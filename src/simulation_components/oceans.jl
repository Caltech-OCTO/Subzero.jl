export Ocean

# See CellFloes documentation below
struct CellStresses{FT<:AbstractFloat}
    τx::Vector{FT}
    τy::Vector{FT}
    npoints::Vector{Int}
end

"""
    CellStresses{FT}()

Constructs an CellStresses object with empty lists for fields.
"""
"""
    CellStresses{FT}

Struct to collect stress from ice floes on ocean grid cells. One `CellStresses`
corresponds to one grid cell and is "linked" to a corresponding [`CellFloes`](@ref) object.
The `CellFloes` object records which floes are in a given grid cell and the `CellStresses`
aggregates the total stress felt on the ocean from the ice (on each of the floe's sub-floe
points generated by a subtype of [`AbstractSubFloePointsGenerator`](@ref)) in a given grid
cell. This is needed ONLY for two-way coupling. Due to the prevalence of periodic
boundaries, the grid cell represented by a `CellStresses` object are centered on grid
points (translated by `Δx/2` and `Δy/2` in the x and y directions for a
[`RegRectilinearGrid`](@ref)), rather than on the grid cells defined by the grid object
itself. A `CellStresses` object holds a list of stresses on the ocean where each element is
from a single floe within grid cell. The ith element of the `τx` and `τy` fields are measures
of the total stress from the ith floe in the cell and the `npoints` field is a measure of
how many of the ith floe's sub-floe points contributed to the running total of the stress.
Again, each element in the list corresponds to one floe, which is denoted in the
corresponding [`CellFloes`](@ref) matrix within the grid. 

##  _Fields_
- `τx::Vector{FT}`: list of total x-stress caused by each floe in a cell on the ocean
- `τy::Vector{FT}`: list of total y-stress caused by each floe in a cell on the ocean
- `npoints::Vector{Int}`: list of total number of sub-floe points contributing to each individial floe's stress

Here is how to construct a `CellStresses` object:

    CellStresses([FT = Float64]; τx = nothing, τy = nothing, npoints = nothing)

## _Positional arguments_
- $FT_DEF
## _Keyword arguments_
- `τx::Vector{FT}`: list of total x-stress caused by each floe in a cell on the ocean
- `τy::Vector{FT}`: list of total y-stress caused by each floe in a cell on the ocean
- `npoints::Vector{Int}`: list of total number of sub-floe points contributing to each individial floe's stress

**Note**: If no keyword arguments are provide by the user, an `CellStresses` object with empty
fields will be created. This is the **standard useage** of these objects and they are added to
during the coupling step. If keyword arguments are provided, then all three must be provided
and each vector must be the same size.

"""
function CellStresses(::Type{FT} = Float64; τx = nothing, τy = nothing, npoints = nothing) where {FT}
    if isnothing(τx) || isnothing(τy) || isnothing(npoints)
        τx = Vector{FT}()
        τy = Vector{FT}()
        npoints = Vector{Int}()
    else
        @assert length(τx) == length(τy) == length(npoints) "A CellStresses object requires that all fields be vectors of the same length."
    end
    return CellStresses{FT}(floeidx, Δx, Δy)
end

# Empties each of the three vectors (`τx`, `τy`, and `npoints`) within an CellStresses object
function Base.empty!(cell::CellStresses)
    empty!(cell.τx)
    empty!(cell.τy)
    empty!(cell.npoints)
    return
end

"""
    Ocean{FT<:AbstractFloat}

Simulation ocean holding ocean values on the grid-scale with matricies of the
same size as the model's grid. The struct has the following fields:
- u is the ocean velocities in the x-direction for each grid cell
- v is the ocean velocities in the y-direction for each grid cell
- temp is the ocean temperature for each grid cell
- hflx_factor is a factor to calculate the ocean-atmosphere heat flux for a 
  cell in that grid cell by multiplying by its height
- si_frac is the fraction of area in each grid cell that is covered in sea-ice

Ocean fields must all be matricies with dimensions equal to the number of grid
lines in the model's grid. 
Note: If a periodic boundary is used in the domain, the last grid cell in that
direction will not be used as it is equivalent to the first grid cell. Thus, for
all of these fields, the first and last value in the x and/or y direction should
be equal if the east-west or north-south boundary pair are periodic
respectively.
"""
struct Ocean{FT<:AbstractFloat}
    u::Matrix{FT}
    v::Matrix{FT}
    temp::Matrix{FT}
    hflx_factor::Matrix{FT}
    scells::Matrix{CellStresses{FT}}
    τx::Matrix{FT}
    τy::Matrix{FT}
    si_frac::Matrix{FT}
    dissolved::Matrix{FT}

    function Ocean{FT}(
        u,
        v,
        temp,
        hflx,
        scells,
        τx,
        τy,
        si_frac,
        dissolved,
    ) where {FT <: AbstractFloat}
        if !all(-3 .<= temp .<= 0)
            @warn "Ocean temperatures are above the range for freezing. The \
                thermodynamics aren't currently setup for these conditions."
        end
        if !(size(u) == size(v) == size(τx) == size(τy))
            throw(ArgumentError("One or more of the ocean vector fields aren't \
                the same dimension."))
        end
        if !(size(temp) == size(hflx) == size(si_frac) == size(dissolved))
            throw(ArgumentError("One or more of the ocean tracer fields aren't \
                the same dimension."))
        end
        new{FT}(u, v, temp, hflx, scells, τx, τy, si_frac, dissolved)
    end
end

"""
    Ocean(::Type{FT}, args...)

A float type FT can be provided as the first argument of any Ocean constructor.
An Ocean of type FT will be created by passing all other arguments to the
correct constructor. 
"""
Ocean(::Type{FT}, args...) where {FT <: AbstractFloat} =
    Ocean{FT}(args...)

"""
    Ocean(args...)

If a type isn't specified, Ocean will be of type Float64 and the correct
constructor will be called with all other arguments.
"""
Ocean(args...) = Ocean{Float64}(args...)

"""
    Ocean{FT}(u, v, temp)

Construct model ocean.
Inputs:
    u       <Matrix> ocean x-velocity matrix with u for each grid line
    v       <Matrix> ocean y-velocity matrix with u for each grid line
    temp    <Matrix> temperature matrix with ocean/ice interface temperature for
                each grid line
Output: 
    Model ocean with given velocity and temperature fields on each grid line.
"""
function Ocean{FT}(
    u,
    v,
    temp,
) where {FT <: AbstractFloat}
    Nx, Ny = size(temp) .- 1
    return Ocean{FT}(
        u,
        v,
        temp,
        zeros(FT, Nx + 1, Ny + 1), # heat flux
        [CellStresses{FT}() for i in 1:(Nx + 1), j in 1:(Ny + 1)],
        zeros(FT, Nx + 1, Ny + 1),  # x-stress
        zeros(FT, Nx + 1, Ny + 1),  # y-stress
        zeros(FT, Nx + 1, Ny + 1),  # sea ice fraction
        zeros(FT, Nx + 1, Ny + 1),  # dissolved
    )
end

"""
    Ocean{FT}(grid, u, v, temp)

Construct model's ocean.
Inputs:
    grid    <AbstractRectilinearGrid> model grid
    u       <Real> ocean x-velocity for each grid line
    v       <Real> ocean y-velocity for each grid line
    temp    <Real> temperature at ocean/ice interface per grid cell
Output: 
        Ocean with constant velocity and temperature on each grid line.
"""
Ocean{FT}(
    grid::AbstractRectilinearGrid,
    u,
    v,
    temp,
) where {FT <: AbstractFloat} =
    Ocean{FT}(
        fill(FT(u), grid.Nx + 1, grid.Ny + 1),
        fill(FT(v), grid.Nx + 1, grid.Ny + 1),
        fill(FT(temp), grid.Nx + 1, grid.Ny + 1),
    )
