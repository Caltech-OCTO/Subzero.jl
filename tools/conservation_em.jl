# function calc_orbital_angular_vel(centroid, u, v)
#     x, y = first.(centroid), last.(centroid)
#     rad = sqrt.(x.^2 .+ y.^2)
#     vel = sqrt.(u.^2 .+ v.^2)
#     orbital = zeros(length(x))
#     for i in eachindex(x)
#         Θ = acos(dot([x[i], y[i]], [u[i], v[i]])/(vel[i]* rad[i]))
#         orbital[i] = (vel[i]/rad[i] * sin(Θ))
#     end
#     return orbital
# end

"""
    calc_total_energy(u, v, mass, ξ, moment)

Calculates linear and rotational energy for one timestep given the floe's
velocities, mass, and moment of intertia.
Inputs:
    u       <Vector{Real}> list of floes' u velocities
    v       <Vector{Real}> list of floes' v velocities
    mass    <Vector{Real}> list of floes' masses
    ξ       <Vector{Real}> list of floes' angular velocities
    moment  <Vector{Real}> list of floes' moments of intertia
Outputs:
    linear      <Real> total linear kinetic energy generated by the floes
    rotational  <Real> total rotational kinetic energy generated by the floes
"""
function calc_total_energy(u, v, mass, ξ, moment)
    linear = sum(0.5 * mass .* (u.^2 .+ v.^2))
    rotational = sum(0.5 * moment .* ξ.^2)
    return linear, rotational
end

"""
    calc_total_momentum(u, v, mass, ξ, moment)

Calculates linear and rotational momentum for one timestep given the floe's
velocities, mass, and moment of intertia.
Inputs:
    u       <Vector{Real}> list of floes' u velocities
    v       <Vector{Real}> list of floes' v velocities
    mass    <Vector{Real}> list of floes' masses
    ξ       <Vector{Real}> list of floes' angular velocities
    moment  <Vector{Real}> list of floes' moments of intertia
Outputs:
    linear      <Real> total linear momentum generated by the floes
    angular     <Real> total angular momentum energy generated by the floes
"""
function calc_total_momentum(u, v, mass, ξ, moment)
    linear = sum(mass .* (u .+ v))
    angular = sum(moment .* ξ)
    return linear, angular
end

function summarize_conservation(
    linear_energy,
    rotational_energy,
    linear_momentum,
    angular_momentum,
    dir,
)
    # Energy conservation
    total_energy = linear_energy .+ rotational_energy
    # Plot energy
    plot(
        [total_energy linear_energy rotational_energy],
        title = "Total Kinetic Energy",
        xlabel = "10 Timesteps",
        ylabel = "[N]",
        label=["total" "linear" "rotational"]
    )

    savefig(joinpath(dir, "energy_conservation.png"))
    # Changes in energy
    println("Difference in starting energy and ending energy: ",
        total_energy[end] - total_energy[1]
    )
    # Percent change in energy
    divisor = total_energy[1] > 0 ? total_energy[1] : eps()
    println("Percent change in energy from t=1 to end: ",
        (total_energy[end] - total_energy[1])/divisor * 100
    )

    # Momentum conservation
    total_momentum = linear_momentum .+ angular_momentum
    # Plot momentum
    plot(
        [total_momentum linear_momentum angular_momentum],
        title = "Total Momentum",
        xlabel = "10 Timesteps",
        ylabel = "[N * s]",
        label=["total" "linear" "angular"]
    )
    # Changes in momentum
    savefig(joinpath(dir, "momentum_conservation.png"))
    println("Difference in starting moment and ending momentum: ",
    total_momentum[end] - total_momentum[1]
    )
    # Percent change in momentum
    divisor = total_momentum[1] > 0 ? total_momentum[1] : eps()
    println("Percent change in momentum from t=1 to end: ",
        (total_momentum[end] - total_momentum[1])/divisor * 100
    )
end

"""
    check_energy_momentum_conservation(filename, dir)

Calculates total kinetic energy and momentum at each timestep and plots the
output to check for conservation from floe outputwriter file. Also gives basic
statistics about total changes in energy and momentum.
Inputs:
    filename    <String> floe outputwriter filename + path
    dir         <String> directory to save total energy and momentum
                    conservation plots
Outputs:
    Saves energy and momentum plots over time to given directory. Prints total
    change and percentage change in both energy and momentum.
"""
function check_energy_momentum_conservation_julia(filename, dir)
    file = jldopen(filename, "r")
    tsteps = keys(file["centroid"])
    ntsteps = length(tsteps)
    linear_energy = zeros(ntsteps)
    rotational_energy = zeros(ntsteps)
    linear_momentum = zeros(ntsteps)
    angular_momentum = zeros(ntsteps)
    for i in eachindex(tsteps)
        t = tsteps[i]
        # Needed values
        parent_idx = file["ghost_id"][t] .== 0
        mass = file["mass"][t][parent_idx]
        moment = file["moment"][t][parent_idx]
        u = file["u"][t][parent_idx]
        v = file["v"][t][parent_idx]
        ξ = file["ξ"][t][parent_idx]
        # calculations
        linear_energy[i], rotational_energy[i] = calc_total_energy(
            u,
            v,
            mass,
            ξ,
            moment,
        )
        linear_momentum[i], angular_momentum[i] = calc_total_momentum(
            u,
            v,
            mass,
            ξ,
            moment,
        )
    end
    close(file)
    summarize_conservation(
        linear_energy,
        rotational_energy,
        linear_momentum,
        angular_momentum,
        dir,
    )
end


#mat_path = "/Users/skylargering/src/SubZero/Floes"

function check_energy_momentum_conservation_matlab(mat_path, dir)
    mat_files = readdir(mat_path)
    mat_files = mat_files[last.(splitext.(mat_files)) .== ".mat"]
    ntsteps = length(mat_files)
    linear_energy = zeros(ntsteps)
    rotational_energy = zeros(ntsteps)
    linear_momentum = zeros(ntsteps)
    angular_momentum = zeros(ntsteps)
    for (i, file) in enumerate(mat_files)
        mat_data = matread(joinpath(mat_path, file))
        # Needed values
        mass = mat_data["Floe"]["mass"]'
        println(length(mass))
        moment = mat_data["Floe"]["inertia_moment"]'
        u = mat_data["Floe"]["Ui"]'
        v = mat_data["Floe"]["Vi"]'
        ξ = mat_data["Floe"]["ksi_ice"]'
        # calculations
        linear_energy[i], rotational_energy[i] = calc_total_energy(
            u,
            v,
            mass,
            ξ,
            moment,
        )
        linear_momentum[i], angular_momentum[i] = calc_total_momentum(
            u,
            v,
            mass,
            ξ,
            moment,
        )
    end
    summarize_conservation(
        linear_energy,
        rotational_energy,
        linear_momentum,
        angular_momentum,
        dir,
    )
end


using JLD2, Random, SplitApplyCombine, Statistics, StructArrays, Subzero, BenchmarkTools, Plots
import LibGEOS as LG

const FT = Float64
const Lx = 1e5
const Ly = Lx
const Δgrid = 1e4
const hmean = 0.25
const Δh = 0.0
const Δt = 10
grid = RegRectilinearGrid(
    FT,
    (0, Lx),
    (0, Ly),
    Δgrid,
    Δgrid,
)

ocean = Ocean(grid, 0.0, 0.0, 0.0)
atmos = Atmos(grid, 0.0, 0.0, 0.0)
nboundary = PeriodicBoundary(grid, North())
sboundary = PeriodicBoundary(grid, South())
eboundary = PeriodicBoundary(grid, East())
wboundary = PeriodicBoundary(grid, West())
domain = Domain(nboundary, sboundary, eboundary, wboundary)

rng = Xoshiro(1)
floe_arr = initialize_floe_field(
    15,
    [0.7],
    domain,
    hmean,
    Δh,
    rng = rng,
    nhistory = 1000,
)
nfloes = length(floe_arr)
floe_arr.u .= rand(rng, nfloes)
floe_arr.v .= rand(rng, nfloes)
# floe_arr.ξ .= rand(rng, nfloes)
# floe_arr = initialize_floe_field(
#     [[[[2e4, 2e4], [2e4, 5e4], [5e4, 5e4], [5e4, 2e4], [2e4, 2e4]]],
#      [[[6e4, 2e4], [6e4, 5e4], [9e4, 5e4], [9e4, 2e4], [6e4, 2e4]]]],
#     domain,
#     hmean,
#     Δh,
#     rng = rng,
#     nhistory = 1000,
# )
# floe_arr.u[1] = 1.0
# floe_arr.u[2] = -1.0
#floe_arr = load("output/sim/initial_state.jld2", "sim").model.floes

model = Model(grid, ocean, atmos, domain, floe_arr)

dir = "output/random_velocities"
initwriter = InitialStateOutputWriter(
    dir = dir,
    overwrite = true,
)
floewriter = FloeOutputWriter(
    10,
    dir = dir,
    filename = "floes",
    overwrite = true,
)
writers = OutputWriters(
    initialwriters = StructArray([initwriter]),
    floewriters = StructArray([floewriter]),
)

modulus = 1.5e3*(mean(sqrt.(floe_arr.area)) + minimum(sqrt.(floe_arr.area)))
consts = Constants(E = modulus, μ = 0.0)
coupling_settings = CouplingSettings(coupling_on = false)
fracture_settings = FractureSettings(
        fractures_on = false,
        criteria = HiblerYieldCurve(floe_arr),
        Δt = 75,
        npieces = 3,
        nhistory = 1000,
        deform_on = false,
)
simulation = Simulation(
    model = model,
    consts = consts,
    Δt = Δt,
    nΔt = 5000,
    verbose = true,
    fracture_settings = fracture_settings,
    coupling_settings = coupling_settings,
    writers = writers
)
run!(simulation)
Subzero.create_sim_gif(
    joinpath(dir, "floes.jld2"), 
    joinpath(dir, "initial_state.jld2"),
    joinpath(dir, "test.gif"),
)

check_energy_momentum_conservation(joinpath(dir, "floes.jld2"), dir)
