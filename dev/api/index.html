<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference ¬∑ Subzero.jl</title><meta name="title" content="API Reference ¬∑ Subzero.jl"/><meta property="og:title" content="API Reference ¬∑ Subzero.jl"/><meta property="twitter:title" content="API Reference ¬∑ Subzero.jl"/><meta name="description" content="Documentation for Subzero.jl."/><meta property="og:description" content="Documentation for Subzero.jl."/><meta property="twitter:description" content="Documentation for Subzero.jl."/><meta property="og:url" content="https://Caltech-OCTO.github.io/SubzeroDocumentation/stable/api/"/><meta property="twitter:url" content="https://Caltech-OCTO.github.io/SubzeroDocumentation/stable/api/"/><link rel="canonical" href="https://Caltech-OCTO.github.io/SubzeroDocumentation/stable/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Subzero.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#All-methods"><span>All methods</span></a></li></ul></li><li><span class="tocitem">Improving Subzero</span><ul><li><a class="tocitem" href="../contribute/">Contributing</a></li><li><a class="tocitem" href="../devdocs/">Developer Documentation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Caltech-OCTO/Subzero.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-Subzero-API-documentation"><a class="docs-heading-anchor" href="#Full-Subzero-API-documentation">Full Subzero API documentation</a><a id="Full-Subzero-API-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Subzero-API-documentation" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This page is still very much WIP!</p></div></div><p>Documentation for <a href="https://github.com/Caltech-OCTO/Subzero.jl">Subzero</a>&#39;s full API (only for reference!).</p><ul><li><a href="../#Subzero"><code>Subzero</code></a></li><li><a href="#Subzero.Subzero"><code>Subzero.Subzero</code></a></li><li><a href="#Subzero.AbstractBoundary"><code>Subzero.AbstractBoundary</code></a></li><li><a href="#Subzero.AbstractDirection"><code>Subzero.AbstractDirection</code></a></li><li><a href="#Subzero.AbstractDomainElement"><code>Subzero.AbstractDomainElement</code></a></li><li><a href="#Subzero.AbstractFractureCriteria"><code>Subzero.AbstractFractureCriteria</code></a></li><li><a href="#Subzero.AbstractGrid"><code>Subzero.AbstractGrid</code></a></li><li><a href="#Subzero.AbstractOutputWriter"><code>Subzero.AbstractOutputWriter</code></a></li><li><a href="#Subzero.AbstractStressCalculator"><code>Subzero.AbstractStressCalculator</code></a></li><li><a href="#Subzero.AbstractSubFloePointsGenerator"><code>Subzero.AbstractSubFloePointsGenerator</code></a></li><li><a href="#Subzero.Atmos-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.Atmos</code></a></li><li><a href="#Subzero.Atmos-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Atmos</code></a></li><li><a href="#Subzero.Atmos"><code>Subzero.Atmos</code></a></li><li><a href="#Subzero.Atmos-Tuple"><code>Subzero.Atmos</code></a></li><li><a href="#Subzero.CellFloes"><code>Subzero.CellFloes</code></a></li><li><a href="#Subzero.CellFloes-Union{Tuple{}, Tuple{FT}} where FT"><code>Subzero.CellFloes</code></a></li><li><a href="#Subzero.CheckpointOutputWriter"><code>Subzero.CheckpointOutputWriter</code></a></li><li><a href="#Subzero.CheckpointOutputWriter-Tuple{Any}"><code>Subzero.CheckpointOutputWriter</code></a></li><li><a href="#Subzero.CheckpointOutputWriter"><code>Subzero.CheckpointOutputWriter</code></a></li><li><a href="#Subzero.CollisionBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}"><code>Subzero.CollisionBoundary</code></a></li><li><a href="#Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection"><code>Subzero.CollisionBoundary</code></a></li><li><a href="#Subzero.CollisionBoundary"><code>Subzero.CollisionBoundary</code></a></li><li><a href="#Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}"><code>Subzero.CollisionBoundary</code></a></li><li><a href="#Subzero.CollisionSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.CollisionSettings</code></a></li><li><a href="#Subzero.CollisionSettings"><code>Subzero.CollisionSettings</code></a></li><li><a href="#Subzero.Constants-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.Constants</code></a></li><li><a href="#Subzero.Constants-Tuple"><code>Subzero.Constants</code></a></li><li><a href="#Subzero.CouplingSettings"><code>Subzero.CouplingSettings</code></a></li><li><a href="#Subzero.DamageStressCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.DamageStressCalculator</code></a></li><li><a href="#Subzero.DamageStressCalculator-Tuple"><code>Subzero.DamageStressCalculator</code></a></li><li><a href="#Subzero.DamageStressCalculator"><code>Subzero.DamageStressCalculator</code></a></li><li><a href="#Subzero.DecayAreaScaledCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.DecayAreaScaledCalculator</code></a></li><li><a href="#Subzero.DecayAreaScaledCalculator"><code>Subzero.DecayAreaScaledCalculator</code></a></li><li><a href="#Subzero.DecayAreaScaledCalculator-Tuple"><code>Subzero.DecayAreaScaledCalculator</code></a></li><li><a href="#Subzero.Domain-Union{Tuple{WB}, Tuple{EB}, Tuple{SB}, Tuple{NB}, Tuple{FT}, Tuple{NB, SB, EB, WB}} where {FT&lt;:AbstractFloat, NB&lt;:AbstractBoundary{North, FT}, SB&lt;:AbstractBoundary{South, FT}, EB&lt;:AbstractBoundary{East, FT}, WB&lt;:AbstractBoundary{West, FT}}"><code>Subzero.Domain</code></a></li><li><a href="#Subzero.Domain"><code>Subzero.Domain</code></a></li><li><a href="#Subzero.East"><code>Subzero.East</code></a></li><li><a href="#Subzero.Floe-Union{Tuple{FT}, Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Floe</code></a></li><li><a href="#Subzero.Floe-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.Floe</code></a></li><li><a href="#Subzero.Floe-Tuple"><code>Subzero.Floe</code></a></li><li><a href="#Subzero.Floe-Union{Tuple{FT}, Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Floe</code></a></li><li><a href="#Subzero.Floe"><code>Subzero.Floe</code></a></li><li><a href="#Subzero.FloeOutputWriter-Tuple{Any}"><code>Subzero.FloeOutputWriter</code></a></li><li><a href="#Subzero.FloeOutputWriter"><code>Subzero.FloeOutputWriter</code></a></li><li><a href="#Subzero.FloeOutputWriter"><code>Subzero.FloeOutputWriter</code></a></li><li><a href="#Subzero.FloeSettings"><code>Subzero.FloeSettings</code></a></li><li><a href="#Subzero.FloeSettings-Union{Tuple{Type{FT}}, Tuple{CT}, Tuple{GT}, Tuple{FT}} where {FT&lt;:AbstractFloat, GT&lt;:Subzero.AbstractSubFloePointsGenerator, CT&lt;:AbstractStressCalculator}"><code>Subzero.FloeSettings</code></a></li><li><a href="#Subzero.FractureSettings"><code>Subzero.FractureSettings</code></a></li><li><a href="#Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Any, AbstractGrid, Any}} where FT&lt;:AbstractFloat"><code>Subzero.GridOutputWriter</code></a></li><li><a href="#Subzero.GridOutputWriter"><code>Subzero.GridOutputWriter</code></a></li><li><a href="#Subzero.GridOutputWriter-Tuple{GridOutputWriter}"><code>Subzero.GridOutputWriter</code></a></li><li><a href="#Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.GridOutputWriter</code></a></li><li><a href="#Subzero.GridOutputWriter-Tuple"><code>Subzero.GridOutputWriter</code></a></li><li><a href="#Subzero.HiblerYieldCurve-Tuple"><code>Subzero.HiblerYieldCurve</code></a></li><li><a href="#Subzero.HiblerYieldCurve-Union{Tuple{StructArrays.StructArray{&lt;:Floe{FT}}}, Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.HiblerYieldCurve</code></a></li><li><a href="#Subzero.HiblerYieldCurve"><code>Subzero.HiblerYieldCurve</code></a></li><li><a href="#Subzero.HiblerYieldCurve-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.HiblerYieldCurve</code></a></li><li><a href="#Subzero.IceStressCell"><code>Subzero.IceStressCell</code></a></li><li><a href="#Subzero.IceStressCell-Union{Tuple{}, Tuple{FT}} where FT"><code>Subzero.IceStressCell</code></a></li><li><a href="#Subzero.InitialStateOutputWriter"><code>Subzero.InitialStateOutputWriter</code></a></li><li><a href="#Subzero.InitialStateOutputWriter-Tuple{}"><code>Subzero.InitialStateOutputWriter</code></a></li><li><a href="#Subzero.InitialStateOutputWriter-Tuple{InitialStateOutputWriter}"><code>Subzero.InitialStateOutputWriter</code></a></li><li><a href="#Subzero.InteractionFields"><code>Subzero.InteractionFields</code></a></li><li><a href="#Subzero.Model"><code>Subzero.Model</code></a></li><li><a href="#Subzero.MohrsCone-Union{Tuple, Tuple{FT}} where FT"><code>Subzero.MohrsCone</code></a></li><li><a href="#Subzero.MohrsCone-Tuple"><code>Subzero.MohrsCone</code></a></li><li><a href="#Subzero.MohrsCone-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.MohrsCone</code></a></li><li><a href="#Subzero.MohrsCone"><code>Subzero.MohrsCone</code></a></li><li><a href="#Subzero.MonteCarloPointsGenerator"><code>Subzero.MonteCarloPointsGenerator</code></a></li><li><a href="#Subzero.MonteCarloPointsGenerator-Tuple"><code>Subzero.MonteCarloPointsGenerator</code></a></li><li><a href="#Subzero.MonteCarloPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.MonteCarloPointsGenerator</code></a></li><li><a href="#Subzero.MovingBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection"><code>Subzero.MovingBoundary</code></a></li><li><a href="#Subzero.MovingBoundary"><code>Subzero.MovingBoundary</code></a></li><li><a href="#Subzero.MovingBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}"><code>Subzero.MovingBoundary</code></a></li><li><a href="#Subzero.MovingBoundary-Union{Tuple{FT}, Tuple{D}, Tuple{Any, Any, Any}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}"><code>Subzero.MovingBoundary</code></a></li><li><a href="#Subzero.NoFracture"><code>Subzero.NoFracture</code></a></li><li><a href="#Subzero.NonPeriodicBoundary"><code>Subzero.NonPeriodicBoundary</code></a></li><li><a href="#Subzero.North"><code>Subzero.North</code></a></li><li><a href="#Subzero.Ocean-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.Ocean</code></a></li><li><a href="#Subzero.Ocean-Tuple"><code>Subzero.Ocean</code></a></li><li><a href="#Subzero.Ocean-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Ocean</code></a></li><li><a href="#Subzero.Ocean-Union{Tuple{FT}, Tuple{Any, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Ocean</code></a></li><li><a href="#Subzero.Ocean"><code>Subzero.Ocean</code></a></li><li><a href="#Subzero.OpenBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection"><code>Subzero.OpenBoundary</code></a></li><li><a href="#Subzero.OpenBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}"><code>Subzero.OpenBoundary</code></a></li><li><a href="#Subzero.OpenBoundary"><code>Subzero.OpenBoundary</code></a></li><li><a href="#Subzero.OpenBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}"><code>Subzero.OpenBoundary</code></a></li><li><a href="#Subzero.OutputWriters"><code>Subzero.OutputWriters</code></a></li><li><a href="#Subzero.PeriodicBoundary"><code>Subzero.PeriodicBoundary</code></a></li><li><a href="#Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}"><code>Subzero.PeriodicBoundary</code></a></li><li><a href="#Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection"><code>Subzero.PeriodicBoundary</code></a></li><li><a href="#Subzero.PeriodicBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}"><code>Subzero.PeriodicBoundary</code></a></li><li><a href="#Subzero.PolyVec"><code>Subzero.PolyVec</code></a></li><li><a href="#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Int64, Int64, Tuple, Tuple}} where FT&lt;:AbstractFloat"><code>Subzero.RegRectilinearGrid</code></a></li><li><a href="#Subzero.RegRectilinearGrid-Tuple"><code>Subzero.RegRectilinearGrid</code></a></li><li><a href="#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Tuple, Tuple, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.RegRectilinearGrid</code></a></li><li><a href="#Subzero.RegRectilinearGrid"><code>Subzero.RegRectilinearGrid</code></a></li><li><a href="#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.RegRectilinearGrid</code></a></li><li><a href="#Subzero.RidgeRaftSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.RidgeRaftSettings</code></a></li><li><a href="#Subzero.RidgeRaftSettings"><code>Subzero.RidgeRaftSettings</code></a></li><li><a href="#Subzero.RingVec"><code>Subzero.RingVec</code></a></li><li><a href="#Subzero.SimplificationSettings"><code>Subzero.SimplificationSettings</code></a></li><li><a href="#Subzero.SimplificationSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.SimplificationSettings</code></a></li><li><a href="#Subzero.Simulation"><code>Subzero.Simulation</code></a></li><li><a href="#Subzero.South"><code>Subzero.South</code></a></li><li><a href="#Subzero.StatusTag"><code>Subzero.StatusTag</code></a></li><li><a href="#Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.SubGridPointsGenerator</code></a></li><li><a href="#Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{RegRectilinearGrid, Int64}} where FT&lt;:AbstractFloat"><code>Subzero.SubGridPointsGenerator</code></a></li><li><a href="#Subzero.SubGridPointsGenerator"><code>Subzero.SubGridPointsGenerator</code></a></li><li><a href="#Subzero.SubGridPointsGenerator-Tuple"><code>Subzero.SubGridPointsGenerator</code></a></li><li><a href="#Subzero.SubzeroLogger"><code>Subzero.SubzeroLogger</code></a></li><li><a href="#Subzero.SubzeroLogger"><code>Subzero.SubzeroLogger</code></a></li><li><a href="#Subzero.SubzeroLogger"><code>Subzero.SubzeroLogger</code></a></li><li><a href="#Subzero.TopographyElement"><code>Subzero.TopographyElement</code></a></li><li><a href="#Subzero.TopographyElement-Tuple"><code>Subzero.TopographyElement</code></a></li><li><a href="#Subzero.TopographyElement-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.TopographyElement</code></a></li><li><a href="#Subzero.TopographyElement-Union{Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.TopographyElement</code></a></li><li><a href="#Subzero.TopographyElement-Union{Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.TopographyElement</code></a></li><li><a href="#Subzero.WeldSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.WeldSettings</code></a></li><li><a href="#Subzero.WeldSettings"><code>Subzero.WeldSettings</code></a></li><li><a href="#Subzero.West"><code>Subzero.West</code></a></li><li><a href="#Base.::-Tuple{InteractionFields, InteractionFields}"><code>Base.::</code></a></li><li><a href="#Base.empty!-Tuple{CellFloes}"><code>Base.empty!</code></a></li><li><a href="#Base.empty!-Tuple{IceStressCell}"><code>Base.empty!</code></a></li><li><a href="#Base.to_index-Tuple{InteractionFields}"><code>Base.to_index</code></a></li><li><a href="#Logging.handle_message-Tuple{Subzero.SubzeroLogger, Vararg{Any, 7}}"><code>Logging.handle_message</code></a></li><li><a href="#Subzero._calculate_hibler-Union{Tuple{FT}, Tuple{Type{FT}, Any, Any, Any}} where FT"><code>Subzero._calculate_hibler</code></a></li><li><a href="#Subzero._calculate_mohrs-Union{Tuple{Type{FT}}, Tuple{FT}, Tuple{Type{FT}, Any}, Tuple{Type{FT}, Any, Any}, Tuple{Type{FT}, Any, Any, Any}} where FT"><code>Subzero._calculate_mohrs</code></a></li><li><a href="#Subzero._calculate_mohrs-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 4}}} where FT"><code>Subzero._calculate_mohrs</code></a></li><li><a href="#Subzero._initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Vararg{Any, 4}}} where FT&lt;:AbstractFloat"><code>Subzero._initialize_floe_field</code></a></li><li><a href="#Subzero._initialize_floe_field-Union{Tuple{V}, Tuple{FT}, Tuple{Type{FT}, V, Any, Any, Any}} where {FT&lt;:AbstractFloat, V&lt;:(AbstractVector)}"><code>Subzero._initialize_floe_field</code></a></li><li><a href="#Subzero.add_floe_ghosts!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}"><code>Subzero.add_floe_ghosts!</code></a></li><li><a href="#Subzero.add_floe_volume!-NTuple{4, Any}"><code>Subzero.add_floe_volume!</code></a></li><li><a href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s86&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s85&quot;&lt;:PeriodicBoundary, var&quot;#s84&quot;&lt;:PeriodicBoundary, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat"><code>Subzero.add_ghosts!</code></a></li><li><a href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:PeriodicBoundary, var&quot;#s86&quot;&lt;:PeriodicBoundary, var&quot;#s85&quot;&lt;:PeriodicBoundary, var&quot;#s84&quot;&lt;:PeriodicBoundary, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat"><code>Subzero.add_ghosts!</code></a></li><li><a href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s86&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s85&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s84&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat"><code>Subzero.add_ghosts!</code></a></li><li><a href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:PeriodicBoundary, var&quot;#s86&quot;&lt;:PeriodicBoundary, var&quot;#s85&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s84&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat"><code>Subzero.add_ghosts!</code></a></li><li><a href="#Subzero.add_point!-Tuple{CellFloes, Any, Any, Any}"><code>Subzero.add_point!</code></a></li><li><a href="#Subzero.add_point!-Tuple{CellFloes, IceStressCell, Vararg{Any, 5}}"><code>Subzero.add_point!</code></a></li><li><a href="#Subzero.auto_extension-Tuple{Any, Any}"><code>Subzero.auto_extension</code></a></li><li><a href="#Subzero.bin_floe_centroids-NTuple{5, Any}"><code>Subzero.bin_floe_centroids</code></a></li><li><a href="#Subzero.boundary_coords-Tuple{Any, Type{North}}"><code>Subzero.boundary_coords</code></a></li><li><a href="#Subzero.boundary_coords-Tuple{Any, Type{West}}"><code>Subzero.boundary_coords</code></a></li><li><a href="#Subzero.boundary_coords-Tuple{Any, Type{South}}"><code>Subzero.boundary_coords</code></a></li><li><a href="#Subzero.boundary_coords-Tuple{Any, Type{East}}"><code>Subzero.boundary_coords</code></a></li><li><a href="#Subzero.calc_angular_momentum-NTuple{7, Any}"><code>Subzero.calc_angular_momentum</code></a></li><li><a href="#Subzero.calc_atmosphere_forcing-NTuple{7, Any}"><code>Subzero.calc_atmosphere_forcing</code></a></li><li><a href="#Subzero.calc_elastic_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat"><code>Subzero.calc_elastic_forces</code></a></li><li><a href="#Subzero.calc_eulerian_data!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}"><code>Subzero.calc_eulerian_data!</code></a></li><li><a href="#Subzero.calc_friction_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Matrix{FT}, Any, Any, Any}} where FT"><code>Subzero.calc_friction_forces</code></a></li><li><a href="#Subzero.calc_kinetic_energy-NTuple{5, Any}"><code>Subzero.calc_kinetic_energy</code></a></li><li><a href="#Subzero.calc_linear_momentum-Tuple{Any, Any, Any}"><code>Subzero.calc_linear_momentum</code></a></li><li><a href="#Subzero.calc_normal_force-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat"><code>Subzero.calc_normal_force</code></a></li><li><a href="#Subzero.calc_ocean_forcing!-NTuple{9, Any}"><code>Subzero.calc_ocean_forcing!</code></a></li><li><a href="#Subzero.calc_one_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT"><code>Subzero.calc_one_way_coupling!</code></a></li><li><a href="#Subzero.calc_strain!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}}, Tuple{FT}} where FT"><code>Subzero.calc_strain!</code></a></li><li><a href="#Subzero.calc_stress!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Any, Any}} where FT"><code>Subzero.calc_stress!</code></a></li><li><a href="#Subzero.calc_subfloe_values!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat"><code>Subzero.calc_subfloe_values!</code></a></li><li><a href="#Subzero.calc_torque!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{&lt;:Floe{FT}}}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.calc_torque!</code></a></li><li><a href="#Subzero.calc_two_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, RegRectilinearGrid, Vararg{Any, 6}}} where FT"><code>Subzero.calc_two_way_coupling!</code></a></li><li><a href="#Subzero.center_cell_coords-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Int64, RegRectilinearGrid, Any, Any}} where FT"><code>Subzero.center_cell_coords</code></a></li><li><a href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}"><code>Subzero.check_cell_bounds</code></a></li><li><a href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.check_cell_bounds</code></a></li><li><a href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.check_cell_bounds</code></a></li><li><a href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, PeriodicBoundary}"><code>Subzero.check_cell_bounds</code></a></li><li><a href="#Subzero.check_energy_momentum_conservation_julia"><code>Subzero.check_energy_momentum_conservation_julia</code></a></li><li><a href="#Subzero.check_energy_momentum_conservation_matlab"><code>Subzero.check_energy_momentum_conservation_matlab</code></a></li><li><a href="#Subzero.check_for_edge_mid-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT"><code>Subzero.check_for_edge_mid</code></a></li><li><a href="#Subzero.compare_floe_data-Tuple{Any, Any}"><code>Subzero.compare_floe_data</code></a></li><li><a href="#Subzero.compare_grid_data-Tuple{Any, Any}"><code>Subzero.compare_grid_data</code></a></li><li><a href="#Subzero.compare_oa_checkpointer_data-Tuple{Any, Any}"><code>Subzero.compare_oa_checkpointer_data</code></a></li><li><a href="#Subzero.conserve_momentum_change_floe_shape!"><code>Subzero.conserve_momentum_change_floe_shape!</code></a></li><li><a href="#Subzero.conserve_momentum_fracture_floe!-Union{Tuple{FT}, Tuple{Any, StructArrays.StructArray{&lt;:Floe{FT}}, Any}} where FT"><code>Subzero.conserve_momentum_fracture_floe!</code></a></li><li><a href="#Subzero.conserve_momentum_transfer_mass!"><code>Subzero.conserve_momentum_transfer_mass!</code></a></li><li><a href="#Subzero.deepcopy_floe-Union{Tuple{StructArrays.LazyRow{Floe{FT}}}, Tuple{FT}} where FT"><code>Subzero.deepcopy_floe</code></a></li><li><a href="#Subzero.deform_floe!-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Vararg{Any, 4}}} where FT"><code>Subzero.deform_floe!</code></a></li><li><a href="#Subzero.determine_fractures-Tuple{Any, Subzero.AbstractFractureCriteria, Any}"><code>Subzero.determine_fractures</code></a></li><li><a href="#Subzero.dissolve_floe!-Tuple{Any, RegRectilinearGrid, Any, Any}"><code>Subzero.dissolve_floe!</code></a></li><li><a href="#Subzero.domain_in_grid-Tuple{Domain, AbstractGrid}"><code>Subzero.domain_in_grid</code></a></li><li><a href="#Subzero.euclidian_dist-Tuple{Any, Any, Any}"><code>Subzero.euclidian_dist</code></a></li><li><a href="#Subzero.find_center_cell_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.find_center_cell_index</code></a></li><li><a href="#Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{East, FT}, PeriodicBoundary{West, FT}}} where FT&lt;:AbstractFloat"><code>Subzero.find_ghosts!</code></a></li><li><a href="#Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{North, FT}, PeriodicBoundary{South, FT}}} where FT&lt;:AbstractFloat"><code>Subzero.find_ghosts!</code></a></li><li><a href="#Subzero.find_grid_cell_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.find_grid_cell_index</code></a></li><li><a href="#Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, PeriodicBoundary}"><code>Subzero.find_interp_knots</code></a></li><li><a href="#Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.find_interp_knots</code></a></li><li><a href="#Subzero.find_poly_coords-Tuple{Any}"><code>Subzero.find_poly_coords</code></a></li><li><a href="#Subzero.find_shared_edges_midpoint-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any}} where FT"><code>Subzero.find_shared_edges_midpoint</code></a></li><li><a href="#Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Any, Union{CollisionBoundary, MovingBoundary, TopographyElement}, Any, Any, Any, FT}} where FT"><code>Subzero.floe_domain_element_interaction!</code></a></li><li><a href="#Subzero.floe_domain_element_interaction!-Tuple{Any, PeriodicBoundary, Vararg{Any, 4}}"><code>Subzero.floe_domain_element_interaction!</code></a></li><li><a href="#Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, OpenBoundary, Vararg{Any, 4}}} where FT"><code>Subzero.floe_domain_element_interaction!</code></a></li><li><a href="#Subzero.floe_domain_interaction!-Union{Tuple{FT}, Tuple{Any, Domain, Any, Any, FT}} where FT&lt;:AbstractFloat"><code>Subzero.floe_domain_interaction!</code></a></li><li><a href="#Subzero.floe_domain_raft!-Tuple{Any, Any, Union{StructArrays.LazyRow{&lt;:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}"><code>Subzero.floe_domain_raft!</code></a></li><li><a href="#Subzero.floe_domain_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Union{StructArrays.LazyRow{&lt;:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}} where FT"><code>Subzero.floe_domain_ridge!</code></a></li><li><a href="#Subzero.floe_floe_interaction!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat"><code>Subzero.floe_floe_interaction!</code></a></li><li><a href="#Subzero.floe_floe_raft!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT"><code>Subzero.floe_floe_raft!</code></a></li><li><a href="#Subzero.floe_floe_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT"><code>Subzero.floe_floe_ridge!</code></a></li><li><a href="#Subzero.floe_to_grid_info!-Union{Tuple{FT}, Tuple{Any, Any, Any, FT, FT, Vararg{Any, 5}}} where FT"><code>Subzero.floe_to_grid_info!</code></a></li><li><a href="#Subzero.fracture_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat"><code>Subzero.fracture_floes!</code></a></li><li><a href="#Subzero.fuse_floes!-NTuple{5, Any}"><code>Subzero.fuse_floes!</code></a></li><li><a href="#Subzero.fuse_two_floes!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 5}}} where FT"><code>Subzero.fuse_two_floes!</code></a></li><li><a href="#Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{MonteCarloPointsGenerator{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat"><code>Subzero.generate_subfloe_points</code></a></li><li><a href="#Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{SubGridPointsGenerator{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat"><code>Subzero.generate_subfloe_points</code></a></li><li><a href="#Subzero.generate_voronoi_coords-Union{Tuple{FT}, Tuple{Int64, Any, Any, Vector{&lt;:Array{Array{Vector{var&quot;#s81&quot;}, 1}, 1} where var&quot;#s81&quot;&lt;:FT}, Any, Int64}} where FT&lt;:AbstractFloat"><code>Subzero.generate_voronoi_coords</code></a></li><li><a href="#Subzero.get_known_grid_outputs-Tuple{}"><code>Subzero.get_known_grid_outputs</code></a></li><li><a href="#Subzero.get_velocity-Union{Tuple{FT}, Tuple{Subzero.AbstractDomainElement{FT}, Any, Any}} where FT"><code>Subzero.get_velocity</code></a></li><li><a href="#Subzero.get_velocity-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, FT, FT}} where FT"><code>Subzero.get_velocity</code></a></li><li><a href="#Subzero.getattrs-Tuple{Symbol}"><code>Subzero.getattrs</code></a></li><li><a href="#Subzero.ghosts_on_bounds!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}"><code>Subzero.ghosts_on_bounds!</code></a></li><li><a href="#Subzero.grid_cell_index-Tuple{Any, Any, Any}"><code>Subzero.grid_cell_index</code></a></li><li><a href="#Subzero.grid_line_index-Tuple{Any, Any, Any}"><code>Subzero.grid_line_index</code></a></li><li><a href="#Subzero.grid_xc_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.grid_xc_index</code></a></li><li><a href="#Subzero.grid_xg_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.grid_xg_index</code></a></li><li><a href="#Subzero.grid_yc_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.grid_yc_index</code></a></li><li><a href="#Subzero.grid_yg_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.grid_yg_index</code></a></li><li><a href="#Subzero.grids_from_lines-Tuple{Any, Any}"><code>Subzero.grids_from_lines</code></a></li><li><a href="#Subzero.hashole-Union{Tuple{Array{Array{Vector{FT}, 1}, 1}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.hashole</code></a></li><li><a href="#Subzero.hashole-Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat}"><code>Subzero.hashole</code></a></li><li><a href="#Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}"><code>Subzero.in_bounds</code></a></li><li><a href="#Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, PeriodicBoundary}"><code>Subzero.in_bounds</code></a></li><li><a href="#Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.in_bounds</code></a></li><li><a href="#Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.in_bounds</code></a></li><li><a href="#Subzero.initialize_floe_field-Tuple"><code>Subzero.initialize_floe_field</code></a></li><li><a href="#Subzero.initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT"><code>Subzero.initialize_floe_field</code></a></li><li><a href="#Subzero.initialize_jld2_file!-NTuple{5, Any}"><code>Subzero.initialize_jld2_file!</code></a></li><li><a href="#Subzero.initialize_netcdf_file!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 6}}} where FT"><code>Subzero.initialize_netcdf_file!</code></a></li><li><a href="#Subzero.initialize_topography_field-Union{Tuple{FT}, Tuple{Type{FT}, Any}} where FT&lt;:AbstractFloat"><code>Subzero.initialize_topography_field</code></a></li><li><a href="#Subzero.initialize_topography_field-Tuple"><code>Subzero.initialize_topography_field</code></a></li><li><a href="#Subzero.intersect_polys-Union{Tuple{FT}, Tuple{Any, Any}, Tuple{Any, Any, Type{FT}}} where FT"><code>Subzero.intersect_polys</code></a></li><li><a href="#Subzero.level_to_string-Tuple{Any}"><code>Subzero.level_to_string</code></a></li><li><a href="#Subzero.mc_interpolation-NTuple{7, Any}"><code>Subzero.mc_interpolation</code></a></li><li><a href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{South, &lt;:AbstractFloat}}} where FT"><code>Subzero.normal_direction_correct!</code></a></li><li><a href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{North, &lt;:AbstractFloat}}} where FT"><code>Subzero.normal_direction_correct!</code></a></li><li><a href="#Subzero.normal_direction_correct!-Tuple{Any, Any, TopographyElement}"><code>Subzero.normal_direction_correct!</code></a></li><li><a href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{East, &lt;:AbstractFloat}}} where FT"><code>Subzero.normal_direction_correct!</code></a></li><li><a href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{West, &lt;:AbstractFloat}}} where FT"><code>Subzero.normal_direction_correct!</code></a></li><li><a href="#Subzero.periodic_compat-Tuple{PeriodicBoundary, PeriodicBoundary}"><code>Subzero.periodic_compat</code></a></li><li><a href="#Subzero.plot_conservation-NTuple{7, Any}"><code>Subzero.plot_conservation</code></a></li><li><a href="#Subzero.poly_to_floes!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat"><code>Subzero.poly_to_floes!</code></a></li><li><a href="#Subzero.potential_interaction-NTuple{4, Any}"><code>Subzero.potential_interaction</code></a></li><li><a href="#Subzero.prettytime-Tuple{Any}"><code>Subzero.prettytime</code></a></li><li><a href="#Subzero.remove_floe_overlap!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT&lt;:AbstractFloat"><code>Subzero.remove_floe_overlap!</code></a></li><li><a href="#Subzero.remove_floes!-NTuple{5, Any}"><code>Subzero.remove_floes!</code></a></li><li><a href="#Subzero.replace_floe!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT"><code>Subzero.replace_floe!</code></a></li><li><a href="#Subzero.restart!-NTuple{4, Any}"><code>Subzero.restart!</code></a></li><li><a href="#Subzero.rotate_radians!-Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real, Any}"><code>Subzero.rotate_radians!</code></a></li><li><a href="#Subzero.run!-Tuple{Any}"><code>Subzero.run!</code></a></li><li><a href="#Subzero.shift_cell_idx-Tuple{Any, Any, PeriodicBoundary}"><code>Subzero.shift_cell_idx</code></a></li><li><a href="#Subzero.shift_cell_idx-Tuple{Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.shift_cell_idx</code></a></li><li><a href="#Subzero.simplify_floes!-NTuple{7, Any}"><code>Subzero.simplify_floes!</code></a></li><li><a href="#Subzero.smooth_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT&lt;:AbstractFloat"><code>Subzero.smooth_floes!</code></a></li><li><a href="#Subzero.split_floe-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT"><code>Subzero.split_floe</code></a></li><li><a href="#Subzero.startup_sim"><code>Subzero.startup_sim</code></a></li><li><a href="#Subzero.teardown_sim-Tuple{Any}"><code>Subzero.teardown_sim</code></a></li><li><a href="#Subzero.timestep_collisions!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 6}}} where FT&lt;:AbstractFloat"><code>Subzero.timestep_collisions!</code></a></li><li><a href="#Subzero.timestep_coupling!-NTuple{5, Any}"><code>Subzero.timestep_coupling!</code></a></li><li><a href="#Subzero.timestep_floe_properties!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Any, Any}} where FT"><code>Subzero.timestep_floe_properties!</code></a></li><li><a href="#Subzero.timestep_ridging_rafting!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat"><code>Subzero.timestep_ridging_rafting!</code></a></li><li><a href="#Subzero.timestep_sim!"><code>Subzero.timestep_sim!</code></a></li><li><a href="#Subzero.timestep_welding!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat"><code>Subzero.timestep_welding!</code></a></li><li><a href="#Subzero.translate-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.translate</code></a></li><li><a href="#Subzero.translate!-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.translate!</code></a></li><li><a href="#Subzero.update_boundaries!-Tuple{Any, Any}"><code>Subzero.update_boundaries!</code></a></li><li><a href="#Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D&lt;:Union{North, South}, FT&lt;:AbstractFloat}"><code>Subzero.update_boundary!</code></a></li><li><a href="#Subzero.update_boundary!-Tuple{Union{CollisionBoundary, OpenBoundary, PeriodicBoundary}, Any}"><code>Subzero.update_boundary!</code></a></li><li><a href="#Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D&lt;:Union{East, West}, FT&lt;:AbstractFloat}"><code>Subzero.update_boundary!</code></a></li><li><a href="#Subzero.update_criteria!-Union{Tuple{FT}, Tuple{HiblerYieldCurve{FT}, Any}} where FT"><code>Subzero.update_criteria!</code></a></li><li><a href="#Subzero.update_criteria!-Tuple{MohrsCone, Any}"><code>Subzero.update_criteria!</code></a></li><li><a href="#Subzero.update_ghost_timestep_vals!-Tuple{Any, Any, Any}"><code>Subzero.update_ghost_timestep_vals!</code></a></li><li><a href="#Subzero.update_new_rotation_conserve!-NTuple{9, Any}"><code>Subzero.update_new_rotation_conserve!</code></a></li><li><a href="#Subzero.valid_polyvec!-Tuple{Any}"><code>Subzero.valid_polyvec!</code></a></li><li><a href="#Subzero.valid_ringvec!-Tuple{Any}"><code>Subzero.valid_ringvec!</code></a></li><li><a href="#Subzero.which_points_on_edges-Tuple{Any, Any}"><code>Subzero.which_points_on_edges</code></a></li><li><a href="#Subzero.which_vertices_match_points-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Any}} where FT"><code>Subzero.which_vertices_match_points</code></a></li><li><a href="#Subzero.write_checkpoint_data!-Tuple{Any, Any}"><code>Subzero.write_checkpoint_data!</code></a></li><li><a href="#Subzero.write_data!-Tuple{Any, Any, Any}"><code>Subzero.write_data!</code></a></li><li><a href="#Subzero.write_floe_data!-Tuple{Any, Any, Any}"><code>Subzero.write_floe_data!</code></a></li><li><a href="#Subzero.write_grid_data!-NTuple{4, Any}"><code>Subzero.write_grid_data!</code></a></li><li><a href="#Subzero.write_init_state_data!-Tuple{Any}"><code>Subzero.write_init_state_data!</code></a></li></ul><h2 id="All-methods"><a class="docs-heading-anchor" href="#All-methods">All methods</a><a id="All-methods-1"></a><a class="docs-heading-anchor-permalink" href="#All-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Subzero" href="#Subzero.Subzero"><code>Subzero.Subzero</code></a> ‚Äî <span class="docstring-category">Module</span></header><section><div><p><img src="https://github.com/Caltech-OCTO/Subzero.jl/blob/main/docs/src/assets/title.gif?raw=true" alt="Subzero.jl"/></p><p><a href="https://caltech-octo.github.io/Subzero.jl/dev/"><img src="https://img.shields.io/badge/docs-latest-blue.svg" alt="Docs"/></a> <a href="https://github.com/Caltech-OCTO/Subzero.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/Caltech-OCTO/Subzero.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="CI"/></a> <a href="https://codecov.io/gh/Caltech-OCTO/Subzero.jl"><img src="https://codecov.io/gh/Caltech-OCTO/Subzero.jl/branch/main/graph/badge.svg" alt="CodeCov"/></a> <a href="https://www.repostatus.org/#active"><img src="https://www.repostatus.org/badges/latest/active.svg?style=flat-square" alt="Status"/></a></p><p><strong><em>Fast and Flexible Sea Ice Dynamics</em></strong></p><p>Subzero.jl is a native <a href="https://julialang.org/">Julia</a> discrete-element model (DEM) for exploring fine-scale sea ice dynamics,  reimplementing MATLAB model <a href="https://doi.org/10.1029/2022MS003247">SubZero by Manucharyan and Montemuro</a>.</p><ul><li>üöÄ Runs over <strong>35 times faster</strong> that original MATLAB model for title simulation!</li><li>üß© Modular simulation model makes it easy to <strong>customize simulations</strong>!<ul><li>Enable and disable physical processes such as fracturing, ridging, and welding</li><li>Choose algorithms for key processes (or add your own!)</li></ul></li></ul><p><strong><em>Documentation</em></strong></p><p>To learn how to build and run simulations, <a href="https://caltech-octo.github.io/Subzero.jl/dev/">check out our documentation and tutorials</a>!</p><p><strong><em>Installation</em></strong></p><p>Subzero is a <a href="https://julialang.org/packages/">registered Julia package</a>. So to install it,</p><ol><li><p><a href="https://julialang.org/downloads/">Download Julia</a> (version 1.9 or later).</p></li><li><p>Launch Julia and type</p></li></ol><pre><code class="language-julia hljs">julia&gt; using Pkg

julia&gt; Pkg.add(&quot;Subzero&quot;)</code></pre><p><strong><em>Citing</em></strong></p><p>If you use Subzero.jl as part of your research, teaching, or other activities, we would be grateful if you could cite our work. We are currently working on a JOSS paper, which will be linked here. If you are ready to publish before that, please reach out to us to discuss citations.</p><p><strong><em>Contributing</em></strong></p><p>If you‚Äôre interested in contributing to the development Subzero, we would love to have you! We welcome all kinds of contributions from bug reports, to documentation, to features, and suggestions. <strong>We can&#39;t wait to talk to you.</strong></p><p>Please check out <a href="https://caltech-octo.github.io/Subzero.jl/dev/contribute/">our contributers&#39; guide</a> for more details.</p><p><strong><em>Authors</em></strong></p><ul><li>Primary Author: <a href="https://github.com/skygering"><strong>Skylar Gering (@skygering)</strong></a></li></ul><p>The list of <a href="https://github.com/Caltech-OCTO/Subzero.jl/graphs/contributors">Subzero contributors</a>:</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl/graphs/contributors"><img src="https://contrib.rocks/image?repo=Caltech-OCTO/Subzero.jl" alt="Contributers"/></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/Subzero.jl#L4-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.NonPeriodicBoundary" href="#Subzero.NonPeriodicBoundary"><code>Subzero.NonPeriodicBoundary</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonPeriodicBoundary</code></pre><p>Union of all non-peridic boundary types to use as shorthand for dispatch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L420-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.AbstractBoundary" href="#Subzero.AbstractBoundary"><code>Subzero.AbstractBoundary</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBoundary{D&lt;:AbstractDirection, FT}&lt;:AbstractDomainElement{FT}</code></pre><p>An abstract type for the types of boundaries at the edges of the model domain. Boundary types will control behavior of sea ice floes at edges of domain. The direction given by type D denotes which edge of a domain this boundary could be and type FT is the simulation float type (e.g. Float64 or Float32).</p><p>Each boundary type has the coordinates of the boudnary as a field. These should be shapes that completely seal the domain, and should overlap on the corners as seen in the example below:  ________________ |<strong>|____val___|</strong>| &lt;- North coordinates include corners |  |          |  | |  |          |  | &lt;- East and west coordinates ALSO include corners |  |          |  | Each bounday type also has a field called &quot;val&quot; that holds value that defines the line y = val or x = val (depending on boundary direction), such that if the floe crosses that line it would be partially within the boundary. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L152-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.AbstractDirection" href="#Subzero.AbstractDirection"><code>Subzero.AbstractDirection</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDirection</code></pre><p>An abstract type for the boundary cardinal directions within model domain. Boundary direction will control behavior of sea ice floes at edges of domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.AbstractDomainElement" href="#Subzero.AbstractDomainElement"><code>Subzero.AbstractDomainElement</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDomainElement{FT&lt;:AbstractFloat}</code></pre><p>An abstract type for all of the element that create the shape of the domain: the 4 boundary walls that make up the rectangular domain and the topography within the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L142-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.AbstractFractureCriteria" href="#Subzero.AbstractFractureCriteria"><code>Subzero.AbstractFractureCriteria</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFractureCriteria</code></pre><p>Abstract type for fracture criteria. Each struct of this type must have a vertices field representing the criteria in principal stress space. For a given polygon, the minimum and maximum eigenvalues of its stress field will be its location in principal stress space. If that stress point falls outside of the criteria-verticies defined polygon it is a stress great enough to fracture the floe. Otherwise the floe will not be fractured. Each fracture criteria type must also have an update_criteria! function defined that is used to update the criteria each timestep. If the criteria does not need to be updated, this function can be empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.AbstractGrid" href="#Subzero.AbstractGrid"><code>Subzero.AbstractGrid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGrid</code></pre><p>An abstract type for the grid that model will be simulated on. Affects calculation on the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L729-L734">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.AbstractOutputWriter" href="#Subzero.AbstractOutputWriter"><code>Subzero.AbstractOutputWriter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractOutputWriter</code></pre><p>An abstract type for output writers that provide data from simulation runs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.AbstractStressCalculator" href="#Subzero.AbstractStressCalculator"><code>Subzero.AbstractStressCalculator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractStressCalculator{FT &lt;: AbstractFloat}</code></pre><p>Abstract super type for stress calculators, which calculate a floe&#39;s stress from floe interactions. The subtypes serve as dispatch types for the following three calculation methods.</p><p><strong>API</strong></p><p>The following methods must be implemented for all subtypes:</p><ul><li><code>_update_stress_accum!(stress_calculator::AbstractStressCalculator{FT}, curr_stress::Matrix{FT} , floe::FloeType{FT})</code></li><li><code>_scale_principal_stress!(stress_calculator::AbstractStressCalculator{FT}, œÉvals::Matrix{FT}, floe::FloeType{FT}, floe_settings::FloeSettings)</code></li></ul><p><code>_update_stress_accum!</code> is called in the <code>calc_stress!</code> function and takes the stress calculator, the <code>floe</code>&#39;s instantatious stress at the current timestep, and the <code>floe</code> itself and updates the <code>floe</code>&#39;s <code>stress_accum</code> field, which is used when determining floe fracture based off of stress. Within the function, other floe fields can be updated as needed.</p><p><code>_scale_principal_stress!</code> is called within the <code>find_œÉpoint</code> function which is called within the <code>determine_fractures</code> function. This function takes the stress calculator, the <code>floe</code>&#39;s accumulated stress in prinicpal stress space (<code>œÉvals = eigvals(stress_accum)</code>), the <code>floe</code> itself, and the <code>floe_settings</code> and scales <code>œÉvals</code> by some values/ratio using physical properties within <code>floe</code> and <code>floe_settings</code>. This is done to approximate changing the polygon defining the floe&#39;s fracture criteria without having to redefine the fracture  criteria for each floe. This is almost like a proxy for damage. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/stress_calculators.jl#L24-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.AbstractSubFloePointsGenerator" href="#Subzero.AbstractSubFloePointsGenerator"><code>Subzero.AbstractSubFloePointsGenerator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSubFloePointsGenerator</code></pre><p>Abstract type for parameters determining generation of sub-floe points used for interpolation. The points generated using these parameters will be used to find stresses on each floe from the ocean and the atmosphere. There must be a <code>generate_subfloe_points</code> function that dispatches off of the subtype of AbstractSubFloePointsGenerator to generate the points for a given floe. Points generated must all be within a given floe.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Atmos" href="#Subzero.Atmos"><code>Subzero.Atmos</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Atmos velocities in the x-direction (u) and y-direction (v). u and v should match the size of the corresponding model grid so that there is one x and y velocity value for each grid cell. Atmos also needs temperature at the atmosphere/ice interface in each grid cell. Model cannot be constructed if size of atmos fields and grid do not match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/ocean_and_atmos.jl#L174-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Atmos-Tuple" href="#Subzero.Atmos-Tuple"><code>Subzero.Atmos</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Atmos(args...)</code></pre><p>If a type isn&#39;t specified, Atmos will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/ocean_and_atmos.jl#L204-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Atmos-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.Atmos-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Atmos</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Atmos{FT}(grid, u, v)</code></pre><p>Construct model atmosphere of type FT. Inputs:     grid        &lt;AbstractGrid&gt; model&#39;s grid      u           &lt;Real&gt; Atmos x-velocity for each grid cell     v           &lt;Real&gt; Atmos y-velocity for each grid cell     temp        &lt;Real&gt; temperature at atmopshere/ice interface per grid cell Output:      Atmosphere of type FT with constant velocity and temperature over domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/ocean_and_atmos.jl#L212-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Atmos-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.Atmos-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.Atmos</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Atmos(::Type{FT}, args...)</code></pre><p>A float type FT can be provided as the first argument of any Atmos constructor. An Atmos of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/ocean_and_atmos.jl#L194-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CellFloes" href="#Subzero.CellFloes"><code>Subzero.CellFloes</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CellFloes{FT&lt;:AbstractFloat}</code></pre><p>Struct that tracks which floes are within given cell, as well as the translation vector needed to move floe each from current postion into cell if it is in cell due to periodic boundaries. Each index in floeidx is the index of a floe within the cell and the Œîx and Œîy with the same index are that floe&#39;s translation vector. Note: the floeidx is the index of grid cells centered on grid lines, not on the grid cells defined by the regular, rectilinear grid. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L690-L700">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CellFloes-Union{Tuple{}, Tuple{FT}} where FT" href="#Subzero.CellFloes-Union{Tuple{}, Tuple{FT}} where FT"><code>Subzero.CellFloes</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CellFloes{FT}()</code></pre><p>Constructs an CellFloes object with empty lists for fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L707-L711">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CheckpointOutputWriter" href="#Subzero.CheckpointOutputWriter"><code>Subzero.CheckpointOutputWriter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CheckpointOutputWriter(writer::CheckpointOutputWriter, [Œîtout]; kwargs...)</code></pre><p>Creates an checkpoint writer from an existing writer, copying all fields unless new field values are explicity provided either as the optional argument Œîtout or through keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L131-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CheckpointOutputWriter" href="#Subzero.CheckpointOutputWriter"><code>Subzero.CheckpointOutputWriter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CheckpointOutputWriter(Œîtout, fn){ST&lt;:AbstractString}&lt;:AbstractOutputWriter</code></pre><p>Checkpoint subtype of AbstractOutputWriter that holds information for outputting checkpoint information used for restarting the simulation from a point where the writer saved data. Checkpoint data is saved every Œîtout timesteps to filepath. If the given file doesn&#39;t end in &quot;.jld2&quot; the extension will be appended. If overwrite is true then if there is already a file of the given name, it will be overwriten. Else it will thrown an error. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L75-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CheckpointOutputWriter-Tuple{Any}" href="#Subzero.CheckpointOutputWriter-Tuple{Any}"><code>Subzero.CheckpointOutputWriter</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CheckpointOutputWriter(
    Œîtout;
    dir = &quot;.&quot;,
    filename = &quot;checkpoint.jld2&quot;,
    overwrite = false,
    jld2_kw = Dict{Symbol, Any}(),
)</code></pre><p>CheckpointOutputWriter writer that outputs need data to restart simulation at given timesteps Œîtout. Inputs:     Œîtout       &lt;Int&gt; number of timesteps between output     dir         &lt;String&gt; Directory to save output to - default is &quot;.&quot; (current                     working directory).     filename    &lt;String&gt; filename to save file to     overwrite   &lt;Bool&gt; if true, exit file of the same name will be deleted, else                     an error will be thrown if other file exists     jld2_kw     list of JLD2 keywords for the jldopen function Outputs: CheckpointOutputWriter that outputs floes, ocean, and atmosphere states at desired timesteps. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L91-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CollisionBoundary" href="#Subzero.CollisionBoundary"><code>Subzero.CollisionBoundary</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CollisionBoundary &lt;: AbstractBoundary</code></pre><p>A sub-type of AbstractBoundary that stops a floe from exiting the domain by having the floe collide with the boundary. The boundary acts as an immovable, unbreakable ice floe in the collision. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L288-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CollisionBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}" href="#Subzero.CollisionBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}"><code>Subzero.CollisionBoundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CollisionBoundary{D, FT}(grid)</code></pre><p>Creates collision boundary on the edge of the grid, and with the direction as a type. Edge is determined by direction. Inputs:     grid        &lt;AbstractGrid&gt; model grid     direction   &lt;AbstractDirection&gt; direction of boundary wall Outputs:     Collision Boundary on edge of grid given by direction. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L324-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}" href="#Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}"><code>Subzero.CollisionBoundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CollisionBoundary(::Type{FT}, ::Type{D}, args...)</code></pre><p>A float type FT can be provided as the first argument of any CollisionBoundary constructor. The second argument D is the directional type of the boundary. A CollisionBoundary of type FT and D will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L301-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection" href="#Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection"><code>Subzero.CollisionBoundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CollisionBoundary(::Type{D}, args...)</code></pre><p>If a float type isn&#39;t specified, CollisionBoundary will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L314-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CollisionSettings" href="#Subzero.CollisionSettings"><code>Subzero.CollisionSettings</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CollisionSettings{FT&lt;:AbstractFloat}</code></pre><p>Settings needed for collisions within the model.  If collisions<em>on is true, collisions will occur, else they will not. The floe</em>floe<em>max</em>overlap defines the percentage of overlap allowed between floes before marking them for ridging/rafting. The floe<em>domain</em>max<em>overlap defines the percentage of overlap allowed between floes and the domain (collision boundaries and topography) before removing the floe from the simulation.  Both floe</em>floe<em>max</em>overlap and floe<em>domain</em>max<em>overlap should be between 0-1 and if a value &lt; 0 is given or a value &gt; 1 is given when collisions</em>on is true they will be set to 0 and 1 respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/process_settings.jl#L169-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CollisionSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.CollisionSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.CollisionSettings</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CollisionSettings(::Type{FT}, kwargs...)</code></pre><p>A float type FT can be provided as the first argument of any CollisionSettings constructor. A CollisionSettings of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/process_settings.jl#L231-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Constants-Tuple" href="#Subzero.Constants-Tuple"><code>Subzero.Constants</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Constants(args...)</code></pre><p>If a type isn&#39;t specified, Constants will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/simulation.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Constants-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.Constants-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.Constants</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Constants(::Type{FT}, args...)</p><p>A float type FT can be provided as the first argument of any Constants constructor. A Constants of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/simulation.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CouplingSettings" href="#Subzero.CouplingSettings"><code>Subzero.CouplingSettings</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CouplingSettings</code></pre><p>Settings needed for coupling within the model. If coupling<em>on is true, the model will be coupled with the simulation&#39;s ocean and atmosphere. The Œît determines how many simulation timesteps between calculating ocean and atmospheric forces on the floes. Œîd number of buffer grid cells on each side of floe for monte carlo interpolation and mc</em>n is the number of monte carlo points to attempt to generage for each floe. If two<em>way</em>coupling_on is true then the simulation calculates the stress the ice/atmosphere put on the ocean. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/process_settings.jl#L121-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.DamageStressCalculator" href="#Subzero.DamageStressCalculator"><code>Subzero.DamageStressCalculator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DamageStressCalculator{FT&lt;:AbstractFloat} &lt;: AbstractStressCalculator{FT}</code></pre><p>Type of AbstractStressCalculator that calculates stress with each timestep with <code>damage * stress_instant</code>, as suggested by Mukund Gupta. This method could keep track of damage directly within each floe using the <code>damage</code> floe field, perhapes as a value between 0-1, and rather than calculating an &quot;accumulated stress&quot; to store damage, as done in <code>DecayAreaScaledCalculator</code>.</p><p>In this calculator, the floe&#39;s <code>damage</code> field keeps track of an explicit parameter.</p><p><strong>Fields:</strong></p><p><strong>Note:</strong></p><p>This method is not implemented and thus throws an error upon creation. The infrastructure for the damage calculator is provided, but functions that depend on this calculator need to be implemented as detailed in the <code>AbstractStressCalculator</code> API. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/stress_calculators.jl#L134-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.DamageStressCalculator-Tuple" href="#Subzero.DamageStressCalculator-Tuple"><code>Subzero.DamageStressCalculator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DamageStressCalculator(; kwargs...)</code></pre><p>If type isn&#39;t specified, <code>DamageStressCalculator</code>(; kwargs...) will be of type <code>Float64</code> and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/stress_calculators.jl#L172-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.DamageStressCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.DamageStressCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.DamageStressCalculator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DamageStressCalculator(::Type{FT}; kwargs...)</code></pre><p>A float type <code>FT</code> can be provided as the first argument of any <code>DamageStressCalculator</code> constructor. A <code>DamageStressCalculator</code> of type <code>FT</code> will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/stress_calculators.jl#L158-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.DecayAreaScaledCalculator" href="#Subzero.DecayAreaScaledCalculator"><code>Subzero.DecayAreaScaledCalculator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DecayAreaScaledCalculator{FT&lt;:AbstractFloat} &lt;: AbstractStressCalculator{FT}</code></pre><p>Type of AbstractStressCalculator that implements stress calculations by accumulating each timestep of stress using a decay equation. The decay aspect increases importance placed on new damage. The decay equation is as follows:</p><p>`stress<em>accum = stress</em>accum(1-Œª) + stress_instant(Œª)</p><p>The area-scaling part of the stress calculations comes into play when deciding if a floe will be fractured. The accumulated stress can be scaled by a ratio of (floe.area/min<em>floe</em>area)^Œ±. By changing the Œ± value, either larger or smaller floes fracture more eassily. The scaled value will not be saved as this is equivalent to scaling the simulation fracture criteria (morh&#39;s cone or hibler&#39;s ellipse, etc.), but it is less computationally intensive. By leaving the default <code>Œ± = 0</code>, this extra scaling will not take place.</p><p><strong>Fields:</strong></p><ul><li><code>Œª::AbstractFloat</code>: decay parameter used when calculating accumulated stress. Should be between 0 - 1.</li><li><code>Œ±::AbstractFloat</code>: Adjusts ellipse in stress space by raising the ratio to the floe&#39;s area over the simulation minimum floe size to <code>Œ±</code>.</li></ul><p><strong>Note:</strong></p><ul><li><code>Œª</code> is used in <code>_update_stress_accum!</code>, whereas Œ± is used in <code>_scale_principal_stress!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/stress_calculators.jl#L58-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.DecayAreaScaledCalculator-Tuple" href="#Subzero.DecayAreaScaledCalculator-Tuple"><code>Subzero.DecayAreaScaledCalculator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DecayAreaScaledCalculator(; kwargs...)</code></pre><p>If type isn&#39;t specified as the first argument, <code>DecayAreaScaledCalculator</code>(; kwargs...) will be of type <code>Float64</code> and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/stress_calculators.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.DecayAreaScaledCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.DecayAreaScaledCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.DecayAreaScaledCalculator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DecayAreaScaledCalculator(::Type{FT}; kwargs...)</code></pre><p>A float type <code>FT</code> can be provided as the first argument of any <code>DecayAreaScaledCalculator</code> constructor. A <code>DecayAreaScaledCalculator</code> of type <code>FT</code> will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/stress_calculators.jl#L94-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Domain" href="#Subzero.Domain"><code>Subzero.Domain</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Domain that holds 4 Boundary elements, forming a rectangle bounding the model during the simulation, and a list of topography elements.</p><p>In order to create a Domain, three conditions need to be met. First, if needs to be periodically compatible. This means that pairs of opposite boundaries both need to be periodic if one of them is periodic. Next, the value in the north boundary must be greater than the south boundary and the value in the east boundary must be greater than the west in order to form a valid rectangle.</p><p>Note: The code depends on the boundaries forming a rectangle oriented along the cartesian grid. Other shapes/orientations are not supported at this time. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L571-L583">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Domain-Union{Tuple{WB}, Tuple{EB}, Tuple{SB}, Tuple{NB}, Tuple{FT}, Tuple{NB, SB, EB, WB}} where {FT&lt;:AbstractFloat, NB&lt;:AbstractBoundary{North, FT}, SB&lt;:AbstractBoundary{South, FT}, EB&lt;:AbstractBoundary{East, FT}, WB&lt;:AbstractBoundary{West, FT}}" href="#Subzero.Domain-Union{Tuple{WB}, Tuple{EB}, Tuple{SB}, Tuple{NB}, Tuple{FT}, Tuple{NB, SB, EB, WB}} where {FT&lt;:AbstractFloat, NB&lt;:AbstractBoundary{North, FT}, SB&lt;:AbstractBoundary{South, FT}, EB&lt;:AbstractBoundary{East, FT}, WB&lt;:AbstractBoundary{West, FT}}"><code>Subzero.Domain</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Domain(north, south, east, west)</code></pre><p>Creates domain with empty list of topography and given boundaries. Inputs:     north   &lt;AbstractBoundary&gt; north boundary     south   &lt;AbstractBoundary&gt; south boundary     east    &lt;AbstractBoundary&gt; east boundary     west    &lt;AbstractBoundary&gt; west boundary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L660-L669">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.East" href="#Subzero.East"><code>Subzero.East</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">East&lt;:AbstractDirection</code></pre><p>A simple direction type representing if a boundary is the eastern boundary in a rectangular domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Floe" href="#Subzero.Floe"><code>Subzero.Floe</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Singular sea ice floe with fields describing current state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Floe-Tuple" href="#Subzero.Floe-Tuple"><code>Subzero.Floe</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Floe(args...)</code></pre><p>If a type isn&#39;t specified, Floe will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Floe-Union{Tuple{FT}, Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.Floe-Union{Tuple{FT}, Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Floe</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Floe{FT}(
    coords::PolyVec,
    hmean,
    Œîh;
    œÅi = 920.0,
    mc_n = 1000,
    rng = Xoshiro(),
    kwargs...,
)</code></pre><p>Floe constructor with PolyVec coordinates Inputs:     coords              &lt;Vector{Vector{Vector{Float64}}}&gt; floe coordinates     hmean               &lt;Real&gt; mean height for floes     Œîh                  &lt;Real&gt; variability in height for floes     floe_settings       &lt;FloeSettings&gt; settings needed to initialize floe     rng                 &lt;RNG&gt; random number generator to generate random floe                             attributes - default uses Xoshiro256++ algorithm     kwargs              Any other floe fields to set as keyword arguments Output:     &lt;Floe&gt; with needed fields defined - all default field values used so all     forcings start at 0 and floe&#39;s status is &quot;active&quot; as long as monte carlo     points were able to be generated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L198-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Floe-Union{Tuple{FT}, Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.Floe-Union{Tuple{FT}, Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Floe</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Floe{FT}(
    poly::Polys,
    hmean,
    Œîh;
    floe_settings = FloeSettings(),
    rng = Xoshiro(),
    kwargs...
)</code></pre><p>Constructor for floe with a polygon Inputs:     poly                &lt;Polygon&gt;      hmean               &lt;Real&gt; mean height for floes     Œîh                  &lt;Real&gt; variability in height for floes     floe_settings       &lt;FloeSettings&gt; settings needed to initialize floe             rng                 &lt;RNG&gt; random number generator to generate floe                             attributes - default is Xoshiro256++ algorithm     kwargs      Any other floe fields to set as keyword arguments Output:     &lt;Floe&gt; with needed fields defined - all default field values used so all         forcings start at 0 and floe&#39;s status is &quot;active&quot; as long as monte carlo         points were able to be generated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L120-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Floe-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.Floe-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.Floe</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Floe(::Type{FT}, args...; kwargs...)</code></pre><p>A float type FT can be provided as the first argument of any Floe constructor. A Floe of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.FloeOutputWriter" href="#Subzero.FloeOutputWriter"><code>Subzero.FloeOutputWriter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FloeOutputWriter(writer::FloeOutputWriter, [Œîtout]; kwargs...)</code></pre><p>Creates an floe output writer from an existing writer, copying all fields unless new field values are explicity provided either as the optional argument Œîtout or through keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L206-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.FloeOutputWriter" href="#Subzero.FloeOutputWriter"><code>Subzero.FloeOutputWriter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FloeOutputWriter{ST&lt;:AbstractString}&lt;:AbstractOutputWriter</code></pre><p>Floe subtype of AbstractOutputWriter that holds information for outputting floe information from model throughout simulation. Output will be saved to the file defined by fn every Œîtout timesteps. Only outputs within the outputs list will be saved. File will be saved as a JLD2 file to filepath. If the given file doesn&#39;t end in &quot;.jld2&quot; the extension will be appended. If overwrite is true then if there is already a file of the given name, it will be overwriten. Else it will thrown an error. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L150-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.FloeOutputWriter-Tuple{Any}" href="#Subzero.FloeOutputWriter-Tuple{Any}"><code>Subzero.FloeOutputWriter</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function FloeOutputWriter(
    Œîtout;
    outputs = collect(fieldnames(Floe)),
    dir = &quot;.&quot;,
    filename = &quot;floes.jld2&quot;,
    overwrite = false,
    jld2_kw = Dict{Symbol, Any}(),
)</code></pre><p>FloeOutput writer that outputs provided Floe fields at given timesteps Œîtout and saves the information in a file of the provided name. Inputs:     Œîtout       &lt;Int&gt; number of timesteps between output     outputs     &lt;Vector{Symbols}&gt; list of floe fields to output     dir         &lt;String&gt; Directory to save output to - default is &quot;.&quot; (current                     working directory)     filename    &lt;String&gt; filename to save file to     overwrite   &lt;Bool&gt; if true, exit file of the same name will be deleted, else                     an error will be thrown if other file exists     jld2_kw     list of JLD2 keywords for the jldopen function Outputs:     FloeOutputWriter that outputs provided Floe fields every Œîtout timesteps to     filename Note: If floe field&#39;s are not specified using <code>outputs</code>, all Floe fields will be saved</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L168-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.FloeSettings" href="#Subzero.FloeSettings"><code>Subzero.FloeSettings</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FloeSettings</code></pre><p>Settings needed to create floes within the model.</p><ul><li>œÅi is the density of all floes within the model</li><li>min<em>floe</em>area is the minimum floe area within the model before removal</li><li>min<em>floe</em>height is the minimum floe height within the model before removal</li><li>max<em>floe</em>height is the maximum floe height within the model before the height   can&#39;t increase any further</li><li>min<em>aspect</em>ratio is the minimum ratio between the x-length and y-length of any   floe prior to removal</li><li>subfloe<em>point</em>generator is the method of subfloe point generation for each   floe within the model</li><li>stress_calculator is the method of calculating current stress of floe</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/process_settings.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.FloeSettings-Union{Tuple{Type{FT}}, Tuple{CT}, Tuple{GT}, Tuple{FT}} where {FT&lt;:AbstractFloat, GT&lt;:Subzero.AbstractSubFloePointsGenerator, CT&lt;:AbstractStressCalculator}" href="#Subzero.FloeSettings-Union{Tuple{Type{FT}}, Tuple{CT}, Tuple{GT}, Tuple{FT}} where {FT&lt;:AbstractFloat, GT&lt;:Subzero.AbstractSubFloePointsGenerator, CT&lt;:AbstractStressCalculator}"><code>Subzero.FloeSettings</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FloeSettings(::Type{FT}; subfloe_point_generator, kwargs...)</code></pre><p>A float type FT can be provided as the first argument of any FloeSettings constructor. A FloeSettings of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/process_settings.jl#L102-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.FractureSettings" href="#Subzero.FractureSettings"><code>Subzero.FractureSettings</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FractureSettings{CT&lt;:AbstractFractureCriteria}</code></pre><p>Settings needed for fractures within the model.  If fractures<em>on is true, fractures will occur, else they will not. The criteria defines which fracture criteria are used to determine which floes to fracture. The Œît determines how many simulation timesteps between fracturing floes. If deform</em>on is true, then the floe will be deformed around floe primarily causing the fracture, identified by the largest overlap area on the most recent set of collisions. Npieces denotes how many pieces to try to split a fractured floe into - 3 is suggested value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/process_settings.jl#L241-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.GridOutputWriter" href="#Subzero.GridOutputWriter"><code>Subzero.GridOutputWriter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridOutputWriter{FT&lt;:AbstractFloat}&lt;:AbstractOutputWriter</code></pre><p>Grid subtype of AbstractOutputWriter that holds information for outputting floe data on the grid. This output does not need to be the grid defined for the model. This grid can be coarser, or more fine, as defined by the xg and yg fields. Output on this scale will be saved to the file defined by filepath every Œîtout timesteps. Data will be collected in the data field during calculation for easier writing to the NetCDF file. Only outputs within the outputs list will be saved. There is a limited number of floe outputs that can be calculated by the GridOutputWriter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L227-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.GridOutputWriter-Tuple" href="#Subzero.GridOutputWriter-Tuple"><code>Subzero.GridOutputWriter</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GridOutputWriter(args...; kwargs...)</code></pre><p>If a type isn&#39;t specified, GridOutputWriter will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L260-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.GridOutputWriter-Tuple{GridOutputWriter}" href="#Subzero.GridOutputWriter-Tuple{GridOutputWriter}"><code>Subzero.GridOutputWriter</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GridOutputWriter(writer::GridOutputWriter, [Œîtout]; kwargs...)</code></pre><p>Creates an grid output writer from an existing writer, copying all fields unless new field values are explicity provided through keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L380-L385">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Any, AbstractGrid, Any}} where FT&lt;:AbstractFloat" href="#Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Any, AbstractGrid, Any}} where FT&lt;:AbstractFloat"><code>Subzero.GridOutputWriter</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>GridOutputWriter{FT}(     outputs::Vector{Symbol},     Œîtout,     grid::AbstractGrid,     dims;     dir = &quot;.&quot;,     filename = &quot;gridded_data.nc&quot;,     overwrite = false,     average = false,</p><p>Create GridOutputWriter for grid of given dimensions to output floe data averaged on this re-gridded gird at given frequency of timesteps. Only outputs provided outputs. Inputs:     outputs     &lt;Vector{Symbols}&gt; list of grid outputs desired     Œîtout       &lt;Int&gt; number of timesteps between output     grid        &lt;Grid&gt; original grid, which we are re-gridding     dims        &lt;(Int, Int)&gt; output new grid dimensions for these calculations -                 rows -&gt; ny, cols -&gt; nx     dir         &lt;String&gt; Directory to save output to - default is &quot;.&quot; (current                     working directory)     filename    &lt;String&gt; filename to save file to     overwrite   &lt;Bool&gt; if true, exit file of the same name will be deleted, else                     an error will be thrown if other file exist     average     &lt;Bool&gt; if true, average gridded data over timesteps between                     outputs, else just calculate at output timestep Output:     GridOutputWriter that re-grids grid to given dimensions, and saves floe     information averaged on this new grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L298-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.GridOutputWriter</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GridOutputWriter(::Type{FT}, args...; kwargs...)</code></pre><p>A float type FT can be provided as the first argument of any GridOutputWriter constructor. A GridOutputWriter of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L250-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.HiblerYieldCurve" href="#Subzero.HiblerYieldCurve"><code>Subzero.HiblerYieldCurve</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HiblerYieldCurve{FT&lt;:AbstractFloat}&lt;:AbstractFractureCriteria</code></pre><p>Type of AbstractFractureCriteria that creates a yield curve that determines if a floe fractures based off if its stress in principal stress space  is inside or outside of the yield curve. Fields:     pstar       &lt;AbstractFloat&gt; used to tune ellipse for optimal fracturing     c           &lt;AbstractFloat&gt; used to tune ellipse for optimal fracturing     verticies   &lt;PolyVec&gt; vertices of criteria in principal stress space Note:     Hibler&#39;s paper says that: Both pstar and c relate the ice strength to the     ice thickness and compactness. c is determined to that 10% open water     reduces the strength substantially and pstar is considered a free parameter</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L28-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.HiblerYieldCurve-Tuple" href="#Subzero.HiblerYieldCurve-Tuple"><code>Subzero.HiblerYieldCurve</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HiblerYieldCurve(args...)</code></pre><p>If a type isn&#39;t specified, HiblerYieldCurve will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.HiblerYieldCurve-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.HiblerYieldCurve-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.HiblerYieldCurve</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HiblerYieldCurve(::Type{FT}, args...)</code></pre><p>A float type FT can be provided as the first argument of any HiblerYieldCurve constructor. A HiblerYieldCurve of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.HiblerYieldCurve-Union{Tuple{StructArrays.StructArray{&lt;:Floe{FT}}}, Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.HiblerYieldCurve-Union{Tuple{StructArrays.StructArray{&lt;:Floe{FT}}}, Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.HiblerYieldCurve</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HiblerYieldCurve(floes, pstar = 2.25e5, c = 20.0)</code></pre><p>Calculates Hibler&#39;s Elliptical Yield curve using parameters pstar, c, and the current floe field.  Inputs:     floes   &lt;StructArray{Floes}&gt; model&#39;s list of floes     pstar   &lt;AbstractFloat&gt; used to tune ellipse for optimal fracturing     c       &lt;AbstractFloat&gt; used to tune ellipse for optimal fracturing Outputs:     HiblerYieldCurve struct with vertices determined using the <em>calculate</em>hibler     function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L96-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.IceStressCell" href="#Subzero.IceStressCell"><code>Subzero.IceStressCell</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IceStressCell{FT&lt;:AbstractFloat}</code></pre><p>Struct to collect stress from ice floes on ocean grid cells. One IceStressCell corresponds to one grid cell. It holds a list of running totals of stress on the cell, and a running list of the number of points making up those running totals. Each element in the list corresponds to one floe, which is denoted in the corresponding CellFloes matrix within the grid. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/ocean_and_atmos.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.IceStressCell-Union{Tuple{}, Tuple{FT}} where FT" href="#Subzero.IceStressCell-Union{Tuple{}, Tuple{FT}} where FT"><code>Subzero.IceStressCell</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IceStressCell{FT}()</code></pre><p>Constructs an IceStressCell object with empty lists for fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/ocean_and_atmos.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.InitialStateOutputWriter" href="#Subzero.InitialStateOutputWriter"><code>Subzero.InitialStateOutputWriter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InitialStateOuputWriter&lt;:AbstractOutputWriter</code></pre><p>Basic type of AbstractOutputWriter that records the intial state of the simulation. Writes JLD2 file with initial simulation state to the filepath specified. If overwrite is true, and there is a file of the given name at the filepath, that file will be overwritten.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.InitialStateOutputWriter-Tuple{InitialStateOutputWriter}" href="#Subzero.InitialStateOutputWriter-Tuple{InitialStateOutputWriter}"><code>Subzero.InitialStateOutputWriter</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InitialStateOutputWriter(writer::InitialStateOutputWriter; kwargs...)</code></pre><p>Creates an initial state output writer from an existing writer, copying all fields unless  new field values are explicity provided through keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.InitialStateOutputWriter-Tuple{}" href="#Subzero.InitialStateOutputWriter-Tuple{}"><code>Subzero.InitialStateOutputWriter</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InitialStateOutputWriter(
    ;
    dir = &quot;.&quot;,
    filename = &quot;initial_state.jld2&quot;,
    overwrite = false,
    jld2_kw = Dict{Symbol, Any}(),
)</code></pre><p>Creates an initial state output writer. Inputs:     dir         &lt;String&gt; path to directory     filename    &lt;String&gt; filename to save file to     overwrite   &lt;Bool&gt; if true, exit file of the same name will be deleted, else                     an error will be thrown if other file exists     jld2_kw     list of JLD2 keywords for the jldopen function Outputs:     Creates InitialStateOutputWriter that will write simulation&#39;s initial     state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L26-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.InteractionFields" href="#Subzero.InteractionFields"><code>Subzero.InteractionFields</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Enum to index into floe interactions field with more intuituve names</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L99-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Model" href="#Subzero.Model"><code>Subzero.Model</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Model which holds grid, ocean, atmos structs, each with the same underlying float type (either Float32 of Float64) and size. It also holds the domain information, which includes the topography and the boundaries. It holds a  StructArray of floe structs, again each relying on the same underlying float type. Finally, it also holds the maximum floe id used thus far in the simulation. This should be the length of the floes array at the beginning of the run. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/model.jl#L38-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.MohrsCone" href="#Subzero.MohrsCone"><code>Subzero.MohrsCone</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>MohrsCone{FT&lt;:AbstractFloat}&lt;:AbstractFractureCriteria</p><p>Type of AbstractFractureCriteria that creates a cone in principal stress space that determines if a floe fractures based off if its stress in principal stress space  is inside or outside of the cone. Fields:     verticies   &lt;PolyVec&gt; vertices of criteria in principal stress space Note:     Concepts from the following papter -     Weiss, J√©r√¥me, and Erland M. Schulson. &quot;Coulombic faulting from the grain     scale to the geophysical scale: lessons from ice.&quot; Journal of Physics D:     Applied Physics 42.21 (2009): 214017.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L120-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.MohrsCone-Tuple" href="#Subzero.MohrsCone-Tuple"><code>Subzero.MohrsCone</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MohrsCone(args...)</code></pre><p>If a type isn&#39;t specified, MohrsCone will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L148-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.MohrsCone-Union{Tuple, Tuple{FT}} where FT" href="#Subzero.MohrsCone-Union{Tuple, Tuple{FT}} where FT"><code>Subzero.MohrsCone</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MohrsCone{FT}(val::AbstractFloat, args...)</code></pre><p>Calculate Mohr&#39;s Cone vertices given <em>calculate</em>mohrs arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L216-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.MohrsCone-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.MohrsCone-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.MohrsCone</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MohrsCone(::Type{FT}, args...)</code></pre><p>A float type FT can be provided as the first argument of any MohrsCone constructor. A MohrsCone of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L138-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.MonteCarloPointsGenerator" href="#Subzero.MonteCarloPointsGenerator"><code>Subzero.MonteCarloPointsGenerator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MonteCarloPointsGenerator</code></pre><p>Subtype of AbstractSubFloePointsGenerator that defines parameters needed to generate a set of random monte carlo points within a given floe. <code>npoints</code> is the number of monte carlo points to generate within the floe&#39;s bounding box - the floe will not end up with this many points as all points outside of the floe will be removed. <code>ntries</code> is the number of tries to generate a set of points within the floe that have a smaller error than <code>err</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.MonteCarloPointsGenerator-Tuple" href="#Subzero.MonteCarloPointsGenerator-Tuple"><code>Subzero.MonteCarloPointsGenerator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MonteCarloPointsGenerator(; kwargs...)</code></pre><p>If type isn&#39;t specified, MonteCarloPointsGenerator(; kwargs...) will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.MonteCarloPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.MonteCarloPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.MonteCarloPointsGenerator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MonteCarloPointsGenerator(::Type{FT}; kwargs...)</code></pre><p>A float type FT can be provided as the first argument of any MonteCarloPointsGenerator constructor. A MonteCarloPointsGenerato of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L54-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.MovingBoundary" href="#Subzero.MovingBoundary"><code>Subzero.MovingBoundary</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MovingBoundary &lt;: AbstractBoundary</code></pre><p>A sub-type of AbstractBoundary that creates a floe along the boundary that moves towards the center of the domain at the given velocity, compressing the ice within the domain. This subtype is a mutable struct so that the coordinates and val can be changed as the boundary moves. The u and v velocities are in [m/s].</p><p>Note that with a u-velocity, east and west walls move towards the center of the domain, providing compressive stress, and with a v-velocity, the bounday creates a shear stress by incorporating the velocity into friction calculations but doesn&#39;t actually move. This means that the boundaries cannot move at an angle, distorting the shape of the domain regardless the the combination of u and v velocities. The same, but opposite is true for the north and south walls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L346-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.MovingBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}" href="#Subzero.MovingBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}"><code>Subzero.MovingBoundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MovingBoundary(::Type{FT}, ::Type{D}, args...)</code></pre><p>A float type FT can be provided as the first argument of any MovingBoundary constructor. The second argument D is the directional type of the boundary. A MovingBoundary of type FT and D will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L369-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.MovingBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection" href="#Subzero.MovingBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection"><code>Subzero.MovingBoundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MovingBoundary(::Type{D}, args...)</code></pre><p>If a float type isn&#39;t specified, MovingBoundary will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.MovingBoundary-Union{Tuple{FT}, Tuple{D}, Tuple{Any, Any, Any}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}" href="#Subzero.MovingBoundary-Union{Tuple{FT}, Tuple{D}, Tuple{Any, Any, Any}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}"><code>Subzero.MovingBoundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MovingBoundary{D, FT}(grid, velocity)</code></pre><p>Creates compression boundary on the edge of the grid, and with the direction as a type. Edge is determined by direction. Inputs:         grid        &lt;AbstractGrid&gt; model grid         u    &lt;AbstractFloat&gt; u velocity of boundary         v    &lt;AbstractFloat&gt; v velocity of boundary Outputs:     MovingBoundary on edge of grid given by direction. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L392-L404">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.NoFracture" href="#Subzero.NoFracture"><code>Subzero.NoFracture</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoFracture&lt;:AbstractFractureCriteria</code></pre><p>Simple AbstractFractureCriteria type representing when fracturing functionality is turned off. If this is the type provided to the simulation&#39;s FractureSettings then fractures will not occur.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.North" href="#Subzero.North"><code>Subzero.North</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">North&lt;:AbstractDirection</code></pre><p>A simple direction type representing if a boundary is the northern boundary in a rectangular domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Ocean" href="#Subzero.Ocean"><code>Subzero.Ocean</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ocean{FT&lt;:AbstractFloat}</code></pre><p>Simulation ocean holding ocean values on the grid-scale with matricies of the same size as the model&#39;s grid. The struct has the following fields:</p><ul><li>u is the ocean velocities in the x-direction for each grid cell</li><li>v is the ocean velocities in the y-direction for each grid cell</li><li>temp is the ocean temperature for each grid cell</li><li>hflx_factor is a factor to calculate the ocean-atmosphere heat flux for a  cell in that grid cell by multiplying by its height</li><li>si_frac is the fraction of area in each grid cell that is covered in sea-ice</li></ul><p>Ocean fields must all be matricies with dimensions equal to the number of grid lines in the model&#39;s grid.  Note: If a periodic boundary is used in the domain, the last grid cell in that direction will not be used as it is equivalent to the first grid cell. Thus, for all of these fields, the first and last value in the x and/or y direction should be equal if the east-west or north-south boundary pair are periodic respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/ocean_and_atmos.jl#L42-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Ocean-Tuple" href="#Subzero.Ocean-Tuple"><code>Subzero.Ocean</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ocean(args...)</code></pre><p>If a type isn&#39;t specified, Ocean will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/ocean_and_atmos.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Ocean-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.Ocean-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Ocean</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ocean{FT}(grid, u, v, temp)</code></pre><p>Construct model&#39;s ocean. Inputs:     grid    &lt;AbstractGrid&gt; model grid     u       &lt;Real&gt; ocean x-velocity for each grid line     v       &lt;Real&gt; ocean y-velocity for each grid line     temp    &lt;Real&gt; temperature at ocean/ice interface per grid cell Output:          Ocean with constant velocity and temperature on each grid line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/ocean_and_atmos.jl#L149-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Ocean-Union{Tuple{FT}, Tuple{Any, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.Ocean-Union{Tuple{FT}, Tuple{Any, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Ocean</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ocean{FT}(u, v, temp)</code></pre><p>Construct model ocean. Inputs:     u       &lt;Matrix&gt; ocean x-velocity matrix with u for each grid line     v       &lt;Matrix&gt; ocean y-velocity matrix with u for each grid line     temp    &lt;Matrix&gt; temperature matrix with ocean/ice interface temperature for                 each grid line Output:      Model ocean with given velocity and temperature fields on each grid line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/ocean_and_atmos.jl#L118-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Ocean-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.Ocean-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.Ocean</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ocean(::Type{FT}, args...)</code></pre><p>A float type FT can be provided as the first argument of any Ocean constructor. An Ocean of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/ocean_and_atmos.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.OpenBoundary" href="#Subzero.OpenBoundary"><code>Subzero.OpenBoundary</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OpenBoundary &lt;: AbstractBoundary</code></pre><p>A sub-type of AbstractBoundary that allows a floe to pass out of the domain edge without any effects on the floe.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.OpenBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}" href="#Subzero.OpenBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}"><code>Subzero.OpenBoundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OpenBoundary{D, FT}(grid)</code></pre><p>Creates open boundary on the edge of the grid, and with the direction as a type. Edge is determined by direction. Inputs:     grid        &lt;AbstractGrid&gt; model grid Outputs:     Open Boundary on edge of grid given by direction and type. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L211-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.OpenBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}" href="#Subzero.OpenBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}"><code>Subzero.OpenBoundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OpenBoundary(::Type{FT}, ::Type{D}, args...)</code></pre><p>A float type FT can be provided as the first argument of any OpenBoundary constructor. The second argument D is the directional type of the boundary. An OpenBoundary of type FT and D will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L189-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.OpenBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection" href="#Subzero.OpenBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection"><code>Subzero.OpenBoundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OpenBoundary(::Type{D}, args...)</code></pre><p>If a float type isn&#39;t specified, OpenBoundary will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L202-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.OutputWriters" href="#Subzero.OutputWriters"><code>Subzero.OutputWriters</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OutputWriters{FT&lt;:AbstractFloat}</code></pre><p>Structure to hold all types of output writers a user might want. All fields are vectors so that more than one of each type of output writer can be defined, and so that a default OutputWriter object doesn&#39;t create default output writer fields, which would create files, but rather empty lists of output writers. If any of the fields is not provided, the default is just an empty list. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L406-L414">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.PeriodicBoundary" href="#Subzero.PeriodicBoundary"><code>Subzero.PeriodicBoundary</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PeriodicBoundary &lt;: AbstractBoundary</code></pre><p>A sub-type of AbstractBoundary that moves a floe from one side of the domain to the opposite side of the domain when it crosses the boundary, bringing the floe back into the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L232-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.PeriodicBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}" href="#Subzero.PeriodicBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}"><code>Subzero.PeriodicBoundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PeriodicBoundary{D, FT}(grid)</code></pre><p>Creates periodic boundary on the edge of the grid, and with the direction as a type. Edge is determined by direction. Inputs:     grid        &lt;AbstractGrid&gt; model grid Outputs:     Periodic Boundary on edge of grid given by direction and type. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L267-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}" href="#Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}"><code>Subzero.PeriodicBoundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PeriodicBoundary(::Type{FT}, ::Type{D}, args...)</code></pre><p>A float type FT can be provided as the first argument of any PeriodicBoundary constructor. The second argument D is the directional type of the boundary. A PeriodicBoundary of type FT and D will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L245-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection" href="#Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection"><code>Subzero.PeriodicBoundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PeriodicBoundary(::Type{D}, args...)</code></pre><p>If a float type isn&#39;t specified, PeriodicBoundary will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L258-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.PolyVec" href="#Subzero.PolyVec"><code>Subzero.PolyVec</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Coordinates are vector of vector of vector of points of the form: [[[x1, y1], [x2, y2], ..., [xn, yn], [x1, y1]],   [[w1, z1], [w2, z2], ..., [wn, zn], [w1, z1]], ...] where the xy coordinates  are the exterior border of the floe and the wz coordinates, or any other  following sets of coordinates, describe holes within the floe.  This form is for easy conversion to polygons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/Subzero.jl#L83-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.RegRectilinearGrid" href="#Subzero.RegRectilinearGrid"><code>Subzero.RegRectilinearGrid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegRectilinearGrid{FT&lt;:AbstractFloat}&lt;:AbstractGrid</code></pre><p>Tessellation of 2-dimensional Euclidean space into n-by-m congruent rectangles.</p><ul><li>Nx: number of grid cells in the x-direction</li><li>Ny: number of grid cells in the y-direction</li><li>x0: value of first x grid line</li><li>xf: value of final x grid line</li><li>y0: value of first y grid line</li><li>yf: value of final y grid line</li><li>Œîx: grid cell width</li><li>Œîy: grid cell height</li><li>floe_locations: matrix of CellFloes, which keep track of which floes are in   each cell</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L737-L751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.RegRectilinearGrid-Tuple" href="#Subzero.RegRectilinearGrid-Tuple"><code>Subzero.RegRectilinearGrid</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RegRectilinearGrid(args...)</code></pre><p>If a type isn&#39;t specified, RegRectilinearGrid will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L800-L805">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Int64, Int64, Tuple, Tuple}} where FT&lt;:AbstractFloat" href="#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Int64, Int64, Tuple, Tuple}} where FT&lt;:AbstractFloat"><code>Subzero.RegRectilinearGrid</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RegRectilinearGrid{FT}(
    Nx,
    Ny,
    xbounds::Tuple{Real, Real},
    ybounds::Tuple{Real, Real},
) where {FT &lt;: AbstractFloat}</code></pre><p>Construct a RegRectilinearGrid for model given bounds for grid x and y and the number of grid cells in both the x and y direction. Inputs:     Nx       &lt;Int&gt; number of grid cells in the x-direction     Ny       &lt;Int&gt; number of grid cells in the y-direction     xbounds  &lt;Tuple{Real, Real}&gt; bound of grid x-direction in form (left, right)     ybounds  &lt;Tuple{Real, Real}&gt; bound of grid y-direction in form (bottom, top) Output:      RegRectilinearGrid with width and height determined by xbound and ybounds     and the number of grid cells in the x-direction and y-direction determined     by dims.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L855-L874">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Tuple, Tuple, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Tuple, Tuple, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.RegRectilinearGrid</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RegRectilinearGrid{FT}(
    xbounds::Tuple,
    ybounds::Tuple,
    Œîx,
    Œîy,
)</code></pre><p>Construct a RegRectilinearGrid for model given bounds for grid x and y and grid cell dimensions in meters. Inputs:     xbounds  &lt;Tuple{Real, Real}&gt; bound of grid x-direction in form (left, right)     ybounds  &lt;Tuple{Real, Real}&gt; bound of grid y-direction in form (bottom, top)     Œîx       &lt;Real&gt; length/height of grid cells in x-direction     Œîy       &lt;Real&gt; length/height of grid cells in y-direction Output:      RegRectilinearGrid from lx to ux and height from ly to uy with grid squares     of size Œîx by Œîy Warning:     If Œîx doesn&#39;t evenly divide x length (lu-lx) or Œîy doesn&#39;t evenly divide y     length (uy-ly) you won&#39;t get full size grid. The grid will be &quot;trimmed&quot; to     the nearest full grid square in both directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L808-L830">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.RegRectilinearGrid</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RegRectilinearGrid(::Type{FT}, args...)</code></pre><p>A float type FT can be provided as the first argument of any RegRectilinearGrid constructor. A RegRectilinearGrid of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L790-L796">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.RidgeRaftSettings" href="#Subzero.RidgeRaftSettings"><code>Subzero.RidgeRaftSettings</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RidgeRaftSettings{FT &lt;: AbstractFloat}</code></pre><p>Settings needed for ridging and rafting within the model. The fields have the following meanings:</p><ul><li>ridge<em>raft</em>on: a boolean flag for if ridging and rafting should be turned on   in the simulation</li><li>Œît: multiple of timesteps during which ridging and rafting code will run</li><li>ridge_probability: the probability a floe ridges with another floe/domain if   it meets all other criteria</li><li>raft_probability: the probability a floe rafts with another floe/domain if it   meets all other criteria</li><li>min<em>overlap</em>frac: the minimum overlap area fraction between a floe and another   floe/domain for that floe to ridge or raft</li><li>min<em>ridge</em>height: the minimum floe height to ridge with a floe/domain</li><li>max<em>floe</em>ridge_height: the maximum floe height to ridge with another   floe</li><li>max<em>domain</em>rdige_height: maximum floe height to ridge with a domain element</li><li>max<em>floe</em>raft_height: maximum floe height to raft with another floe</li><li>max<em>domain</em>raft_height: maximum floe height to raft with a domain element</li><li>domain<em>gain</em>probability: the probalility that a floe that rafts with a domain   element keeps all of its mass (0) or if that mass is removed and lost to the   domain element (1).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/process_settings.jl#L361-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.RidgeRaftSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.RidgeRaftSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.RidgeRaftSettings</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RidgeRaftSettings(::Type{FT}, kwargs...)</code></pre><p>A float type FT can be provided as the first argument of any RidgeRaftSettings constructor. A RidgeRaftSettings of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/process_settings.jl#L493-L499">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.RingVec" href="#Subzero.RingVec"><code>Subzero.RingVec</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Coordinates are vector of vector of points of the form: [[x1, y1], [x2, y2], ..., [xn, yn], [x1, y1]] where the xy coordinates form a closed ring. PolyVec objects can be made out RingVec objects. This form is for each conversion to LinearRings, which can also be made into Polygons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/Subzero.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.SimplificationSettings" href="#Subzero.SimplificationSettings"><code>Subzero.SimplificationSettings</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SimplificationSettings{FT&lt;:AbstractFloat}</code></pre><p>If smooth<em>vertices</em>on is true then floe&#39;s with more vertices than max<em>vertices will be simplified every Œît</em>smooth timesteps. The tolerance is the Douglas‚ÄìPeucker algorithm tolerance in (m).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/process_settings.jl#L306-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.SimplificationSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.SimplificationSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.SimplificationSettings</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SimplificationSettings(::Type{FT}, kwargs...)</code></pre><p>A float type FT can be provided as the first argument of any SimplificationSettings constructor. A SimplificationSettings of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/process_settings.jl#L351-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Simulation" href="#Subzero.Simulation"><code>Subzero.Simulation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Simulation{FT&lt;:AbstractFloat, DT&lt;:Domain{FT}}</code></pre><p>Simulation which holds a model and parameters needed for running the simulation. This includes physical constants (consts), a random number generator (rng), the number of seconds in a timestep (Œît), and the number of timesteps to run (nŒît). We also have a flag for verbose, which will print out the number of timesteps every 50 timesteps and a simulation name, which can be used when saving files. The user can also define settings for each physical process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/simulation.jl#L39-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.South" href="#Subzero.South"><code>Subzero.South</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">South&lt;:AbstractDirection</code></pre><p>A simple direction type representing if a boundary is the southern boundary in a rectangular domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.StatusTag" href="#Subzero.StatusTag"><code>Subzero.StatusTag</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Enum for differnt floe status</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.SubGridPointsGenerator" href="#Subzero.SubGridPointsGenerator"><code>Subzero.SubGridPointsGenerator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubGridPointsGenerator</code></pre><p>Subtype of AbstractSubFloePointsGenerator that defines parameters needed to generate a set of points on a &quot;subgrid&quot; within the floe where the subgrid is a regular rectilinar grid with cells of size <code>Œîg</code> in both width and height. If two-way coupling, <code>Œîg</code> should be smaller than the grid&#39;s Œîx and Œîy so that there is at least one point in each grid cell that the floe occupies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L77-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.SubGridPointsGenerator-Tuple" href="#Subzero.SubGridPointsGenerator-Tuple"><code>Subzero.SubGridPointsGenerator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SubGridPointsGenerator(; kwargs...)</code></pre><p>If type isn&#39;t specified, SubGridPointsGenerator(; kwargs...) will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{RegRectilinearGrid, Int64}} where FT&lt;:AbstractFloat" href="#Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{RegRectilinearGrid, Int64}} where FT&lt;:AbstractFloat"><code>Subzero.SubGridPointsGenerator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SubGridPointsGenerator{FT}(grid, npoint_per_cell)</code></pre><p>SubGridPointsGenerator constructor that uses the simulation grid and the desired number of sub-floe points per simulation grid cell to determine the correct value of Œîg Inputs:     grid                &lt;RegRectilinearGrid&gt; simulation&#39;s grid     npoint<em>per</em>cell     &lt;Int&gt; number of points per grid cell, where the grid                             is redefined to have width and height equal to the                             minimum of Œîx and Œîy Output:     SubGridPointsGenerator with Œîg defined to be the minimum of Œîx and Œîy over     the number of desired points per grid cell</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L123-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.SubGridPointsGenerator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SubGridPointsGenerator(::Type{FT}; kwargs...)</code></pre><p>A float type FT can be provided as the first argument of any SubGridPointsGenerator constructor. A SubGridPointsGenerator of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.SubzeroLogger" href="#Subzero.SubzeroLogger"><code>Subzero.SubzeroLogger</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubzeroLogger(sim; messages_per_tstep = 1)</code></pre><p>Created Subzero logger and writes log events to log file in current directory to file with the same name as the simulation&#39;s name field. Inputs:     sim                 &lt;Simulation&gt;     messages<em>per</em>tstep  &lt;Int&gt; maximum number of times a given message should be                         written per timestep Outputs:     Subzero logger that saves log to file with the same name as the simulation&#39;s     name field and optional keyword arguments set. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/logger.jl#L68-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.SubzeroLogger" href="#Subzero.SubzeroLogger"><code>Subzero.SubzeroLogger</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubzeroLogger(sim, messages_per_tstep = 1)</code></pre><p>Constructor from Subzero logger. Inputs:     filename            &lt;String&gt; file path to file to write log events into     messages<em>per</em>tstep  &lt;Int&gt; maximum number of times a given message should be                             written per timestep Outputs:     Subzero logger that saves log to file with the same name as the simulation&#39;s     name field and optional keyword arguments set. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/logger.jl#L42-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.SubzeroLogger" href="#Subzero.SubzeroLogger"><code>Subzero.SubzeroLogger</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubzeroLogger</code></pre><p>Logger for Subzero. Logs unique messages <code>messages_per_tstep</code> times per timestep to prevent overwhelming number of messages timesteps from multiple floes triggering the same log event. Fields:</p><ul><li>stream: ogs are written to this IO</li><li>min_level: minimum log event level to write</li><li>message_limits: dictionary with message IDs for key whose values are the   number of times that message can still be written in current timestep -    current timestep is stored in same dictionary under key &#39;tstep&#39;</li><li>messages<em>per</em>tstep: maximum number of times a given message should be written   per timestep</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/logger.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.TopographyElement" href="#Subzero.TopographyElement"><code>Subzero.TopographyElement</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TopographyElement{FT}&lt;:AbstractDomainElement{FT}</code></pre><p>Singular topographic element with coordinates field storing where the element is within the grid. These are used to create the desired topography within the simulation and will be treated as islands or coastline within the model in that they will not move or break due to floe interactions, but they will affect floes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L431-L439">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.TopographyElement-Tuple" href="#Subzero.TopographyElement-Tuple"><code>Subzero.TopographyElement</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TopographyElement(args...)</code></pre><p>If a type isn&#39;t specified, TopographyElement will be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L471-L476">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.TopographyElement-Union{Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.TopographyElement-Union{Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.TopographyElement</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TopographyElement{FT}(coords)</code></pre><p>Constructor for topographic element with PolyVec coordinates Inputs:     coords      &lt;PolyVec&gt; Output:     Topographic element of abstract float type FT</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L501-L509">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.TopographyElement-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.TopographyElement-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.TopographyElement</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TopographyElement(::Type{FT}, args...)</code></pre><p>A float type FT can be provided as the first argument of any TopographyElement constructor. A TopographyElement of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L461-L467">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.TopographyElement-Union{Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.TopographyElement-Union{Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.TopographyElement</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TopographyElement{FT}(poly)</code></pre><p>Constructor for topographic element with Polygon Inputs:     poly    &lt;Polygon&gt; Output:     Topographic element of abstract float type FT</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L479-L487">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.WeldSettings" href="#Subzero.WeldSettings"><code>Subzero.WeldSettings</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WeldSettings{FT&lt;:AbstractFloat}</code></pre><p>Settings needed for welding within the model. The fields have the following meanings:</p><ul><li>weld_on: a boolean flag for if welding should be turned on in the simulation</li><li>Œîts: a list of multiples of timesteps during which welding code will run,   welding will be run at multiples of all elements, each with domain split   into corresponding Nx and Ny values</li><li>Nxs: a list of number of x-directional bins to split the domain into at   corresponding timesteps</li><li>Nys: a list of number of x-directional bins to split the domain into at   corresponding timesteps</li><li>min<em>weld</em>area: minimum area a weld can create for two floes to weld</li><li>max<em>weld</em>area: maximum area a weld can create for two floes to weld</li><li>welding<em>coeff: non-dimensional parameter, multiplied by ratio of overlap   between two floes to original floe area to determin probability that a floe   will merge. The larger this is, the more likely floes are to weld.   Probability with 5% overlap is `welding</em>coeff * (0.05) &gt; rand()`</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/process_settings.jl#L505-L525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.WeldSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.WeldSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.WeldSettings</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WeldSettings(::Type{FT}, kwargs...)</code></pre><p>A float type FT can be provided as the first argument of any WeldSettings constructor. A WeldSettings of type FT will be created by passing all other arguments to the correct constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/process_settings.jl#L590-L596">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.West" href="#Subzero.West"><code>Subzero.West</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">West&lt;:AbstractDirection</code></pre><p>A simple direction type representing if a boundary is the western boundary in a rectangular domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.::-Tuple{InteractionFields, InteractionFields}" href="#Base.::-Tuple{InteractionFields, InteractionFields}"><code>Base.::</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Create a range of interactions field columns with InteractionFields enum objects</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L115-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.empty!-Tuple{CellFloes}" href="#Base.empty!-Tuple{CellFloes}"><code>Base.empty!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">empty!(cell::CellFloes)</code></pre><p>Empties the vectors within a CellFloes object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L717-L721">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.empty!-Tuple{IceStressCell}" href="#Base.empty!-Tuple{IceStressCell}"><code>Base.empty!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">empty!(cell::IceStressCell)</code></pre><p>Empties the vectors within an IceStressCell</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/ocean_and_atmos.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.to_index-Tuple{InteractionFields}" href="#Base.to_index-Tuple{InteractionFields}"><code>Base.to_index</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Index into interactions field with InteractionFields enum objects</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L111-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Logging.handle_message-Tuple{Subzero.SubzeroLogger, Vararg{Any, 7}}" href="#Logging.handle_message-Tuple{Subzero.SubzeroLogger, Vararg{Any, 7}}"><code>Logging.handle_message</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">handle_message(
    logger::SubzeroLogger,
    level,
    message,
    _module,
    group,
    id,
    filepath,
    line;
    tstep = nothing,
    kwargs...,
)</code></pre><p>Function that determines if log event should be written to file depending on how many times that event has been written to file in current timestep.</p><p>Note:     This is called when a log macro is called (e.g. @warn), not explicitly by     the user. Additionally, it is not threadsafe so a message may be written     more times than <code>messages_per_tstep</code>, but it should be in the ballpark.     Putting a lock would slow down logging and isn&#39;t worth it given that this     problem only records a few extra log events. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/logger.jl#L105-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero._calculate_hibler-Union{Tuple{FT}, Tuple{Type{FT}, Any, Any, Any}} where FT" href="#Subzero._calculate_hibler-Union{Tuple{FT}, Tuple{Type{FT}, Any, Any, Any}} where FT"><code>Subzero._calculate_hibler</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calculate_hibler(FT, floes, pstar, c)</code></pre><p>Calculate Hibler&#39;s Elliptical Yield Curve as described in his 1979 paper &quot;A Dynamic Thermodynamic Sea Ice Model&quot;. Inputs:     floes   &lt;StructArray{Floes}&gt; model&#39;s list of floes     pstar   &lt;AbstractFloat&gt; used to tune ellipse for optimal fracturing     c       &lt;AbstractFloat&gt; used to tune ellipse for optimal fracturing Outputs:     vertices &lt;PolyVec{AbstractFloat}&gt; vertices of elliptical yield curve Note:     Hibler&#39;s paper says that: Both pstar and c relate the ice strength to the     ice thickness and compactness. c is determined to that 10% open water     reduces the strength substantially and pstar is considered a free parameter. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L67-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero._calculate_mohrs-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 4}}} where FT" href="#Subzero._calculate_mohrs-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 4}}} where FT"><code>Subzero._calculate_mohrs</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calculate_mohrs(FT, œÉ1, œÉ2, œÉ11, œÉ22)</code></pre><p>Creates PolyVec from vertex values for Mohr&#39;s Cone (triangle in 2D) Inputs:     œÉ1  &lt;AbstractFloat&gt; x-coordiante of first point in cone     œÉ2  &lt;AbstractFloat&gt; y-coordiante of first point in cone     œÉ11 &lt;AbstractFloat&gt; x-coordinate of one vertex of cone and negative of the             y-coordinate of adjacend vertex in principal stress space     œÉ22 &lt;AbstractFloat&gt; y-coordinate of one vertex of cone and negative of the     x-coordinate of adjacend vertex in principal stress space Output:     Mohr&#39;s Cone vertices (triangle since we are in 2D) in principal stress space</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L156-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero._calculate_mohrs-Union{Tuple{Type{FT}}, Tuple{FT}, Tuple{Type{FT}, Any}, Tuple{Type{FT}, Any, Any}, Tuple{Type{FT}, Any, Any, Any}} where FT" href="#Subzero._calculate_mohrs-Union{Tuple{Type{FT}}, Tuple{FT}, Tuple{Type{FT}, Any}, Tuple{Type{FT}, Any, Any}, Tuple{Type{FT}, Any, Any, Any}} where FT"><code>Subzero._calculate_mohrs</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calculate_mohrs(
    FT,
    q,
    œÉc,
    œÉ11;
    œÉ1 = nothing,
    œÉ2 = nothing,
    œÉ22 = nothing,
)</code></pre><p>Calculate Mohr&#39;s Cone coordinates in principal stress space. Inputs:     q   &lt;AbstractFloat&gt; based on the coefficient of internal friction (¬µi) by             ((Œºi^2 + 1)^(1/2) + Œºi^2     œÉc  &lt;AbstractFloat&gt; uniaxial compressive strength     œÉ11 &lt;AbstractFloat&gt; negative of the x-coordinate of one vertex of cone             (triangle in 2D) and negative of the y-coordinate of adjacend vertex             in principal stress space Outputs:     Mohr&#39;s Cone vertices (triangle since we are in 2D) in principal stress space Note:     Concepts from the following papter -     Weiss, J√©r√¥me, and Erland M. Schulson. &quot;Coulombic faulting from the grain     scale to the geophysical scale: lessons from ice.&quot; Journal of Physics D:     Applied Physics 42.21 (2009): 214017.     Equations taken from original version of Subzero written in MATLAB</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L176-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero._initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Vararg{Any, 4}}} where FT&lt;:AbstractFloat" href="#Subzero._initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Vararg{Any, 4}}} where FT&lt;:AbstractFloat"><code>Subzero._initialize_floe_field</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_initialize_floe_field(
    ::Type{FT},
    nfloes,
    concentrations,
    domain,
    hmean,
    Œîh;
    floe_settings,
    rng,
)</code></pre><p>Create a field of floes using Voronoi Tesselation. Inputs:     Type{FT}        &lt;AbstractFloat&gt; Type for grid&#39;s numberical fields -                         determines simulation run type     nfloes          &lt;Int&gt; number of floes to try to create - note you                         might not end up with this number of floes -                         topography in domain and multiple concentrations can                         decrease number of floes created     concentrations  &lt;Matrix&gt; matrix of concentrations to fill domain. If                         size(concentrations) = N, M then split the domain                         into NxM cells, each to be filled with the                         corresponding concentration. If concentration is                         below 0, it will default to 0. If it is above 1, it                         will default to 1     domain          &lt;Domain&gt; model domain      hmean           &lt;Float&gt; average floe height     Œîh              &lt;Float&gt; height range - floes will range in height from                         hmean - Œîh to hmean + Œîh     floe<em>bounds     &lt;PolyVec&gt; coordinates of boundary within which to populate floes. This                         can be smaller that the domain, but will be limited to open space                         within the domain     floe</em>settings   &lt;FloeSettings&gt; settings needed to initialize floes     rng             &lt;RNG&gt; random number generator to generate random floe                         attributes - default uses Xoshiro256++ Output:     floe_arr &lt;StructArray&gt; list of floes created using Voronoi Tesselation         of the domain with given concentrations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L508-L547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero._initialize_floe_field-Union{Tuple{V}, Tuple{FT}, Tuple{Type{FT}, V, Any, Any, Any}} where {FT&lt;:AbstractFloat, V&lt;:(AbstractVector)}" href="#Subzero._initialize_floe_field-Union{Tuple{V}, Tuple{FT}, Tuple{Type{FT}, V, Any, Any, Any}} where {FT&lt;:AbstractFloat, V&lt;:(AbstractVector)}"><code>Subzero._initialize_floe_field</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_initialize_floe_field(
    ::Type{FT},
    coords,
    domain,
    hmean,
    Œîh;
    floe_settings,
    rng,
)</code></pre><p>Create a field of floes from a list of polygon coordiantes. User is wanrned if floe&#39;s do not meet minimum size requirment.  Inputs:     Type{FT}            &lt;AbstractFloat&gt; Type for grid&#39;s numberical fields -                             determines simulation run type     coords              &lt;Vector{PolyVec}&gt; list of polygon coords to make into floes     domain              &lt;Domain&gt; model domain      hmean               &lt;Float&gt; average floe height     Œîh                  &lt;Float&gt; height range - floes will range in height from                             hmean ¬± Œîh     floe<em>settings       &lt;FloeSettings&gt; settings needed to initialize floes     rng                 &lt;RNG&gt; random number generator to generate random floe                             attributes - default uses Xoshiro256++ algorithm Output:     floe</em>arr &lt;StructArray{Floe}&gt; list of floes created from given polygon     coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L333-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.add_floe_ghosts!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}" href="#Subzero.add_floe_ghosts!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}"><code>Subzero.add_floe_ghosts!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_floe_ghosts!(floes, max_boundary, min_boundary)</code></pre><p>Add ghosts of all of the given floes passing through the two given boundaries to the list of floes. Inputs:     floes           &lt;StructArray{Floe{FT}}&gt; list of floes to find ghosts for     max<em>boundary    &lt;PeriodicBoundary&gt; northern or eastern boundary of domain     min</em>boundary    &lt;PeriodicBoundary&gt; southern or western boundary of domain Outputs:     None. Ghosts of floes are added to floe list. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L1188-L1199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.add_floe_volume!-NTuple{4, Any}" href="#Subzero.add_floe_volume!-NTuple{4, Any}"><code>Subzero.add_floe_volume!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_floe_volume!(
    floes,
    idx,
    vol,
    floe_settings,
)</code></pre><p>Add volume to existing floe and update fields that depend on the volume. Inputs:     floes           &lt;StructArray{Frloe}&gt; list of floes     idx             &lt;Int&gt; index of floe to add volume to      vol             &lt;AbstractFloat&gt; volume to add to floe     floe_settings   &lt;FloeSettings&gt; simulation&#39;s settings for making floes Outputs:     Nothing. Floe&#39;s fields are updated to reflect increase in volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/ridge_raft.jl#L5-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:PeriodicBoundary, var&quot;#s86&quot;&lt;:PeriodicBoundary, var&quot;#s85&quot;&lt;:PeriodicBoundary, var&quot;#s84&quot;&lt;:PeriodicBoundary, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat" href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:PeriodicBoundary, var&quot;#s86&quot;&lt;:PeriodicBoundary, var&quot;#s85&quot;&lt;:PeriodicBoundary, var&quot;#s84&quot;&lt;:PeriodicBoundary, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat"><code>Subzero.add_ghosts!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_ghosts!(
    elems,
    domain,
)</code></pre><p>Add ghosts for elements that pass through any of the boundaries.  Inputs:     elems   &lt;StructArray{Floe} or StructArray{TopographyElement}&gt; list of                 elements to add ghosts to     domain  &lt;Domain{                 AbstractFloat,                 PeriodicBoundary,                 PeriodicBoundary,                 PeriodicBoundary,                 PeriodicBoundary,             }&gt; domain with all boundaries Outputs:         None. Ghosts are added to list of elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L1324-L1343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:PeriodicBoundary, var&quot;#s86&quot;&lt;:PeriodicBoundary, var&quot;#s85&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s84&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat" href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:PeriodicBoundary, var&quot;#s86&quot;&lt;:PeriodicBoundary, var&quot;#s85&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s84&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat"><code>Subzero.add_ghosts!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_ghosts!(
    elems,
    domain,
)</code></pre><p>Add ghosts for elements that pass through the northern or southern boundaries. Inputs:         elems   &lt;StructArray{Floe} or StructArray{TopographyElement}&gt; list of                     elements to add ghosts to         domain  &lt;Domain{                     Float,                     PeriodicBoundary,                     PeriodicBoundary,                     NonPeriodicBoundary,                     NonPeriodicBoundary,                 }&gt; domain with northern and southern periodic boundaries Outputs:         None. Ghosts are added to list of elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L1256-L1275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s86&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s85&quot;&lt;:PeriodicBoundary, var&quot;#s84&quot;&lt;:PeriodicBoundary, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat" href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s86&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s85&quot;&lt;:PeriodicBoundary, var&quot;#s84&quot;&lt;:PeriodicBoundary, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat"><code>Subzero.add_ghosts!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_ghosts!(
    elems,
    domain,
)</code></pre><p>Add ghosts for elements that pass through the eastern or western boundaries.  Inputs:     elems   &lt;StructArray{Floe} or StructArray{TopographyElement}&gt; list of                 elements to add ghosts to     domain  &lt;Domain{                 Float,                 NonPeriodicBoundary,                 NonPeriodicBoundary,                 PeriodicBoundary,                 PeriodicBoundary,             }&gt; domain with eastern and western periodic boundaries  Outputs:     None. Ghosts are added to list of elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L1290-L1309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s86&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s85&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s84&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat" href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s86&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s85&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s84&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat"><code>Subzero.add_ghosts!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_ghosts!(
    elems,
    domain,
)</code></pre><p>When there are no periodic boundaries, no ghosts should be added. Inputs:         None are used.  Outputs:         None. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L1231-L1242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.add_point!-Tuple{CellFloes, Any, Any, Any}" href="#Subzero.add_point!-Tuple{CellFloes, Any, Any, Any}"><code>Subzero.add_point!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_point!(
    cfloes::CellFloes,
    floeidx,
    Œîx,
    Œîy,
)</code></pre><p>Add floe to CellFloes list of floes within that grid cell and aggragate the stress caused by monte carlo point in floe into IceStressCell object. Inputs:     cfloes  &lt;CellFloes&gt; CellFloes object representing one grid cell (centered on                 model&#39;s grid lines)     floeidx &lt;Int&gt; floe index within model&#39;s list of floes     Œîx      &lt;AbstractFloat&gt; x-translation to move floe from current position into                 given grid cell if shifted due to periodic boundaries     Œîy      &lt;AbstractFloat&gt; y-translation to move floe from current position into                 given grid cell if shifted due to periodic boundaries Outputs:     None. Add information to both cfloes to record where floe is on model grid. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L1352-L1371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.add_point!-Tuple{CellFloes, IceStressCell, Vararg{Any, 5}}" href="#Subzero.add_point!-Tuple{CellFloes, IceStressCell, Vararg{Any, 5}}"><code>Subzero.add_point!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_point!(
    cfloes::CellFloes,
    scell::IceStressCell,
    floeidx,
    œÑx,
    œÑy,
    Œîx,
    Œîy,
)</code></pre><p>Add floe to CellFloes list of floes within that grid cell and aggragate the stress caused by monte carlo point in floe into IceStressCell object. Inputs:     cfloes  &lt;CellFloes&gt; CellFloes object representing one grid cell (centered on                 model&#39;s grid lines)     scell   &lt;IceStressCell&gt; IceStressCell aggragating stresses from floes within                 grid cell from each floes&#39; monte carlo points     floeidx &lt;Int&gt; floe index within model&#39;s list of floes     œÑx      &lt;AbstractFloat&gt; x-directional stress from monte carlo point on ocean     œÑy      &lt;AbstractFloat&gt; y-directional stress from monte carlo point on ocean     Œîx      &lt;AbstractFloat&gt; x-translation to move floe from current position into                 given grid cell if shifted due to periodic boundaries     Œîy      &lt;AbstractFloat&gt; y-translation to move floe from current position into                 given grid cell if shifted due to periodic boundaries Outputs:     None. Add information to both cfloes and scell to aggregate stress on ocean     grid cell and record where floe is on model grid. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L1301-L1328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.auto_extension-Tuple{Any, Any}" href="#Subzero.auto_extension-Tuple{Any, Any}"><code>Subzero.auto_extension</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">auto_extension(filename, ext)</code></pre><p>If <code>filename</code> ends in <code>ext</code>, return <code>filename</code>. Otherwise return <code>filename * ext</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L755-L760">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.bin_floe_centroids-NTuple{5, Any}" href="#Subzero.bin_floe_centroids-NTuple{5, Any}"><code>Subzero.bin_floe_centroids</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bin_floe_centroids(floes, grid, domain, Nx, Ny)</code></pre><p>Split floe locations into a grid of Nx by Ny by floe centroid location Inputs:     floes       &lt;StructArray{Floe}&gt; simulation&#39;s list of floes     grid        &lt;RegRectilinearGrid&gt; simulation&#39;s grid     domain      &lt;Domain&gt; simulation&#39;s domain     Nx          &lt;Int&gt; number of grid cells in the x-direction to split domain                     into for welding groups     Ny          &lt;Int&gt; number of grid cells in the y-direction to split domain                     into for welding groups Outputs:     floe<em>bins   &lt;Matrix{Vector{Int}}&gt; Nx by Ny matrix where each element is a                     list of floe indices whose centroids are in the                     corresponding section of the grid. May also have elements of                     value 0 if there are less than average number of floes in                      the section.     nfloes      &lt;Maxtrix{Int}&gt; Nx by Ny matrix where each element is the total                     number of indices within floe</em>bins[Nx, Ny] that are                     non-zeros and represent a floe within the grid section.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/welding.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.boundary_coords-Tuple{Any, Type{East}}" href="#Subzero.boundary_coords-Tuple{Any, Type{East}}"><code>Subzero.boundary_coords</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_coords(grid, ::Type{East})</code></pre><p>Determine coordinates of eastern-most boundary of domain if around the edge of the grid. Inputs:     grid    &lt;AbstractGrid&gt; model grid             &lt;Type{East}&gt; boundary direction type Output:     PolyVec of boundary coordinates. See documentation of North method of this     function for more details. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L96-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.boundary_coords-Tuple{Any, Type{North}}" href="#Subzero.boundary_coords-Tuple{Any, Type{North}}"><code>Subzero.boundary_coords</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_coords(grid, ::Type{North})</code></pre><p>Determine coordinates of northen-most boundary of domain if around the edge of the grid. Inputs:     grid    &lt;AbstractGrid&gt; model grid             &lt;Type{North}&gt; boundary direction type Output:     PolyVec of boundary coordinates. These coordinates describe a rectangle that     has a length 2-times the length of the grid in the x-direction, centered on     the grid so that there is a buffer of half of the grid on either side. The     height is half of the grid in the y-direction. This buffer prevents pieces     of floes from passing outside the boundary before the next timestep -     possibly too cautious. If boundary_coords methods are used for each     direction, corners will be shared between adjacent boundaries. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L45-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.boundary_coords-Tuple{Any, Type{South}}" href="#Subzero.boundary_coords-Tuple{Any, Type{South}}"><code>Subzero.boundary_coords</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_coords(grid, ::Type{South})</code></pre><p>Determine coordinates of southern-most boundary of domain if around the edge of the grid. Inputs:     grid    &lt;AbstractGrid&gt; model grid             &lt;Type{South}&gt; boundary direction type Output:     PolyVec of boundary coordinates. See documentation of North method of this     function for more details. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L73-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.boundary_coords-Tuple{Any, Type{West}}" href="#Subzero.boundary_coords-Tuple{Any, Type{West}}"><code>Subzero.boundary_coords</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_coords(grid, ::Type{West})</code></pre><p>Determine coordinates of western-most boundary of domain if around the edge of the grid. Inputs:     grid    &lt;AbstractGrid&gt; model grid             &lt;Type{West}&gt; boundary direction Output:     PolyVec of boundary coordinates. See documentation of North method of this     function for more details. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L119-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_angular_momentum-NTuple{7, Any}" href="#Subzero.calc_angular_momentum-NTuple{7, Any}"><code>Subzero.calc_angular_momentum</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_angular_momentum(u, v, mass, Œæ, moment, x, y)</code></pre><p>Calculates angular momentum for one timestep given the floe&#39;s velocities, mass, moment of intertia, and centroid position. Inputs:     u       &lt;Vector{Real}&gt; list of floes&#39; u velocities     v       &lt;Vector{Real}&gt; list of floes&#39; v velocities     mass    &lt;Vector{Real}&gt; list of floes&#39; masses     Œæ       &lt;Vector{Real}&gt; list of floes&#39; angular velocities     moment  &lt;Vector{Real}&gt; list of floes&#39; moments of intertia     x       &lt;Vector{Real}&gt; list of floes&#39; centroid x-value     y       &lt;Vector{Real}&gt; list of floes&#39; centroid y-value Outputs:     &lt;Real&gt; total spin angular momentum from the floes     &lt;Real&gt; total orbital angular momentum from the floes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/tools/conservation_em.jl#L41-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_atmosphere_forcing-NTuple{7, Any}" href="#Subzero.calc_atmosphere_forcing-NTuple{7, Any}"><code>Subzero.calc_atmosphere_forcing</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_atmosphere_forcing(
    mc_xr, 
    mc_yr,
    upoint,
    vpoint,
    uatm_interp,
    vatm_interp,
    c,
)</code></pre><p>Calculates the stresses on a floe from the atmosphere above at given monte carlo point. Inputs:     mc<em>xr       &lt;AbstractFloat&gt; monte carlo point x-coordinate     mc</em>yr       &lt;AbstractFloat&gt; monte carlo point y-coordinate     upoint      &lt;AbstractFloat&gt; u velocity of floe at monte carlo point     vpoint      &lt;AbstractFloat&gt; v velocity of floe at monte carlo point     uatm<em>interp &lt;Interplations object&gt; linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the atompshere u velocity onto point     vatm</em>interp &lt;Interplations object&gt; linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the atompshere v velocity onto point     c           &lt;Constants&gt; simulation&#39;s constants Outputs:     œÑx<em>atm  &lt;AbstractFloat&gt; stress from atmosphere on floe in                 x-direction at given monte carlo point     œÑy</em>atm  &lt;AbstractFloat&gt; stress from atmosphere on floe in                 y-direction at given monte carlo point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L1181-L1211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_elastic_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat" href="#Subzero.calc_elastic_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat"><code>Subzero.calc_elastic_forces</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_elastic_forces(
    p1,
    p2,
    regions,
    region_areas,
    force_factor,
    consts,
)</code></pre><p>Calculate normal forces, the point the force is applied, and the overlap area of regions created from floe collisions  Inputs:     p1              &lt;Polygon&gt; first floe&#39;s polygon in collision     p2              &lt;Polygon&gt; second floe&#39;s polygon in collision     regions         &lt;Vector{Polygon}&gt; polygon regions of overlap during                         collision     region<em>areas    &lt;Vector{Float}&gt; area of each polygon in regions     force</em>factor    &lt;Float&gt; Spring constant equivalent for collisions Outputs:     force   &lt;Array{Float, n, 2}&gt; normal forces on each of the n regions greater                 than a minimum area     fpoint  &lt;Array{Float, n, 2}&gt; point force is applied on each of the n regions                 greater than a minimum area     overlap &lt;Array{Float, n, 2}&gt; area of each of the n regions greater than a                 minimum area     Œîl      &lt;Float&gt; mean length of distance between intersection points</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L121-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_eulerian_data!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}" href="#Subzero.calc_eulerian_data!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}"><code>Subzero.calc_eulerian_data!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_eulerian_data!(floes, topography, writer, istep)</code></pre><p>Calculate floe data averaged on grid defined by GridOutputWriter for current timestep (istep). Inputs:     floes       &lt;StructArray{Floe}&gt; array of model&#39;s floes     topography  &lt;StructArray{Topography} array of  model&#39;s topography     writer      &lt;GridOutputWriter&gt;      istep       &lt;Int&gt; current simulation timestep Output:     Floe data averaged on eularian grid provided and saved in writer.data field </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L781-L793">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_friction_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Matrix{FT}, Any, Any, Any}} where FT" href="#Subzero.calc_friction_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Matrix{FT}, Any, Any, Any}} where FT"><code>Subzero.calc_friction_forces</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_friction_forces(
    ifloe,
    jfloe,
    fpoints,
    normal::Matrix{FT},
    Œîl,
    consts,
    Œît,
)</code></pre><p>Calculate frictional force for collision between two floes or a floe and a domain element. Input:     ifloe   &lt;Floe&gt; first floe in collsion     jfloe   &lt;Union{Floe, DomainElement}&gt; either second floe or topography                 element/boundary element     fpoints &lt;Array{Float, N, 2}&gt; x,y-coordinates of the point the force is                 applied on floe overlap region     normal  &lt;Array{Float, N, 2}&gt; x,y normal force applied on fpoint on floe                 overlap region     Œîl      &lt;Vector&gt; mean length of distance between intersection points     consts  &lt;Constants&gt; model constants needed for calculations     Œît      &lt;AbstractFloat&gt; simulation&#39;s timestep Outputs:     force   &lt;Array{Float, N, 2}&gt; frictional/tangential force of the collision in                 x and y (each row) for each collision (each column)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L239-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_kinetic_energy-NTuple{5, Any}" href="#Subzero.calc_kinetic_energy-NTuple{5, Any}"><code>Subzero.calc_kinetic_energy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_total_energy(u, v, mass, Œæ, moment)</code></pre><p>Calculates linear and rotational energy for one timestep given the floe&#39;s velocities, mass, and moment of intertia. Inputs:     u       &lt;Vector{Real}&gt; list of floes&#39; u velocities     v       &lt;Vector{Real}&gt; list of floes&#39; v velocities     mass    &lt;Vector{Real}&gt; list of floes&#39; masses     Œæ       &lt;Vector{Real}&gt; list of floes&#39; angular velocities     moment  &lt;Vector{Real}&gt; list of floes&#39; moments of intertia Outputs:     linear      &lt;Real&gt; total linear kinetic energy generated by the floes     rotational  &lt;Real&gt; total rotational kinetic energy generated by the floes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/tools/conservation_em.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_linear_momentum-Tuple{Any, Any, Any}" href="#Subzero.calc_linear_momentum-Tuple{Any, Any, Any}"><code>Subzero.calc_linear_momentum</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_linear_momentum(u, v, mass)</code></pre><p>Calculates linear momentum for one timestep given the floe&#39;s velocities and mass. Inputs:     u       &lt;Vector{Real}&gt; list of floes&#39; u velocities     v       &lt;Vector{Real}&gt; list of floes&#39; v velocities     mass    &lt;Vector{Real}&gt; list of floes&#39; masses Outputs:     &lt;Real&gt; total linear momentum in the x-direction from floes     &lt;Real&gt; total linear momentum in the y-direction from floes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/tools/conservation_em.jl#L22-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_normal_force-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat" href="#Subzero.calc_normal_force-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat"><code>Subzero.calc_normal_force</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_normal_force(
    c1,
    c2,
    region,
    area,
    ipoints,
    force_factor,
)</code></pre><p>Calculate normal force for collision between polygons p1 and p2 given an overlapping region, the area of that region, their intersection points in the region, and a force factor.  Inputs:     p1           &lt;Polys&gt; first polygon     p2           &lt;Polys&gt; second polygon     region       &lt;PolyVec{Float64}&gt; coordiantes for one region of intersection                     between the polygons     area         &lt;Float&gt; area of region     ipoints      &lt;Vector{Tuple{Float, Float} or Vector{Vector{Float}}}&gt; Points                     of intersection between polygon 1 and 2     force_factor &lt;Float&gt; Spring constant equivalent for collisions Outputs:         &lt;Float&gt; normal force of collision         Œîl &lt;Float&gt; mean length of distance between intersection points</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L5-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_ocean_forcing!-NTuple{9, Any}" href="#Subzero.calc_ocean_forcing!-NTuple{9, Any}"><code>Subzero.calc_ocean_forcing!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_ocean_forcing!(
    mc_xr,
    mc_yr,
    upoint,
    vpoint,
    uocn_interp,
    vocn_interp,
    hflx_interp,
    ma_ratio,
    c,
)</code></pre><p>Calculates the stresses on a floe from the ocean above at given monte carlo point. Inputs:     mc<em>xr       &lt;AbstractFloat&gt; monte carlo point x-coordinate     mc</em>yr       &lt;AbstractFloat&gt; monte carlo point y-coordinate     upoint      &lt;AbstractFloat&gt; u velocity of floe at monte carlo point     vpoint      &lt;AbstractFloat&gt; v velocity of floe at monte carlo point     uocn<em>interp &lt;Interplations object&gt; linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the ocean u velocity onto point     vocn</em>interp &lt;Interplations object&gt; linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the ocean v velocity onto point     hflx<em>interp &lt;Interplations object&gt; linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the ocean heatflux factor velocity onto point     ma</em>ratio    &lt;AbstractFloat&gt; floe&#39;s mass to area ratio     c           &lt;Constants&gt; simulation&#39;s constants Outputs:     œÑx<em>ocn          &lt;AbstractFloat&gt; stress from ocean velocity on floe in                         x-direction at given monte carlo point     œÑy</em>ocn          &lt;AbstractFloat&gt; stress from ocean velocity on floe in                         y-direction at given monte carlo point     œÑx<em>pressure‚àá    &lt;AbstractFloat&gt; stress from ocean pressure gradient on floe                         in x-direction at given monte carlo point     œÑy</em>pressure‚àá    &lt;AbstractFloat&gt; stress from ocean pressure gradient on floe                         in y-direction at given monte carlo point     hflx_factor     &lt;AbstractFloat&gt; heatflux factor at given monte carlo point                         from the heatflux factors of ocean below floe</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L1234-L1276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_one_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT" href="#Subzero.calc_one_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT"><code>Subzero.calc_one_way_coupling!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_one_way_coupling!(
    floes::StructArray{Floe{FT}},
    grid,
    atmos,
    ocean,
    domain,
    coupling_settings,
    consts,
)</code></pre><p>Preforms calculations needed for one way coupling by calculating floe&#39;s forcings from ocean and atmosphere as well as the heatflux below a given floe.</p><p>Floe location on grid is also recorded. If two-way coupling is on, total stress on each grid cell per-floe in grid cell is also recorded for use in calc<em>two</em>way<em>coupling! Inputs:     floes               &lt;StructArray{Floe{FT}}&gt; model&#39;s floe list     grid                &lt;AbstractGrid&gt; model&#39;s grid     atmos               &lt;Ocean&gt; model&#39;s atmosphere     ocean               &lt;Ocean&gt; model&#39;s ocean     domain              &lt;Domain&gt; model&#39;s domain     coupling</em>settings   &lt;CouplingSettings&gt; simulation coupling settings     consts              &lt;Constants&gt; simulation&#39;s constants Ouputs:     None. Update each floe&#39;s forces, torque, and heatflux factor from     ocean/atmosphere. Determine location of floe within grid and if two-way     coupling in enabled, save floe stress on grid. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L1456-L1485">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_strain!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}}, Tuple{FT}} where FT" href="#Subzero.calc_strain!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}}, Tuple{FT}} where FT"><code>Subzero.calc_strain!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_strain!(coords, centroid, u, v, Œæ, area)</code></pre><p>Calculates the strain on a floe given the velocity at each vertex Inputs:     floe        &lt;Floe{AbstractFloat}&gt; a floe Outputs:     strain      &lt;Matrix{AbstractFloat}&gt; 2x2 matrix for floe strain </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/update_floe.jl#L416-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_stress!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Any, Any}} where FT" href="#Subzero.calc_stress!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Any, Any}} where FT"><code>Subzero.calc_stress!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_stress!(floe)</code></pre><p>Calculates the stress on a floe for current collisions given interactions and floe properties. Inputs:     floe          &lt;Union{LazyRow{Floe{AbstractFloat}}, Floe{AbstractFloat}&gt; properties of floe     floe<em>settings &lt;FloeSettings{AbstractFloat}&gt; Settings to create floes within model     Œît            &lt;AbstractFloat&gt; Simulation timestep in seconds Outputs:     Does not return anything, but updates floe.stress</em>accum and floe.stress_instant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/update_floe.jl#L380-L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_subfloe_values!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat" href="#Subzero.calc_subfloe_values!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat"><code>Subzero.calc_subfloe_values!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_subfloe_values!(
    floe::Union{Floe{FT}, LazyRow{Floe{FT}}},
    grid,
    domain,
    mc_cart,
    mc_grid_idx,
)</code></pre><p>Calculates subfloe point&#39;s cartesian coordiantes, polar coordiantes, velocity and index within the grid.  Inputs:     floe        &lt;Union{Floe{AbstractFloat}, LazyRow{Floe{AbstractFloat}}}&gt; floe     grid        &lt;AbstractGrid&gt; model&#39;s grid     domain      &lt;Domain&gt; model&#39;s domain     mc<em>cart     &lt;Matrix{AbstractFloat}&gt; pre-allocated nx2 matrix for floe&#39;s                     monte carlo point&#39;s cartesian coordinates where the first                     column is x and second is y     mc</em>grid<em>idx &lt;Matrix{AbstractFloat}&gt; pre-allocated nx2 matrix for floe&#39;s                     monte carlo point&#39;s grid indices where the first column is                     the column and the second is the row that the point is in on                     the grid split into cells centered on grid lines. Outputs:     j   &lt;Int&gt; last element in mc</em>cart and mc<em>grid</em>idx that holds monte carlo             point information for given floe.     mc<em>cart and mc</em>grid_idx filled with data for given floe&#39;s monte carlo points     up to row j.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L599-L626">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_torque!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{&lt;:Floe{FT}}}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.calc_torque!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{&lt;:Floe{FT}}}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.calc_torque!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_torque!(floe)</code></pre><p>Calculate a floe&#39;s torque based on the interactions. Inputs:         floe  &lt;Floe&gt; floe in model Outputs:         None. Floe&#39;s interactions field is updated with calculated torque.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L846-L854">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.calc_two_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, RegRectilinearGrid, Vararg{Any, 6}}} where FT" href="#Subzero.calc_two_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, RegRectilinearGrid, Vararg{Any, 6}}} where FT"><code>Subzero.calc_two_way_coupling!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_two_way_coupling!(
    floes::StructArray{Floe{FT}},
    grid::RegRectilinearGrid,
    atmos,
    ocean,
    domain,
    floe_settings,
    consts,
    Œît,
)</code></pre><p>Calculate effects of ice and atmosphere on the ocean and update ocean stress fields and sea ice fraction. Inputs:     floes           &lt;StructArray{Floe}&gt; model&#39;s floes     grid            &lt;AbstractGrid&gt; model&#39;s grid     atmos           &lt;Atmos&gt; model&#39;s atmosphere     ocean           &lt;Ocean&gt; model&#39;s ocean     domain          &lt;Domain&gt; model&#39;s domain     floe_settings   &lt;FloeSettings&gt; simulation&#39;s floe settings     consts          &lt;Constants&gt; model&#39;s constants     Œît              &lt;Int&gt; simulation&#39;s timestep in seconds Output:     None. Update&#39;s ocean&#39;s stress fields and heatflux factor field. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L1591-L1616">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.center_cell_coords-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Int64, RegRectilinearGrid, Any, Any}} where FT" href="#Subzero.center_cell_coords-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Int64, RegRectilinearGrid, Any, Any}} where FT"><code>Subzero.center_cell_coords</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center_cell_coords(
    xidx::Int,
    yidx::Int,
    grid::RegRectilinearGrid,
    ns_bound,
    ew_bound,
)</code></pre><p>Find the coordinates of a given grid cell, centered on a grid line with row yidx and column xidx. This is offset from the cells within the regular rectilinear grid by half of a grid cell.  Inputs:     xidx        &lt;Int&gt; x index of grid line within list of gridlines (cell column)     yidx        &lt;Int&gt; y index of grid line within list of gridlines (cell row)     grid        &lt;RegRectilinearGrid&gt; model&#39;s grid      ns<em>bound    &lt;AbstractBoundary&gt; type of either north or south boundary - for                     checking if periodic     ew</em>bound    &lt;AbstractBoundary&gt; type of either east or west boundary - for                     checking if perioidic Output:     &lt;PolyVec&gt; coordinates for cell centered on grid line with given indices.     Note that cell bounds will be adjusted depending on if the bounds are     periodic. Cells cannot extend outside of non-periodic boundaries and thus     will be trimmed at boundaries. Therefore, if indices place cell completely     outside of grid, could return a line at the edge of the boundary. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L1089-L1115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, PeriodicBoundary}" href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, PeriodicBoundary}"><code>Subzero.check_cell_bounds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_cell_bounds(
    xmin,
    xmax,
    ymin,
    ymax,
    grid,
    ::PeriodicBoundary,
    ::PeriodicBoundary,
)</code></pre><p>Return cell bounding values as is given the domain is doubley periodic and thus the cell can extend beyond the grid as it will simply wrap back around into grid through opposite periodic boundary. Inputs:     xmin    &lt;Float&gt; center cell minimum x value     xmax    &lt;Float&gt; center cell maxumum x value     ymin    &lt;Float&gt; center cell minimum y value     ymax    &lt;Float&gt; center cell maximum y value     grid    &lt;AbstractGrid&gt; model&#39;s grid             &lt;PeriodicBoundary&gt; type of north or south boundary - periodic pair             &lt;PeriodicBoundary&gt; type of east or west boundary - periodic pair Output:     x and y minimums and maximums as given since they can extend past the grid     due to periodic boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L905-L930">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}" href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.check_cell_bounds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_cell_bounds(
    xmin,
    xmax,
    ymin,
    ymax,
    grid,
    ::PeriodicBoundary,
    ::NonPeriodicBoundary,
)</code></pre><p>Trim cell bound in the east-west direction if it exends past grid due to non-periodic boundary pair. Inputs:     xmin    &lt;Float&gt; center cell minimum x value     xmax    &lt;Float&gt; center cell maxumum x value     ymin    &lt;Float&gt; center cell minimum y value     ymax    &lt;Float&gt; center cell maximum y value     grid    &lt;AbstractGrid&gt;             &lt;PeriodicBoundary&gt; type of either north or south boundary - periodic                 pair             &lt;NonPeriodicBoundary&gt; type of either east or west boundary - not a                 periodic pair Output:     Potentially trimmed x min and max if these values extend beyond grid values.     Else returned unchanged. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L989-L1015">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}" href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}"><code>Subzero.check_cell_bounds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_cell_bounds(
    xmin,
    xmax,
    ymin,
    ymax,
    grid,
    ::NonPeriodicBoundary,
    ::PeriodicBoundary,
)</code></pre><p>Trim cell bound in the north-south direction if it exends past grid due to non-periodic boundary pair. Inputs:     xmin    &lt;Float&gt; center cell minimum x value     xmax    &lt;Float&gt; center cell maxumum x value     ymin    &lt;Float&gt; center cell minimum y value     ymax    &lt;Float&gt; center cell maximum y value     grid    &lt;AbstractGrid&gt;             &lt;NonPeriodicBoundary&gt; type of either north or south boundary - not a                 periodic pair             &lt;PeriodicBoundary&gt; type of either east or west boundary - periodic                 pair Output:         Potentially trimmed y min and y max if these values extend beyond grid         values. Else returned unchanged. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L943-L969">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}" href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.check_cell_bounds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_cell_bounds(
    xmin,
    xmax,
    ymin,
    ymax,
    grid,
    ::NonPeriodicBoundary,
    ::NonPeriodicBoundary,
)</code></pre><p>Trim cell bounds in the east-west and north-south direction if they exend past grid due to non-periodic boundary pairs. Inputs:     xmin    &lt;Float&gt; center cell minimum x value     xmax    &lt;Float&gt; center cell maxumum x value     ymin    &lt;Float&gt; center cell minimum y value     ymax    &lt;Float&gt; center cell maximum y value     grid    &lt;AbstractGrid&gt;             &lt;NonPeriodicBoundary&gt; type of either north or south boundary - not a                 periodic pair             &lt;NonPeriodicBoundary&gt; type of either east or west boundary - not a                 periodic pair Output:     Potentially trimmed x and y minimums and maximums if these values extend     beyond grid values. Else returned unchanged. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L1035-L1061">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.check_energy_momentum_conservation_julia" href="#Subzero.check_energy_momentum_conservation_julia"><code>Subzero.check_energy_momentum_conservation_julia</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_energy_momentum_conservation_julia(filename, dir, verbose)</code></pre><p>Calculates total kinetic energy and momentum at each timestep and plots the output to check for conservation from floe outputwriter file. Also gives percent change in energy and momentum from first to last timestep in terminal. Inputs:     filename    &lt;String&gt; floe outputwriter filename + path     dir         &lt;String&gt; directory to save total energy and momentum                     conservation plots     plot        &lt;Bool&gt; plots energy and momentum over time if true Outputs:     Œîenergy    &lt;Float&gt; percentage change in energy from first to last timestep     Œîxmomentum       &lt;Float&gt; % change in x momentum from first to last timestep     Œîymomentum       &lt;Float&gt; % change in y momentum from first to last timestep     Œîangularmomentum &lt;Float&gt; % change in angular momentum from first to last                         timestep     Also saves energy and momentum plots over time to given directory if plots     is true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/tools/conservation_em.jl#L153-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.check_energy_momentum_conservation_matlab" href="#Subzero.check_energy_momentum_conservation_matlab"><code>Subzero.check_energy_momentum_conservation_matlab</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_energy_momentum_conservation_matlab(mat_path, dir, plot)</code></pre><p>Calculates total kinetic energy and momentum at each timestep and plots the output to check for conservation from MATLAB verion of model output. The mat<em>path should lead to the Floes file within the MATLAB version of the model. Also givesnpercent change in energy and momentum from first to last timestep in terminal. Inputs:     mat</em>path    &lt;String&gt; path to MATLAB version&#39;s Floe folder      dir         &lt;String&gt; directory to save total energy and momentum                     conservation plots     plot        &lt;Bool&gt; plots energy and momentum over time if true Outputs:     Œîenergy    &lt;Float&gt; percentage change in energy from first to last timestep     Œîxmomentum       &lt;Float&gt; % change in x momentum from first to last timestep     Œîymomentum       &lt;Float&gt; % change in y momentum from first to last timestep     Œîangularmomentum &lt;Float&gt; % change in angular momentum from first to last                         timestep     Also saves energy and momentum plots over time to given directory if plots     is true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/tools/conservation_em.jl#L240-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.check_for_edge_mid-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT" href="#Subzero.check_for_edge_mid-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT"><code>Subzero.check_for_edge_mid</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_for_edge_mid(c, start, stop, shared_idx, shared_dist, running_dist)</code></pre><p>Check if indices from start to stop index of given coords includes midpoint given the shared distance and return midpoint if it exists in given range. Inputs:     c               &lt;PolyVec&gt; floe coordinates     start           &lt;Int&gt; index of shared<em>index list to start search from     stop            &lt;Int&gt; index of shared</em>index list to stop search at     shared<em>idx      &lt;Vector{Int}&gt; list of indices of c used to calculate midpoint     shared</em>dist     &lt;Float&gt; total length of edges considered from shared<em>idx     running</em>dist    &lt;Float&gt; total length of edges traveled along in midpoint                         search so far Outputs:     mid<em>x           &lt;Float&gt; x-coordinate of midpoint, Inf if midpoint not in                         given range     mid</em>y           &lt;Float&gt; y-coordinate of midpoint, Inf if midpoint not in                         given range     running_dist    &lt;Float&gt; sum of distances travelled along shared edges</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L418-L437">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.compare_floe_data-Tuple{Any, Any}" href="#Subzero.compare_floe_data-Tuple{Any, Any}"><code>Subzero.compare_floe_data</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compare_floe_data(filename1, filename2)</code></pre><p>Compare two files output by the floe output writer. Prints out first instances of not matching per timestep and field.  Inputs:     filename1   &lt;String&gt; filename and path of first file     filename2   &lt;String&gt; filename and path of second file Outputs:     If there are instances of differences, function will print time and index of     floes that don&#39;t match</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/tools/compare_files.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.compare_grid_data-Tuple{Any, Any}" href="#Subzero.compare_grid_data-Tuple{Any, Any}"><code>Subzero.compare_grid_data</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compare_grid_data(filename1, filename2)</code></pre><p>Compare two files output by the grid output writer. Prints out first instances of not matching per field. All timesteps are compared at once.  Inputs:     filename1   &lt;String&gt; filename and path of first file     filename2   &lt;String&gt; filename and path of second file Outputs:     If there are instances of differences, function will print the field that     has discrepancies. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/tools/compare_files.jl#L51-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.compare_oa_checkpointer_data-Tuple{Any, Any}" href="#Subzero.compare_oa_checkpointer_data-Tuple{Any, Any}"><code>Subzero.compare_oa_checkpointer_data</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compare_checkpointer_data(filename1, filename2)</code></pre><p>Compare two files output by the checkpointer output writer. Compares ocean and atmosphere. If there are discrepancies between the files, it will timesteps and field.  Inputs:     filename1   &lt;String&gt; filename and path of first file     filename2   &lt;String&gt; filename and path of second file Outputs:     If there are instances of differences, function will print the field and     timesteps that have discrepancies. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/tools/compare_files.jl#L83-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.conserve_momentum_change_floe_shape!" href="#Subzero.conserve_momentum_change_floe_shape!"><code>Subzero.conserve_momentum_change_floe_shape!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conserve_momentum_change_floe_shape!(
    mass_tmp,
    moment_tmp,
    x_tmp,
    y_tmp,
    Œît,
    keep_floe,
    combine_floe = nothing,
)</code></pre><p>Update current and previous velocity/acceleration fields to conserve momentum of a floe whose shape has been changed, given the previous mass, momentum, and centroid. Inputs:     mass<em>tmp    &lt;AbstractFloat&gt; original mass of floe before shape change     moment</em>tmp  &lt;AbstractFloat&gt; original moment of intertia of floe before shape                     change     x<em>tmp       &lt;AbstractFloat&gt; original x-coordinate of centroid of floe before                     shape change     y</em>tmp       &lt;AbstractFloat&gt; original y-coordinate of centroid of floe before                     shape change     Œît          &lt;Int&gt; timestep of simulation in seconds     keep<em>floe   &lt;Union{Floe, LazyRow{Floe}}&gt; floe whose shape has been changed     combine</em>floe &lt;Union{Floe, LazyRow{Floe}}&gt; if keep<em>floe&#39;s shape has been                     changed due to an interaction with another floe, combine</em>floe                     is that floe - optional parameter Output:     None. keep<em>floe&#39;s u, v, Œæ, p</em>dxdt, p<em>dydt, p</em>dŒ±dt, p<em>dudt, p</em>dvdt, and     p_dŒædt fields all updated to preserve momentum.  Note:     Function does not depend on conservation of mass</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/update_floe.jl#L70-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.conserve_momentum_fracture_floe!-Union{Tuple{FT}, Tuple{Any, StructArrays.StructArray{&lt;:Floe{FT}}, Any}} where FT" href="#Subzero.conserve_momentum_fracture_floe!-Union{Tuple{FT}, Tuple{Any, StructArrays.StructArray{&lt;:Floe{FT}}, Any}} where FT"><code>Subzero.conserve_momentum_fracture_floe!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conserve_momentum_fracture_floe!(
    init_floe,
    new_floes,
    Œît,
)</code></pre><p>Update new<em>floes&#39;s current and previous velocity/acceleration fields to conserve momentum when a floe has been fractured into several new floes, given the previous mass, momentum, and centroid. The assumption is made that each new floe has the same velocities/accelerations Inputs:     init</em>floe   &lt;Union{Floe, LazyRow{Floe}}&gt; original floe     new<em>floes   &lt;StructArray{Floe}&gt; fractured pieces of original floe     Œît          &lt;Int&gt; simulation&#39;s timestep in seconds Output:     None. new</em>floes velocities and accelerations are updated for current and     previous timestep to conserve momentum. Note: Depends on conservation of mass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/update_floe.jl#L235-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.conserve_momentum_transfer_mass!" href="#Subzero.conserve_momentum_transfer_mass!"><code>Subzero.conserve_momentum_transfer_mass!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conserve_momentum_transfer_mass!(
    floes,
    idx1, idx2,
    m1, m2,
    I1, I2,
    x1, x2,
    y1, y2,
    Œît,
    pieces_list = nothing,
    pieces_idx = 0,
)</code></pre><p>Conserve linear momentum when mass is transfered from one floe to another floe. Inputs:     floes       &lt;StructArray{Floes}&gt; list of floes     idx1        &lt;Int&gt; index of first floe in floes list     idx2        &lt;Int&gt; index of second floe in floes list     m1          &lt;Float&gt; initial mass of first floe before mass transfer     m2          &lt;Float&gt; initial mass of second floe before mass transfer     Œît          &lt;Int&gt; timestep of simulation in seconds     pieces<em>list &lt;Union{nothing, Vector{Floe}}&gt; list of floes created from floes                     breaking during ridging and rafting     pieces</em>idx  &lt;Int&gt; start index of pieces included in conservation                     calculations within the pieces_list Outputs:     Nothing. Update floes&#39; velocities and accelerations to conserve linear     momentum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/update_floe.jl#L276-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.deepcopy_floe-Union{Tuple{StructArrays.LazyRow{Floe{FT}}}, Tuple{FT}} where FT" href="#Subzero.deepcopy_floe-Union{Tuple{StructArrays.LazyRow{Floe{FT}}}, Tuple{FT}} where FT"><code>Subzero.deepcopy_floe</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deepcopy_floe(floe::LazyRow{Floe{FT}})</code></pre><p>Deepcopy of a floe by creating a new floe and copying all fields. Inputs:     floe    &lt;Floe&gt; Outputs:     New floe with floes that are equal in value. Any vector fields are copies so     they share values, but not referance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L110-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.deform_floe!-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Vararg{Any, 4}}} where FT" href="#Subzero.deform_floe!-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Vararg{Any, 4}}} where FT"><code>Subzero.deform_floe!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deform_floe!(
    floe,
    deformer_poly,
    deforming_forces,
)</code></pre><p>Deform a floe around the area of its collision with largest area overlap within the last timestep. Inputs:         floe                &lt;Floe&gt; floe to deform         deformer<em>coords     &lt;PolyVec&gt; coords of floe that is deforming floe                                 argument         deforming</em>forces    &lt;Vector{AbstractFloat}&gt; 1x2 matrix of forces between                                 floe and the deforming floe from floe&#39;s                                 interactions - of the form: [xforce yforce]  Outputs:         None. The input floe&#39;s centroid, coordinates, and area are updated to         reflect a deformation due to the collision with the deforming floe. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L290-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.determine_fractures-Tuple{Any, Subzero.AbstractFractureCriteria, Any}" href="#Subzero.determine_fractures-Tuple{Any, Subzero.AbstractFractureCriteria, Any}"><code>Subzero.determine_fractures</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">determine_fractures(
    floes,
    criteria,
    min_floe_area,
)</code></pre><p>Determines which floes will fracture depending on the principal stress criteria. Inputs:     floes           &lt;StructArray{Floe}&gt; model&#39;s list of floes     criteria        &lt;AbstractFractureCriteria&gt; fracture criteria     floe_settings   &lt;FloeSettings&gt; Floe settings. Contains Floe properties and stress                      calculator. Outputs:     &lt;Vector{Int}&gt; list of indices of floes to fracture </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L253-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.dissolve_floe!-Tuple{Any, RegRectilinearGrid, Any, Any}" href="#Subzero.dissolve_floe!-Tuple{Any, RegRectilinearGrid, Any, Any}"><code>Subzero.dissolve_floe!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dissolve_floe(floe, grid, dissolved)</code></pre><p>Dissolve given floe into dissolved ocean matrix. Inputs:     floe        &lt;Union{Floe, LazyRow{Floe}}&gt; single floe     grid        &lt;RegRectilinearGrid&gt; model&#39;s grid     domain      &lt;Domain&gt; model&#39;s domain     dissolved    &lt;Matrix{AbstractFloat}&gt; ocean&#39;s dissolved field Outputs:     None. Update dissolved matrix with given floe&#39;s mass and mark floe for     removal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/simplification.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.domain_in_grid-Tuple{Domain, AbstractGrid}" href="#Subzero.domain_in_grid-Tuple{Domain, AbstractGrid}"><code>Subzero.domain_in_grid</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">domain_in_grid(domain, grid)</code></pre><p>Checks if given rectangular domain is within given grid and gives user a warning if domain is not of maximum possible size given grid dimensions. Inputs:     domain      &lt;RectangularDomain&gt;     grid        &lt;AbstractGrid&gt; Outputs:     &lt;Boolean&gt; true if domain is within grid bounds, else false</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/model.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.euclidian_dist-Tuple{Any, Any, Any}" href="#Subzero.euclidian_dist-Tuple{Any, Any, Any}"><code>Subzero.euclidian_dist</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>euclidian_dist(c, idx2, idx1)</p><p>Calculate euclidean distance between two points within given coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L354-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.find_center_cell_index-Tuple{Any, Any, RegRectilinearGrid}" href="#Subzero.find_center_cell_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.find_center_cell_index</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_center_cell_index(xp, yp, grid::RegRectilinearGrid)</code></pre><p>Find index of the cell centered on grid lines of the given RegRectilinearGrid that the given x-coordinate and y-coordinate falls within. This cell is centered around the grid lines, so it is a shifted grid cell by half a cell. Method depends on grid being a regular rectilinear grid. Inputs:     xp      &lt;AbstractFloat&gt; x-coordinates of point     yp      &lt;AbstractFloat&gt; y-coordinate of point     grid    &lt;RegRectilinearGrid&gt; simulation grid Outputs:     xidx    &lt;AbstractFloat&gt; x-index of grid cell (cented on grid lines) x-point                 is within - this is the column     yidx    &lt;AbstractFloat&gt; y-index of grid cell (cented on grid lines) y-point                 is within - this is the row Note:     Points can be outside of the grid, so index can be less than 1 or greater     than the number of grid lines in a given direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L447-L465">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{East, FT}, PeriodicBoundary{West, FT}}} where FT&lt;:AbstractFloat" href="#Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{East, FT}, PeriodicBoundary{West, FT}}} where FT&lt;:AbstractFloat"><code>Subzero.find_ghosts!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_ghosts!(
    floes,
    elem_idx,
    ebound::PeriodicBoundary,
    wbound::PeriodicBoundary,
)</code></pre><p>Find ghosts of given element and its known ghosts through an eastern or western periodic boundary. If element&#39;s centroid isn&#39;t within the domain in the east/west direction, swap it with its ghost since the ghost&#39;s centroid must then be within the domain.  Inputs:     floes       &lt;StructArray{Floe}&gt; model&#39;s list of floes     elem_idx    &lt;Int&gt; floe of interest&#39;s index within the floe list     eboundary   &lt;PeriodicBoundary{East, Float}&gt; domain&#39;s eastern boundary     wboundary   &lt;PeriodicBoundary{West, Float}&gt; domain&#39;s western boundary Outputs:     None. Ghosts added to the floe list. Primary floe always has centroid within     the domain, else it is swapped with one of its ghost&#39;s which has a centroid     within the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L1086-L1107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{North, FT}, PeriodicBoundary{South, FT}}} where FT&lt;:AbstractFloat" href="#Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{North, FT}, PeriodicBoundary{South, FT}}} where FT&lt;:AbstractFloat"><code>Subzero.find_ghosts!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_ghosts!(
    floes,
    elem_idx,
    nbound::PeriodicBoundary{North, &lt;:AbstractFloat},
    sbound::PeriodicBoundary{South, &lt;:AbstractFloat},
)</code></pre><p>Find ghosts of given element and its known ghosts through an northern or southern periodic boundary. If element&#39;s centroid isn&#39;t within the domain in the north/south direction, swap it with its ghost since the ghost&#39;s centroid must then be within the domain.  Inputs:     floes       &lt;StructArray{Floe}&gt; model&#39;s list of floes     elem_idx    &lt;Int&gt; floe of interest&#39;s index within the floe list     nboundary        &lt;PeriodicBoundary{North, Float}&gt; domain&#39;s northern boundary     sboundary        &lt;PeriodicBoundary{South, Float}&gt; domain&#39;s southern boundary Outputs:     None. Ghosts added to the floe list. Primary floe always has centroid within     the domain, else it is swapped with one of its ghost&#39;s which has a centroid     within the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L1137-L1158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.find_grid_cell_index-Tuple{Any, Any, RegRectilinearGrid}" href="#Subzero.find_grid_cell_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.find_grid_cell_index</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_grid_cell_index(xp, yp, grid::RegRectilinearGrid)</code></pre><p>Find index of the grid cell of the given RegRectilinearGrid that the given x-coordinate and y-coordinate falls within. Method depends on grid being a regular rectilinear grid. Inputs:     xp      &lt;AbstractFloat&gt; x-coordinates of point     yp      &lt;AbstractFloat&gt; y-coordinate of point     grid    &lt;RegRectilinearGrid&gt; simulation grid Outputs:     xidx    &lt;AbstractFloat&gt; x-index of grid cell x-point is within - this is the                 column     yidx    &lt;AbstractFloat&gt; y-index of grid cell y-point is within - this is the                 row Note:     Points can be outside of the grid, so index can be less than 1 or greater     than the number of grid cells</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L422-L439">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, PeriodicBoundary}" href="#Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, PeriodicBoundary}"><code>Subzero.find_interp_knots</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_interp_knots(
    point_idx,
    ncells,
    L,
    Œîd::Int,
    ::PeriodicBoundary,
)</code></pre><p>Find indicies in list of grid lines that surround points with indicies &#39;point<em>idx&#39;, with a buffer of Œîd indices on each side of the points. In this case, the points are being considered near a periodic boundary, which means that they can loop around to the other side of the grid. If these points exist, we extend the grid lines to cover the points and buffer.  Inputs:     point</em>idx   &lt;Vector{Int}&gt; vector of point indices representing the grid line                     they are nearest     ncells      &lt;Int&gt; number of grid cells in given dimension     glines      &lt;Vector or Range&gt; grid line values     L           &lt;AbstractFloat&gt; length of grid in given dimension     Œîd          &lt;Int&gt; number of buffer grid cells to include on either side of                     the provided indicies                  &lt;PeriodicBoundary&gt; dispatching on periodic boundary Outputs:     knots       &lt;Vector{AbstractFloat}&gt; interpolation knots - grid line values     knot_idx    &lt;Vector{Int}&gt; - indices of grid line values within grid list of                     grid lines. Note:     The grid values are extended if points expand past gridlines, however, the     indices are within the grid. For example, consider a grid where the maximum     grid value is 1e5, with grid cells of length 1e4. One of the knot values     might be 1.1e5, however, its index would be 2 since the grid line at 1e5 is     equivalent to the first grid line since it is periodic, and 1.1e5 is one     grid cell length past that value.</p><pre><code class="nohighlight hljs">This function depends on the ocean being periodic in the given direction.
We assume that first grid line and the last grid line are the same, and have
the same values within the ocean/atmosphere. These are not repeated in the
knots, but rather only one is used. So if there are 10 grid lines, grid line
1 and 10 are the equivalent and we use grid line 1 exclusively.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L661-L701">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}" href="#Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.find_interp_knots</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_interp_knots(
    point_idx,
    ncells,
    L,
    Œîd::Int,
    ::NonPeriodicBoundary,
)</code></pre><p>Find indicies in list of grid lines that surround points with indicies &#39;point<em>idx&#39; with a buffer of Œîd indices on each side of the points. In this case, the points are being considered near a NON-periodic boundary, so we cut off the possible indices past the edge of the grid.  Inputs:     point</em>idx   &lt;Vector{Int}&gt; vector of indices representing the grid line they                     are nearest     ncells      &lt;Int&gt; number of grid cells in given dimension     glines      &lt;Vector or Range&gt; grid line values     L           &lt;AbstractFloat&gt; length of grid in given dimension     Œîd          &lt;Int&gt; number of buffer grid cells to include on either side of                     the provided indicies                  &lt;PeriodicBoundary&gt; dispatching on periodic boundary Outputs:     knots       &lt;Vector{AbstractFloat}&gt; interpolation knots - grid line values     knot_idx    &lt;Vector{Int}&gt; - indices of grid line values within grid list of                     grid lines. Note:     Only knots within the grid will be returned since this is a non-periodic     boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L749-L778">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.find_poly_coords-Tuple{Any}" href="#Subzero.find_poly_coords-Tuple{Any}"><code>Subzero.find_poly_coords</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_poly_coords(poly)</code></pre><p>Syntactic sugar for to find a polygon&#39;s coordinates Input:     poly    &lt;Polygon&gt; Output:     &lt;PolyVec&gt; representing the floe&#39;s coordinates xy plane</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L34-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.find_shared_edges_midpoint-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any}} where FT" href="#Subzero.find_shared_edges_midpoint-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any}} where FT"><code>Subzero.find_shared_edges_midpoint</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_shared_edges_midpoint(c1, c2)</code></pre><p>Find &quot;midpoint&quot; of shared polygon edges by distance Inputs:     c1      &lt;PolVec&gt; polygon coordinates for floe 1     c2      &lt;PolVec&gt; polygon coordinates for floe 2 Outputs:     mid<em>x   &lt;Float&gt; x-coordinate of midpoint     mid</em>y   &lt;Float&gt; y-coordinate of midpoint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L462-L472">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.floe_domain_element_interaction!-Tuple{Any, PeriodicBoundary, Vararg{Any, 4}}" href="#Subzero.floe_domain_element_interaction!-Tuple{Any, PeriodicBoundary, Vararg{Any, 4}}"><code>Subzero.floe_domain_element_interaction!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floe_domain_element_interaction!(
    floe,
    ::PeriodicBoundary,
    element_idx,
    consts,
    Œît,
)</code></pre><p>If a given floe intersects with a periodic boundary, nothing happens at this point. Periodic floes pass through boundaries using ghost floes. Inputs:         None are used.  Output:         None. This function does not do anyting. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L466-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Any, Union{CollisionBoundary, MovingBoundary, TopographyElement}, Any, Any, Any, FT}} where FT" href="#Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Any, Union{CollisionBoundary, MovingBoundary, TopographyElement}, Any, Any, Any, FT}} where FT"><code>Subzero.floe_domain_element_interaction!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floe_domain_element_interaction!(
    floe,
    element,
    element_idx,
    consts,
    Œît,
)</code></pre><p>If floe intersects with given element (either collision boundary or topography element), floe interactions field and overarea field are updated. Inputs:     floe            &lt;Floe&gt; floe interacting with element     element         &lt;Union{CollisionBoundary, TopographyElement}&gt; coordinates of                         element     consts          &lt;Constants&gt; model constants needed for calculations     Œît              &lt;Int&gt; current simulation timestep     max_overlap     &lt;Float&gt; Percent a floe can overlap with a collision wall                             or topography before being killed/removed Outputs:     None. If floe interacts, the floe&#39;s interactions field is updated with the     details of each region of overlap. The interactions field will have the     following form for each region of overlap with the element:     [Inf, xforce, yforce, xfpoints, yfpoints, overlaps] where the xforce and     yforce are the forces, xfpoints and yfpoints are the location of the force     and overlaps is the overlap between the floe and element. The overlaps field     is also added to the floe&#39;s overarea field that describes the total     overlapping area at any timestep.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L599-L627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, OpenBoundary, Vararg{Any, 4}}} where FT" href="#Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, OpenBoundary, Vararg{Any, 4}}} where FT"><code>Subzero.floe_domain_element_interaction!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floe_domain_element_interaction!(floe, boundary, _, _,)</code></pre><p>If given floe insersects with an open boundary, the floe is set to be removed from the simulation. Inputs:     floe            &lt;Floe&gt; floe interacting with boundary     boundary        &lt;OpenBoundary&gt; coordinates of boundary     _               &lt;Constants&gt; model constants needed in other methods of this                         function - not needed here     _               &lt;Int&gt; current simulation timestep - not needed here     -               &lt;Float&gt; maximum overlap between floe and domain elements -                         not needed here Output:     None. If floe is interacting with the boundary, floe&#39;s status is set to     remove. Else, nothing is changed. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L433-L449">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.floe_domain_interaction!-Union{Tuple{FT}, Tuple{Any, Domain, Any, Any, FT}} where FT&lt;:AbstractFloat" href="#Subzero.floe_domain_interaction!-Union{Tuple{FT}, Tuple{Any, Domain, Any, Any, FT}} where FT&lt;:AbstractFloat"><code>Subzero.floe_domain_interaction!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floe_domain_interaction!(
    floe,
    domain::DT,
    consts,
    max_overlap,
)</code></pre><p>If the floe interacts with the domain, update the floe accordingly. Dispatches on different boundary types within the domain. Inputs:     floe        &lt;Floe&gt; floe interacting with boundary     domain      &lt;Domain&gt; model domain     consts      &lt;Constants&gt; model constants needed for calculations     Œît          &lt;Int&gt; current simulation timestep     max_overlap &lt;Float&gt; Percent a floe can overlap with a collision wall                         or topography before being killed/removed Outputs:     None. Floe is updated according to which boundaries it interacts with and     the types of those boundaries. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L755-L775">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.floe_domain_raft!-Tuple{Any, Any, Union{StructArrays.LazyRow{&lt;:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}" href="#Subzero.floe_domain_raft!-Tuple{Any, Any, Union{StructArrays.LazyRow{&lt;:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}"><code>Subzero.floe_domain_raft!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floe_domain_raft!(
    floes,
    idx1,
    domain_element,
    pieces_buffer,
    max_floe_id,
    broken,
    ridgeraft_settings,
    floe_settings,
    simp_settings,
    Œît
    rng,
)</code></pre><p>Raft a floe against a boundary or a topography element and return any excess floes created by the rafting. This is equivalent to ridging. Inputs:     floes               &lt;StructArray{Floe}&gt; floe list     idx1                &lt;Int&gt; index of first floe     domain<em>element      &lt;AbstractDomainElement&gt; boundary or topography element     pieces</em>buffer       &lt;StructArray{Floe}&gt; list of new floe pieces caused by                             breakage of floes     max<em>floe</em>id         &lt;Int&gt; maximum floe ID before this ridging/rafting     broken              &lt;Vector{Bool}&gt; floe index is true if that floe has                             broken in a previous ridge/raft interaction     ridgeraft<em>settings  &lt;RidgeRaftSettings&gt; ridge/raft settings     floe</em>settings       &lt;FloeSettings&gt; simulation&#39;s settings for making floes     simp_settings       &lt;SimplificationSettings&gt; simplification settings     Œît                  &lt;Int&gt; simulation timestep in seconds     rng                 &lt;RandomNumberGenerator&gt; simulation&#39;s random number                             generator Outputs:     floe1 is updated with new shape. If any new floes are created by rafting     they are returned, else nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/ridge_raft.jl#L585-L620">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.floe_domain_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Union{StructArrays.LazyRow{&lt;:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}} where FT" href="#Subzero.floe_domain_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Union{StructArrays.LazyRow{&lt;:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}} where FT"><code>Subzero.floe_domain_ridge!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floe_domain_ridge!(
    floes,
    idx,
    domain_element,
    pieces_buffer,
    max_floe_id,
    broken,
    ridgeraft_settings,
    floe_settings,
    simp_settings,
    Œît,
    rng,
)</code></pre><p>Ridge a floe against a boundary or a topography element and return any excess floes created by the ridging. Inputs:     floes               &lt;StructArray{Floe}&gt; floe list     idx1                &lt;Int&gt; index of first floe     domain<em>element      &lt;AbstractDomainElement&gt; boundary or topography element     pieces</em>buffer       &lt;StructArray{Floe}&gt; list of new floe pieces caused by                             breakage of floes     max<em>floe</em>id         &lt;Int&gt; maximum floe ID before this ridging/rafting     broken              &lt;Vector{Bool}&gt; floe index is true if that floe has                             broken in a previous ridge/raft interaction     ridgeraft<em>settings  &lt;RidgeRaftSettings&gt; simulation&#39;s settings for ridge/raft     floe</em>settings       &lt;FloeSettings&gt; simulation&#39;s settings for making floes     simp_settings       &lt;SimplificationSettings&gt; simulation&#39;s settings for                             simplification     Œît                  &lt;Int&gt; simulation timestep in seconds     rng                 &lt;RandomNumberGenerator&gt; simulation&#39;s random number                             generator Outputs:     floe1 is updated with new shape. Return maximum floe id of floes created</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/ridge_raft.jl#L344-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.floe_floe_interaction!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat" href="#Subzero.floe_floe_interaction!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat"><code>Subzero.floe_floe_interaction!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floe_floe_interaction!(
    ifloe,
    i,
    jfloe,
    j,
    nfloes,
    consts,
    Œît,
)</code></pre><p>If the two floes interact, update floe i&#39;s interactions accordingly. Floe j is not update here so that the function can be parallelized. Inputs:     ifloe       &lt;Floe&gt; first floe in potential interaction     i           &lt;Int&gt; index of ifloe in model&#39;s list of floes      jfloe       &lt;Floe&gt; second floe in potential interaction     j           &lt;Int&gt; index of jfloe in model&#39;s list of floes      nfloes      &lt;Int&gt; number of non-ghost floes in the simulation this timestep     consts      &lt;Constants&gt; model constants needed for calculations     Œît          &lt;Int&gt; Simulation&#39;s current timestep     max<em>overlap &lt;Float&gt; Percent two floes can overlap before marking them                         for fusion Outputs:     None. Updates floes interactions fields. If floes overlap by more than     the max</em>overlap fraction, they will be marked for fusion. Note:     If ifloe interacts with jfloe, only ifloe&#39;s interactions field is updated     with the details of each region of overlap. The interactions field will have     the following form for each region of overlap with the boundary:     [Inf, xforce, yforce, xfpoints, yfpoints, overlaps] where the xforce and     yforce are the forces, xfpoints and yfpoints are the location of the force     and overlaps is the overlap between the floe and boundary. The overlaps     field is also added to the floe&#39;s overarea field that describes the total     overlapping area at any timestep. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L334-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.floe_floe_raft!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT" href="#Subzero.floe_floe_raft!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT"><code>Subzero.floe_floe_raft!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floe_floe_raft!(
    floes,
    idx1,
    idx2,
    pieces_buffer,
    max_floe_id,
    broken,
    ridgeraft_settings,
    floe_settings,
    simp_settings,
    Œît,
    rng,
)</code></pre><p>Raft two floes, updating both in-place and returning any new floes that resulting from the rafting event. Inputs:     floes               &lt;StructArray{Floe}&gt; floe list     idx1                &lt;Int&gt; index of first floe     idx2                &lt;Int&gt; index of second floe     pieces<em>buffer       &lt;StructArray{Floe}&gt; list of new floe pieces caused by                             breakage of floes     max</em>floe<em>id         &lt;Int&gt; maximum floe ID before this ridging/rafting     broken              &lt;Vector{Bool}&gt; floe index is true if that floe has                             broken in a previous ridge/raft interaction     ridgeraft</em>settings  &lt;RidgeRaftSettings&gt; simulation&#39;s ridge/raft settings     floe<em>settings       &lt;FloeSettings&gt; simultion&#39;s settings for making floes     simp</em>settings       &lt;SimplificationSettings&gt; simulation&#39;s simplification                             settings     Œît                  &lt;Int&gt; simulation timestep in seconds     rng                 &lt;RandomNumberGenerator&gt; simulation&#39;s random number                             generator Outputs:     Updates floe1 and floe2 and returns any new floes created by rafting</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/ridge_raft.jl#L461-L496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.floe_floe_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT" href="#Subzero.floe_floe_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT"><code>Subzero.floe_floe_ridge!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floe_floe_ridge!(
    floes,
    idx1,
    idx2,
    floe2,
    overlap_area,
    ridgeraft_settings,
    simp_settings,
    Œît,
    rng
)</code></pre><p>Ridge two floes, updating both in-place and returning any new floes that resulting from the ridging event. Inputs:     floes               &lt;StructArray{Floe}&gt; floe list     idx1                &lt;Int&gt; index of first floe     idx2                &lt;Int&gt; index of second floe     pieces<em>buffer       &lt;StructArray{Floe}&gt; list of new floe pieces caused by                             breakage of floes     max</em>floe<em>id         &lt;Int&gt; maximum floe ID before this ridging/rafting     broken              &lt;Vector{Bool}&gt; floe index is true if that floe has                             broken in a previous ridge/raft interaction     ridgeraft</em>settings  &lt;RidgeRaftSettings&gt; simulation&#39;s settings for ridging                             and rafting     floe<em>settings       &lt;FloeSettings&gt; simulation&#39;s settings for making floes     simp</em>settings       &lt;SimplificationSettings&gt; simulation&#39;s simplification                             settings     Œît                  &lt;Int&gt; simulation timestep in seconds     rng                 &lt;RandomNumberGenerator&gt; simulation&#39;s random number                             generator Outputs:     Updates floe1 and floe2 and returns any new floes created by ridging</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/ridge_raft.jl#L199-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.floe_to_grid_info!-Union{Tuple{FT}, Tuple{Any, Any, Any, FT, FT, Vararg{Any, 5}}} where FT" href="#Subzero.floe_to_grid_info!-Union{Tuple{FT}, Tuple{Any, Any, Any, FT, FT, Vararg{Any, 5}}} where FT"><code>Subzero.floe_to_grid_info!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floe_to_grid_info!(
    floeidx,
    xidx,
    yidx,
    œÑx_ocn::FT,
    œÑy_ocn::FT,
    grid,
    domain,
    scells,
)</code></pre><p>Add force from the ice on ocean to ocean force fields (fx &amp; fy) for each grid cell and update ocean sea ice area fraction (si<em>area), representing total area of sea ice in a given cell. Function is called for each monte carlo point. Inputs:     floeidx             &lt;Int&gt; index of floe within model&#39;s floe array     xidx                &lt;Int&gt; grid x index that floe&#39;s point is within for grid                             centered on grid lines     yidx                &lt;Int&gt; grid column that floe&#39;s point is within for grid                             centered on grid lines     œÑx</em>ocn              &lt;AbstractFloat&gt; x-stress caused by ocean on point     œÑy<em>ocn              &lt;AbstractFloat&gt; y-stress caused by ocean on point     grid                &lt;AbstractGrid&gt; model&#39;s grid     domain              &lt;Domain&gt; model&#39;s domain     cell</em>floes          &lt;Matrix{CellFloes}&gt; matrix of CellFloes, one for each                             grid cell     scells              &lt;Matrix{IceStressCell}&gt; matrix of IceStressCells, one                             for each grid cell     coupling_settings   &lt;CouplingSettings&gt; simulation&#39;s coupling settings</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L1386-L1416">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.fracture_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat" href="#Subzero.fracture_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat"><code>Subzero.fracture_floes!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fracture_floes!(
    floes,
    max_floe_id,
    rng,
    fracture_settings,
    floe_settings,
    Œît,
)</code></pre><p>Fractures floes that meet the criteria defined in the fracture settings. Inputs:     floes       &lt;StructArray{Floe}&gt; model&#39;s list of floes     max<em>floe</em>id &lt;Int&gt; maximum ID of any floe created so far in simulation     rng         &lt;RNG&gt; random number generator     fracture<em>settings   &lt;FractureSettings&gt; sim&#39;s fracture settings     floe</em>settings       &lt;FloeSettings&gt; sim&#39;s settings to make floes     Œîtout               &lt;Int&gt; length of simulation timestep in seconds Outputs:     max<em>floe</em>id &lt;Int&gt; new highest floe ID after adding new floes to floe array.     Floe pieces added to floe array and original fractured floes removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L440-L460">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.fuse_floes!-NTuple{5, Any}" href="#Subzero.fuse_floes!-NTuple{5, Any}"><code>Subzero.fuse_floes!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fuse_floes!(
    floes,
    max_floe_id,
    floe_settings,
    Œît,
    rng,
)</code></pre><p>Fuse all floes marked for fusion. Inputs:     floes               &lt;StructArray{Floe}&gt; model&#39;s floes     max<em>floe</em>id         &lt;Int&gt; maximum floe ID created yet     floe_settings       &lt;FloeSettings&gt;  simulation&#39;s settings for making floes     Œît                  &lt;Int&gt; simulation timestep in seconds     rng                 &lt;RNG&gt; random number generator Outputs:     None. Fuses floes marked for fusion. Marks floes fused into another floe     for removal. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/simplification.jl#L206-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.fuse_two_floes!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 5}}} where FT" href="#Subzero.fuse_two_floes!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 5}}} where FT"><code>Subzero.fuse_two_floes!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fuse_two_floes!(
    keep_floe,
    remove_floe,
    Œît,
    floe_settings,
    max_floe_id,
    rng,
)</code></pre><p>Fuses two floes together if they intersect and replaces the larger of the two floes with their union. Mass and momentum are conserved. Inputs:     keep<em>floe           &lt;Union{Floe, LazyRow{Floe}}&gt; first floe     remove</em>floe         &lt;Union{Floe, LazyRow{Floe}}&gt; second floe     floe<em>settings       &lt;FloeSettings&gt; simulation&#39;s settings to make new floes     prefuse</em>max<em>floe</em>id &lt;Int&gt; maximum floe ID used yet in simulation     rng                 &lt;RNG&gt; random number generator Outputs:     If floes are not intersecting, no changes. If intersecing, the fused floe     replaces the larger of the two floes and the smaller floe is marked for     removal.     Note that the smaller floe&#39;s ID is NOT updated!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/simplification.jl#L123-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{MonteCarloPointsGenerator{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat" href="#Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{MonteCarloPointsGenerator{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat"><code>Subzero.generate_subfloe_points</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_subfloe_points(
    point_generator
    poly,
    centroid,
    area,
    status,
    rng
)</code></pre><p>Generate monte carlo points centered on the origin within the floe according to parameters defined in the point<em>generator argument. Inputs:     point</em>generator     &lt;MonteCarloPointsGenerator&gt; monte carlo point generator     poly                &lt;Polygon&gt; Polygon representing floe shape     centroid            &lt;Matrix&gt; floe&#39;s centroid     area                &lt;AbstractFloat&gt; floe&#39;s area     status              &lt;Status&gt; floe status (i.e. active, fuse in simulation)     rng                 &lt;AbstractRNG&gt; random number generator to generate monte                             carlo points Ouputs:     x<em>sub</em>floe  &lt;Vector{FT}&gt; vector of sub-floe grid points x-coords within floe     y<em>sub</em>floe  &lt;Vector{FT}&gt; vector of sub-floe grid points y-coords within floe     status      &lt;Status&gt; floe&#39;s status post generation, changed to remove if                      generation is unsuccessful</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L146-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{SubGridPointsGenerator{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat" href="#Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{SubGridPointsGenerator{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat"><code>Subzero.generate_subfloe_points</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_subfloe_points(
    point_generator,
    poly,
    centroid,
    area,
    status,
    rng
)</code></pre><p>Generate evenly spaced points within given floe coordinates to be used for coupling. If only one point falls within the floe, return the floe&#39;s centroid. Inputs:     point<em>generator     &lt;SubGridPointsGenerator&gt; sub-grid point generator     poly                &lt;Polygon&gt; Polygon representing floe shape     centroid            &lt;Matrix&gt; floe&#39;s centroid     area                &lt;AbstractFloat&gt; floe&#39;s area     status              &lt;Status&gt; floe status (i.e. active, fuse in simulation)     rng                 &lt;AbstractRNG&gt; random number generator is not used in                             this generation method Ouputs:     x</em>sub<em>floe  &lt;Vector{FT}&gt; vector of sub-floe grid points x-coords within floe     y</em>sub_floe  &lt;Vector{FT}&gt; vector of sub-floe grid points y-coords within floe     status      &lt;Status&gt; tag isn&#39;t changed with this generation method</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L210-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.generate_voronoi_coords-Union{Tuple{FT}, Tuple{Int64, Any, Any, Vector{&lt;:Array{Array{Vector{var&quot;#s81&quot;}, 1}, 1} where var&quot;#s81&quot;&lt;:FT}, Any, Int64}} where FT&lt;:AbstractFloat" href="#Subzero.generate_voronoi_coords-Union{Tuple{FT}, Tuple{Int64, Any, Any, Vector{&lt;:Array{Array{Vector{var&quot;#s81&quot;}, 1}, 1} where var&quot;#s81&quot;&lt;:FT}, Any, Int64}} where FT&lt;:AbstractFloat"><code>Subzero.generate_voronoi_coords</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_voronoi_coords(
    desired_points,
    scale_fac,
    trans_vec,
    domain_coords,
    rng;
    max_tries = 10,
)</code></pre><p>Generate voronoi coords within a bounding box defined by its lower left corner and its height and width. Attempt to generate <code>npieces</code> cells within the box. Inputs:     desired<em>points  &lt;Int&gt; desired number of voronoi cells     scale</em>fac       &lt;Vector{AbstractFloat}&gt; width and height of bounding box -                         formatted as [w, h]      trans<em>vec       &lt;Vector{AbstractFloat}&gt; lower left corner of bounding box -                         formatted as [x, y]      domain</em>coords   &lt;Vector{PolyVec{AbstractFloat}}&gt; multipolygon that will                         eventually be filled with/intersected with the voronoi                         cells - such as topography     rng             &lt;RNG&gt; random number generator to generate voronoi cells     min<em>to</em>warn     &lt;Int&gt; minimum number of points to warn if not generated to                         seed voronoi     max<em>tries       &lt;Int&gt; number of tires to generate desired number of points                         within domain</em>coords to seed voronoi cell creation Outputs:     coords  &lt;Vector{PolyVec{Float}}&gt; vector of polygon coordinates generated by         voronoi tesselation. These polygons all fall within the space defined by         the domain<em>coords. If less polygons than min</em>to_warn are generated, the         user will be warned. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L413-L444">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.get_known_grid_outputs-Tuple{}" href="#Subzero.get_known_grid_outputs-Tuple{}"><code>Subzero.get_known_grid_outputs</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_known_grid_outputs()</code></pre><p>Returns list of symbols that represent calculations available in calc<em>eularian</em>grid to average floe data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L269-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.get_velocity-Union{Tuple{FT}, Tuple{Subzero.AbstractDomainElement{FT}, Any, Any}} where FT" href="#Subzero.get_velocity-Union{Tuple{FT}, Tuple{Subzero.AbstractDomainElement{FT}, Any, Any}} where FT"><code>Subzero.get_velocity</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_velocity(
    element::AbstractDomainElement{FT},
    x,
    y,
)</code></pre><p>Get velocity, which is 0m/s by default, of a point on topography element or boundary. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L216-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.get_velocity-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, FT, FT}} where FT" href="#Subzero.get_velocity-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, FT, FT}} where FT"><code>Subzero.get_velocity</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_velocity(
    floe,
    x,
    y,
)</code></pre><p>Get velocity of a point, assumed to be on given floe. Inputs:     floe &lt;Union{LazyRow{Floe}, Floe}&gt; floe     x    &lt;AbstractFloat&gt; x-coordinate of point to find velocity at     y    &lt;AbstractFloat&gt; y-coordinate of point to find velocity at Outputs:     u   &lt;AbstractFloat&gt; u velocity at point (x, y) assuming it is on given floe     v   &lt;AbstractFloat&gt; v velocity at point (x, y) assuming it is on given floe</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L190-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.getattrs-Tuple{Symbol}" href="#Subzero.getattrs-Tuple{Symbol}"><code>Subzero.getattrs</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getattrs(output::FloeOutput)</code></pre><p>Returns unit and comment attributes for each output type to be saved within output NetCDF file Input:     output&lt;FloeOutput&gt; Output:     &lt;Tuple(String, String)&gt; tuple of string units and comments to be saved to     output NetCDF file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L922-L932">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.ghosts_on_bounds!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}" href="#Subzero.ghosts_on_bounds!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}"><code>Subzero.ghosts_on_bounds!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ghosts_on_bounds(element, ghosts, boundary, trans_vec)</code></pre><p>If the given element intersects with the boundary, add ghosts of the element and  any of its existing ghosts.  Inputs:     floes       &lt;StructArray{Floe}&gt; model&#39;s list of floes     elem<em>idx    &lt;Int&gt; floe of interest&#39;s index within the floe list     boundary    &lt;PeriodicBoundary&gt; boundary to translate element through     trans</em>vec   &lt;Matrix{Float}&gt; 1x2 matrix of form [x y] to translate element                     through the boundary Outputs:     Nothing. New ghosts created by the given element, or its current ghosts,     are added to the floe list</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L1049-L1063">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.grid_cell_index-Tuple{Any, Any, Any}" href="#Subzero.grid_cell_index-Tuple{Any, Any, Any}"><code>Subzero.grid_cell_index</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grid_cell_index(p, Œîg, g0)</code></pre><p>Find the index of given point&#39;s cartesian value (in either the x or y direction) within the simulation grid.  Inputs:     p       &lt;Real&gt; point&#39;s cartesian value in either x or y direction     Œîg      &lt;Real&gt; simulation grid&#39;s cell width or height     g0      &lt;Real&gt; simulation grid&#39;s first grid line value in either x or y                         direction Output:     Point&#39;s grid cell index within the simulation grid, as specified by the grid     cell dimension and grid line starting value, in either the x or y direction</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L325-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.grid_line_index-Tuple{Any, Any, Any}" href="#Subzero.grid_line_index-Tuple{Any, Any, Any}"><code>Subzero.grid_line_index</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grid_line_index(p, Œîg, g0)</code></pre><p>Find the index of given point&#39;s cartesian value (in either the x or y direction) within grid with cells centered on simulation grid&#39;s grid lines. Thus these cells are shifted from simulation&#39;s grid cells by half of a grid cell to the left.   Inputs:     p       &lt;Real&gt; point&#39;s cartesian value in either x or y direction     Œîg      &lt;Real&gt; grid&#39;s cell width or height     g0      &lt;Real&gt; grid&#39;s first grid line value in either x or y direction Output:     Point&#39;s grid cell index within the shifted simulation grid, as specified by     the grid cell dimension and grid line starting value, in either the x or y     direction</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L341-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.grid_xc_index-Tuple{Any, Any, RegRectilinearGrid}" href="#Subzero.grid_xc_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.grid_xc_index</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grid_xc_index(xp, yp, grid::RegRectilinearGrid)</code></pre><p>Find indices of given cartesian point within simulation&#39;s xc-grid. Inputs:     xp      &lt;Real&gt; point&#39;s x-cartesian value     yp      &lt;Real&gt; point&#39;s y-cartesian value     grid    &lt;RegRectilinearGrid&gt; simulation&#39;s grid Outputs:     x index and y indices within xc-grid Note:      This is equivalent fo the yc-grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L389-L401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.grid_xg_index-Tuple{Any, Any, RegRectilinearGrid}" href="#Subzero.grid_xg_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.grid_xg_index</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grid_xg_index(xp, yp, grid::RegRectilinearGrid)</code></pre><p>Find indices of given cartesian point within simulation&#39;s xg-grid. Inputs:     xp      &lt;Real&gt; point&#39;s x-cartesian value     yp      &lt;Real&gt; point&#39;s y-cartesian value     grid    &lt;RegRectilinearGrid&gt; simulation&#39;s grid Outputs:     x index and y indices within xg-grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L359-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.grid_yc_index-Tuple{Any, Any, RegRectilinearGrid}" href="#Subzero.grid_yc_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.grid_yc_index</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grid_yc_index(xp, yp, grid::RegRectilinearGrid)</code></pre><p>Find indices of given cartesian point within simulation&#39;s yc-grid. Inputs:     xp      &lt;Real&gt; point&#39;s x-cartesian value     yp      &lt;Real&gt; point&#39;s y-cartesian value     grid    &lt;RegRectilinearGrid&gt; simulation&#39;s grid Outputs:     x index and y indices within yc-grid Note:      This is equivalent fo the xc-grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L406-L418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.grid_yg_index-Tuple{Any, Any, RegRectilinearGrid}" href="#Subzero.grid_yg_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.grid_yg_index</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grid_yg_index(xp, yp, grid::RegRectilinearGrid)</code></pre><p>Find indices of given cartesian point within simulation&#39;s yg-grid. Inputs:     xp      &lt;Real&gt; point&#39;s x-cartesian value     yp      &lt;Real&gt; point&#39;s y-cartesian value     grid    &lt;RegRectilinearGrid&gt; simulation&#39;s grid Outputs:     x index and y indices within yg-grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L374-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.grids_from_lines-Tuple{Any, Any}" href="#Subzero.grids_from_lines-Tuple{Any, Any}"><code>Subzero.grids_from_lines</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>grids<em>from</em>lines(xlines, ylines)</p><p>Creates x-grid and y-grid. Assume xlines has length n and ylines has length m. xgrid is the grid&#39;s xline vector repeated m times as rows in a mxn array and ygrid is the yline vector repeated n times as columns in a mxn vector. xlines and ylines are typically either xg and yg or xc and yc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L767-L774">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.hashole-Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat}" href="#Subzero.hashole-Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat}"><code>Subzero.hashole</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hashole(poly::Polys)</code></pre><p>Determine if polygon has one or more holes Inputs:     poly &lt;Polygon&gt; polygon Outputs:     &lt;Bool&gt; true if there is a hole in the polygons, else false</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L236-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.hashole-Union{Tuple{Array{Array{Vector{FT}, 1}, 1}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.hashole-Union{Tuple{Array{Array{Vector{FT}, 1}, 1}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.hashole</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hashole(coords::PolyVec{FT})</code></pre><p>Determine if polygon coordinates have one or more holes Inputs:     coords &lt;PolyVec{Float}&gt; Outputs:     &lt;Bool&gt;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L223-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, PeriodicBoundary}" href="#Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, PeriodicBoundary}"><code>Subzero.in_bounds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function in_bounds(
    xr,
    yr,
    grid,
    ::PeriodicBoundary,
    ::PeriodicBoundary,
)</code></pre><p>With all periodic boundaries, all points are considered to be in-bounds. Inputs:     xr  &lt;AbstractFloat&gt; point x-coordinate     yr  &lt;AbstractFloat&gt; point y-coordinate         &lt;::PeriodicBoundary&gt; type of either north or south boundary -             checking if periodic pair         &lt;::PeriodicBoundary&gt; type of either east or west boundary -             checking if periodic pair Output:     Boolean that is true regardless of point values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L569-L588">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}" href="#Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.in_bounds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function in_bounds(
    xr,
    yr,
    grid,
    ::PeriodicBoundary,
    ::NonPeriodicBoundary,
)</code></pre><p>With the east/west non-periodic boundaries, points outside of the grid in the x-direction are defined to be out of bounds since these points can&#39;t be interpolated as we don&#39;t have any information on the ocean outside of the grid. Inputs:     xr  &lt;AbstractFloat&gt; point x-coordinate     yr  &lt;AbstractFloat&gt; point y-coordinate         &lt;::PeriodicBoundary&gt; type of either north or south boundary -             checking if periodic pair         &lt;::NonPeriodicBoundary&gt; type of either east or west boundary -             checking if periodic pair Output:     Boolean that is true if xr is within domain boundaries, and false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L537-L558">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}" href="#Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}"><code>Subzero.in_bounds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function in_bounds(
    xr,
    yr,
    grid,
    ::NonPeriodicBoundary,
    ::PeriodicBoundary,
)</code></pre><p>With the north/south non-periodic boundaries, points outside of the grid in the y-direction are defined to be out of bounds since these points can&#39;t be interpolated as we don&#39;t have any information on the ocean outside of the grid. Inputs:     xr  &lt;AbstractFloat&gt; point x-coordinate     yr  &lt;AbstractFloat&gt; point y-coordinate         &lt;::NonPeriodicBoundary&gt; type of either north or south boundary -             checking if periodic pair         &lt;::PeriodicBoundary&gt; type of either east or west boundary -             checking if periodic pair Output:     Boolean that is true if yr is within domain boundaries, and false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L505-L526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}" href="#Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.in_bounds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">in_bounds(
    xr,
    yr,
    grid,
    ::NonPeriodicBoundary,
    ::NonPeriodicBoundary,
)</code></pre><p>With all non-periodic boundaries, points outside of the grid in both the x and y are defined to be out of bounds since these points can&#39;t be interpolated as we don&#39;t have any information on the ocean outside of the grid. Inputs:     xr  &lt;AbstractFloat&gt; point x-coordinate     yr  &lt;AbstractFloat&gt; point y-coordinate         &lt;::NonPeriodicBoundary&gt; type of either north or south boundary -             checking if periodic pair         &lt;::NonPeriodicBoundary&gt; type of either east or west boundary -             checking if periodic pair Output:     Boolean that is true if both xr and yr are within domain boundaries, and     false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L471-L493">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.initialize_floe_field-Tuple" href="#Subzero.initialize_floe_field-Tuple"><code>Subzero.initialize_floe_field</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_floe_field(args...)</code></pre><p>A float type FT can be provided as the first argument of the initialize<em>floe</em>field constructor. A field of floes of type FT will be created by passing all other arguments to the correct method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L314-L320">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT" href="#Subzero.initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT"><code>Subzero.initialize_floe_field</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_floe_field(args...)</code></pre><p>If a type isn&#39;t specified, the field of Floes will each be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L324-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.initialize_jld2_file!-NTuple{5, Any}" href="#Subzero.initialize_jld2_file!-NTuple{5, Any}"><code>Subzero.initialize_jld2_file!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_jld2_file!(dir, filename, overwrite, outputs, jld2_kw)</code></pre><p>Initializes a JLD2 file in the given directory with the given filename. Setup file to write given outputs. Inputs:     dir         &lt;String&gt; path to directory     filename    &lt;String&gt; filename to save file to     overwrite   &lt;Bool&gt; if true, exit file of the same name will be deleted, else                     an error will be thrown if other file exists     outputs     &lt;Vector{Symbol}&gt; list of symbols to save as a group within the                     file     jld2_kw     list of JLD2 keywords for the jldopen function Outputs:     Create JLD2 file dir/filename where each output is a group within the file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L608-L623">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.initialize_netcdf_file!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 6}}} where FT" href="#Subzero.initialize_netcdf_file!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 6}}} where FT"><code>Subzero.initialize_netcdf_file!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function initialize_netcdf_file!(
    ::Type{FT},
    dir,
    filename,
    overwrite,
    outputs,
    xg,
    yg,
)</code></pre><p>Initializes a NetCDF file in the given directory with the given filename. Setup file to write given outputs. Inputs:     Type{FT}    &lt;Type{AbstractFloat}&gt; type of float to run simulation                     calculations using     dir         &lt;String&gt; path to directory     filename    &lt;String&gt; filename to save file to     overwrite   &lt;Bool&gt; if true, exit file of the same name will be deleted, else                     an error will be thrown if other file exists     outputs     &lt;Vector{Symbol}&gt; list of symbols to save as a group within the                     file     xg          &lt;Vector{AbstractFloat}&gt; list of x grid lines     yg          &lt;Vector{AbstractFloat}&gt; list of y grid lines Outputs:     Create NetCDF file dir/filename with each output added as a variable and     with the dimensions time, x, and y. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L653-L680">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.initialize_topography_field-Tuple" href="#Subzero.initialize_topography_field-Tuple"><code>Subzero.initialize_topography_field</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_topography_field(args...)</code></pre><p>If a type isn&#39;t specified, the list of TopographyElements will each be of type Float64 and the correct constructor will be called with all other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L513-L518">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.initialize_topography_field-Union{Tuple{FT}, Tuple{Type{FT}, Any}} where FT&lt;:AbstractFloat" href="#Subzero.initialize_topography_field-Union{Tuple{FT}, Tuple{Type{FT}, Any}} where FT&lt;:AbstractFloat"><code>Subzero.initialize_topography_field</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_topography_field(
    ::Type{FT},
    coords,
)</code></pre><p>Create a field of topography from a list of polygon coordiantes. Inputs:     Type{FT}        &lt;AbstractFloat&gt; Type for grid&#39;s numberical fields -                         determines simulation run type     coords          &lt;Vector{PolyVec}&gt; list of polygon coords to make into floes Outputs:     topo_arr &lt;StructArray{TopographyElement}&gt; list of topography elements     created from given polygon coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L522-L536">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.intersect_polys-Union{Tuple{FT}, Tuple{Any, Any}, Tuple{Any, Any, Type{FT}}} where FT" href="#Subzero.intersect_polys-Union{Tuple{FT}, Tuple{Any, Any}, Tuple{Any, Any, Type{FT}}} where FT"><code>Subzero.intersect_polys</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersect_polys(p1, p2)</code></pre><p>Intersect two geometries and return a list of polygons resulting. Inputs:     p1  &lt;AbstractGeometry&gt;     p2  &lt;AbstractGeometry&gt; Output:     Vector of Polygons</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L45-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.level_to_string-Tuple{Any}" href="#Subzero.level_to_string-Tuple{Any}"><code>Subzero.level_to_string</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">level_to_string(level)</code></pre><p>Returns string with log event name given log event level</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/logger.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.mc_interpolation-NTuple{7, Any}" href="#Subzero.mc_interpolation-NTuple{7, Any}"><code>Subzero.mc_interpolation</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mc_interpolation(
    mc_cart,
    mc_grid_idx,
    grid,
    domain,
    atmos,
    ocean,
    coupling_settings,
)</code></pre><p>Create and returns interpolation objects for atmosphere u and v velocities, and ocean u and v velocities, in addition to ocean&#39;s heatflux factor. Inputs:     npoints             &lt;Int&gt; number of monte carlo points to consider - the                             number of rows to use in mc<em>cart and mc</em>grid<em>idx     mc</em>cart             &lt;Matrix{AbstractFloat}&gt; cartesian coordinates for model                             coordinates - nx2 matrix of monte carlo coordinates                             where first column is the x-coords and the second                             column is the y-coords     mc<em>grid</em>idx         &lt;Matrix{Int}&gt; index of monte carlo points within the                             grid - nx2 matrix of indices where the first column                             is the grid column index and the second column is                             the grid row index for cells centered on grid lines     grid                &lt;AbstractGrid&gt; model grid     domain              &lt;Domain&gt; model domain     atmos               &lt;Atmos&gt; model atmosphere     ocean               &lt;Ocean&gt; model ocean     coupling<em>settings   &lt;CouplingSettings&gt; simulation&#39;s coupling settings Outputs:     uatm</em>interp &lt;Interplations object&gt; linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the atompshere u velocity onto point     vatm<em>interp &lt;Interplations object&gt; linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the atompshere v velocity onto point     uocn</em>interp &lt;Interplations object&gt; linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the ocean u velocity onto point     vocn<em>interp &lt;Interplations object&gt; linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the ocean v velocity onto point     hflx</em>interp &lt;Interplations object&gt; linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the ocean heatflux factor velocity onto point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L799-L844">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.normal_direction_correct!-Tuple{Any, Any, TopographyElement}" href="#Subzero.normal_direction_correct!-Tuple{Any, Any, TopographyElement}"><code>Subzero.normal_direction_correct!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normal_direction_correct!(
    forces,
    fpoints,
    ::TopographyElement,
)</code></pre><p>No forces should be zero-ed out in collidions with topography elements.  Inputs:         None used. Outputs:         None.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L578-L590">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{East, &lt;:AbstractFloat}}} where FT" href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{East, &lt;:AbstractFloat}}} where FT"><code>Subzero.normal_direction_correct!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normal_direction_correct!(
    forces,
    fpoints,
    boundary::AbstractBoundary{East, &lt;:AbstractFloat},
)</code></pre><p>Zero-out forces that point in direction not perpendicular to East boundary wall. See normal<em>direction</em>correct! on northern wall for more information</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L540-L549">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{North, &lt;:AbstractFloat}}} where FT" href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{North, &lt;:AbstractFloat}}} where FT"><code>Subzero.normal_direction_correct!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normal_direction_correct!(
    forces,
    fpoints,
    boundary::AbstractBoundary{North, &lt;:AbstractFloat},
)</code></pre><p>Zero-out forces that point in direction not perpendicular to North boundary wall. Inputs:     force       &lt;Array{Float, n, 2}&gt; normal forces on each of the n regions                     greater than a minimum area     fpoint      &lt;Array{Float, n, 2}&gt; point force is applied on each of the n                     regions greater than a minimum area     boundary    &lt;AbstractBoundary{North, &lt;:AbstractFloat}&gt; domain&#39;s northern                     boundary Outputs:     None. All forces in the x direction set to 0 if the point the force is     applied to is in the northern boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L493-L511">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{South, &lt;:AbstractFloat}}} where FT" href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{South, &lt;:AbstractFloat}}} where FT"><code>Subzero.normal_direction_correct!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normal_direction_correct!(
    forces,
    fpoints,
    boundary::AbstractBoundary{South, &lt;:AbstractFloat},
)</code></pre><p>Zero-out forces that point in direction not perpendicular to South boundary wall. See normal<em>direction</em>correct! on northern wall for more information</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L521-L530">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{West, &lt;:AbstractFloat}}} where FT" href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{West, &lt;:AbstractFloat}}} where FT"><code>Subzero.normal_direction_correct!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normal_direction_correct!(
    forces,
    fpoints,
    boundary::AbstractBoundary{&lt;:AbstractFloat, West},
)</code></pre><p>Zero-out forces that point in direction not perpendicular to West boundary wall. See normal<em>direction</em>correct! on northern wall for more information</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L559-L568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.periodic_compat-Tuple{PeriodicBoundary, PeriodicBoundary}" href="#Subzero.periodic_compat-Tuple{PeriodicBoundary, PeriodicBoundary}"><code>Subzero.periodic_compat</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">periodic_compat(b1, b2)</code></pre><p>Checks if two boundaries are compatible as a periodic pair. This is true if they are both periodic, or if neither are periodic. Otherwise, it is false. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/domain_and_grid.jl#L549-L554">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.plot_conservation-NTuple{7, Any}" href="#Subzero.plot_conservation-NTuple{7, Any}"><code>Subzero.plot_conservation</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_conservation(
    linear_energy,
    rotational_energy,
    linear_x_momentum,
    linear_y_momentum,
    angular_spin_momentum,
    angular_orbital_momentum,
    dir,
)</code></pre><p>Takes in vectors of energy and momentum at each simulation timestep and plots conservation over time. Plots are saved to given directory. Also prints total change in both kinetic energy and momentum from beginning to end of simulation to terminal.  Inputs:     linear<em>energy               &lt;Vector{Real}&gt; list of total energy from x and y                                     motion per timestep     rotational</em>energy           &lt;Vector{Real}&gt; list of total energy from                                     rotational motion per timestep     linear<em>x</em>momentum           &lt;Vector{Real}&gt; list of total momentum from x                                     motion per timestep     linear<em>y</em>momentum           &lt;Vector{Real}&gt; list of total momentum from y                                     motion per timestep     angular<em>spin</em>momentum       &lt;Vector{Real}&gt; list of total momentum from floes                                     spinning around their own center of masses                                     per timestep     angular<em>orbital</em>momentum    &lt;Vector{Real}&gt; list of total momentum from floes                                     spinning around origin per timestep     dir                         &lt;String&gt; directory to save images to Outputs:     Œîenergy          &lt;Float&gt; % change in energy from first to last timestep     Œîxmomentum       &lt;Float&gt; % change in x momentum from first to last timestep     Œîymomentum       &lt;Float&gt; % change in y momentum from first to last timestep     Œîangularmomentum &lt;Float&gt; % change in angular momentum from first to last                         timestep     Also saves energy and momentum plots over time to given directory</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/tools/conservation_em.jl#L69-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.poly_to_floes!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat" href="#Subzero.poly_to_floes!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat"><code>Subzero.poly_to_floes!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">poly_to_floes!(
    ::Type{FT},
    floes,
    poly,
    hmean,
    Œîh,
    rmax;
    floe_settings,
    rng = Xoshiro(),
    kwargs...
)</code></pre><p>Split a given polygon around any holes before turning each region with an area greater than the minimum floe area into a floe. Inputs:     Type{FT}            &lt;AbstractFloat&gt; Type for grid&#39;s numberical fields -                         determines simulation run type     floes               &lt;StructArray{Floe}&gt; vector of floes to add new floes to     poly                &lt;Polygon&gt; polygons to turn into floes     hmean               &lt;AbstratFloat&gt; average floe height     Œîh                  &lt;AbstratFloat&gt; height range - floes will range in height                         from hmean - Œîh to hmean + Œîh     rmax                &lt;AbstractFloat&gt; maximum radius of floe (could be larger given context)     floe_settings       &lt;FloeSettings&gt; settings needed to initialize floe                             settings     rng                 &lt;RNG&gt; random number generator to generate random floe                             attributes - default uses Xoshiro256++ algorithm     kwargs...           Any additional keywords to pass to floe constructor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/floe.jl#L244-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.potential_interaction-NTuple{4, Any}" href="#Subzero.potential_interaction-NTuple{4, Any}"><code>Subzero.potential_interaction</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">potential_interaction(
    centroid1,
    centroid2,
    rmax1,
    rmax2,
)</code></pre><p>Determine if two floes could potentially interact using the two centroid and two radii to form a bounding circle. Inputs:     centroid1   &lt;Vector&gt; first floe&#39;s centroid [x, y]     centroid2   &lt;Vector&gt; second floe&#39;s centroid [x, y]     rmax1       &lt;Float&gt; first floe&#39;s maximum radius     rmax2       &lt;Float&gt; second floe&#39;s maximum radius Outputs:     &lt;Bool&gt; true if floes could potentially interact, false otherwise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L870-L886">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.prettytime-Tuple{Any}" href="#Subzero.prettytime-Tuple{Any}"><code>Subzero.prettytime</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prettytime(t)</code></pre><p>Turn time in seconds into units of minutes, hours, days, or years as appropriate</p><p><strong>Aguments:</strong></p><ul><li><code>t::Real</code>: number of seconds</li></ul><p><strong>Returns:</strong></p><ul><li><code>::String</code>: number of seconds converted to a string value in minutes, hours, days, or years with units</li></ul><p><strong>Note:</strong></p><pre><code class="nohighlight hljs">This code was modified from the this [source code](https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/src/trials.jl).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/plotting.jl#L38-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.remove_floe_overlap!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT&lt;:AbstractFloat" href="#Subzero.remove_floe_overlap!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT&lt;:AbstractFloat"><code>Subzero.remove_floe_overlap!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_floe_overlap!(
    floes,
    shrink_idx,
    grow_floe_poly,
    pieces_buffer,
    max_floe_id,
    broken,
    ridgeraft_settings,
    floe_settings,
    rng,  
)</code></pre><p>Removes area/volume of overlap from floe that loses area during ridging/rafting Inputs:     floes               &lt;StructArray{Floe}&gt; list of floes     shrink<em>idx       &lt;Int&gt; index of floe that loses area     grow</em>floe<em>poly   &lt;Polys&gt; polygon of floe/domain that subsumes area     pieces</em>buffer       &lt;StructArray{Floe}&gt; list of new floe pieces caused by                             breakage of floes     max<em>floe</em>id         &lt;Int&gt; maximum floe ID before this ridging/rafting     broken              &lt;Vector{Bool}&gt; floe index is true if that floe has                             broken in a previous ridge/raft interaction     ridgeraft<em>settings  &lt;RidgeRaftSettings&gt; simulation&#39;s ridge/raft settings     floe</em>settings       &lt;FloeSettings&gt; simulation&#39;s settings for making floes     simp<em>settings       &lt;SimplificationSettings&gt; simulation&#39;s simplification                             settings     rng                 &lt;AbstractRNG&gt; random number generator Outputs:     transfer</em>vol    &lt;Float&gt; total volume to transfer away from floe     max<em>floe</em>id     &lt;Int&gt; maximum floe id of floe created during overlap removal     floe_num        &lt;Int&gt; total number of floes created from origianl floe -&gt;                         one if floe doesn&#39;t break, more otherwise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/ridge_raft.jl#L44-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.remove_floes!-NTuple{5, Any}" href="#Subzero.remove_floes!-NTuple{5, Any}"><code>Subzero.remove_floes!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_floes!(
    floes,
    grid,
    domain,
    dissolved,
    floe_settings
)</code></pre><p>Remove floes marked for removal and dissolve floes smaller than minimum floe area if the dissolve setting is on. Inputs:     floes           &lt;StructArray{Floe}&gt; model&#39;s floes     grid            &lt;AbstractGrid&gt; model&#39;s grid     domain          &lt;Domain&gt; model&#39;s domain     dissolved       &lt;Matrix{AbstractFloat}&gt; ocean&#39;s dissolved field     floe_settings   &lt;FloeSettings&gt; simulation&#39;s settings for making floes Outputs:     None. Removes floes that do not continue to the next timestep and reset all     continuing floes status to active.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/simplification.jl#L258-L278">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.replace_floe!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT" href="#Subzero.replace_floe!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT"><code>Subzero.replace_floe!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_floe!(
    floe::Union{Floe{FT}, LazyRow{Floe{FT}}},
    new_poly,
    new_mass,
    floe_settings,
    rng,
)</code></pre><p>Updates existing floe shape and related physical properties based of the polygon defining the floe. Inputs:     floe        &lt;Union{Floe, LazyRow{Floe}}&gt; floe to update     new<em>poly    &lt;Polygon&gt; polygon representing new outline of floe     new</em>mass    &lt;AbstractFloat&gt; mass of floe     floe_settings   &lt;FloeSettings&gt; simulation&#39;s settings for making floes     rng         &lt;RNG&gt; random number generator Ouputs:     Updates a given floe&#39;s physical properties given new shape and total mass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/update_floe.jl#L7-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.restart!-NTuple{4, Any}" href="#Subzero.restart!-NTuple{4, Any}"><code>Subzero.restart!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">restart!(initial_state_fn, checkpointer_fn, new_nŒît, new_output_writers; start_tstep = 0)</code></pre><p>Continue the simulation run started with the given initial state and floe file for an additional <code>new_nŒît</code> timesteps and with the new output<em>writers provided. The simulation will restart with a recorded timestep of `start</em>tstep`.</p><p>Note that this <code>restart!</code> function may not fit your needs and you may need to write your own. This function is meant to act as a simplest case and as a template for users to write their own restart functions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/simulation.jl#L299-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.rotate_radians!-Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real, Any}" href="#Subzero.rotate_radians!-Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real, Any}"><code>Subzero.rotate_radians!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_radians!(coords::PolyVec, Œ±)</code></pre><p>Rotate a polygon&#39;s coordinates by Œ± radians around the origin. Inputs:     coords  &lt;PolyVec{AbstractFloat}&gt; polygon coordinates     Œ±       &lt;Real&gt; radians to rotate the coordinates Outputs:     Updates coordinates in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L202-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.run!-Tuple{Any}" href="#Subzero.run!-Tuple{Any}"><code>Subzero.run!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run!(sim; logger = nothing, messages_per_tstep = 1, start_tstep = 0)</code></pre><p>Run given simulation and generate output for given writers. Simulation calculations will be done with Floats of type T (Float64 of Float32).</p><p>Inputs:     sim                 &lt;Simulation&gt; simulation to Run     logger              &lt;AbstractLogger&gt; logger for simulation - default is                             Subzero logger     messages<em>per</em>tstep  &lt;Int&gt; number of messages to print per timestep if using                             default SubzeroLogger, else not needed     start_tstep         &lt;Int&gt; which timestep to start the simulation on Outputs:     None. The simulation will be run and outputs will be saved in the output     folder. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/simulation.jl#L270-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.shift_cell_idx-Tuple{Any, Any, PeriodicBoundary}" href="#Subzero.shift_cell_idx-Tuple{Any, Any, PeriodicBoundary}"><code>Subzero.shift_cell_idx</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shift_cell_idx(idx, nlines, ::PeriodicBoundary)</code></pre><p>If index is greater than or equal to the grid lines, shift index to equivalent grid line on opposite side of grid due to periodic boundary. Similarly if given index is less than 1, shift index to equivalent grid line on opposite side of grid due to periodic boundary. Inputs:     idx     &lt;Int&gt; grid line index in either x or y     nlines  &lt;Int&gt; number of grid lines in model grid in either x or y direction             &lt;PeriodicBoundary&gt; boundary pair is periodic Output:     &lt;Int&gt; if given index is greater than or equal to number of grid lines, shift     index. If given index is less than 1, shift grid index. For example, the     last grid index, nlines, is equivalent to the 1st grid line. The nlines+1     grid line is equivalent to the 2nd grid line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L1158-L1174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.shift_cell_idx-Tuple{Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}" href="#Subzero.shift_cell_idx-Tuple{Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.shift_cell_idx</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shift_cell_idx(idx, nlines, ::NonPeriodicBoundary)</code></pre><p>Return index as is given non-periodic boundary pair in either x or y direction. Inputs:     idx     &lt;Int&gt; grid line index in either x or y     nlines  &lt;Int&gt; number of grid lines in model grid in either x or y direction             &lt;NonPeriodicBoundary&gt; boundary pair is non-periodic Ouput:     idx &lt;Int&gt; as given. Can include the index nlines, unlike with the periodic         case, which will use the first index instead. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L1142-L1153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.simplify_floes!-NTuple{7, Any}" href="#Subzero.simplify_floes!-NTuple{7, Any}"><code>Subzero.simplify_floes!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify_floes!(
    model,
    simp_settings,
    collision_settings,
    floe_settings,
    Œît,
    rng,
)</code></pre><p>Simplify the floe list be smoothing vertices, fusing floes, dissolving floes, and removing floes as needed.  Inputs:     model               &lt;Model&gt; model     max<em>floe</em>id         &lt;Int&gt; maximum floe id in simulation     simp<em>settings       &lt;SimplificationSettings&gt; simulation&#39;s simplification                             settings     collision</em>settings  &lt;CollisionSettings&gt; simulation&#39;s collision settings     floe_settings       &lt;FloeSettings&gt;  simulation&#39;s settings for making floes     Œît                  &lt;Int&gt; simulation timestep in seconds     rng                 &lt;RNG&gt; random number generator Outputs:     Updates floe list and removes floe that won&#39;t continue to the next timestep</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/simplification.jl#L316-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.smooth_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT&lt;:AbstractFloat" href="#Subzero.smooth_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT&lt;:AbstractFloat"><code>Subzero.smooth_floes!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smooth_floes!(
    floes,
    topography,
    simp_settings,
    collision_settings,
    Œît,
    rng,
)</code></pre><p>Smooths floe coordinates for floes with more vertices than the maximum allowed number. Uses Ramer‚ÄìDouglas‚ÄìPeucker algorithm with a user-defined tolerance. If new shape causes overlap greater with another floe greater than the maximum percentage allowed, mark the two floes for fusion. Inputs:     floes               &lt;StructArray{Floe}&gt; model&#39;s floes     topography          &lt;StructArray{TopographyElement}&gt; domain&#39;s topography     simp<em>settings       &lt;SimplificationSettings&gt; simulation&#39;s simplification                             settings     collision</em>settings  &lt;CollisionSettings&gt; simulation&#39;s collision settings     Œît                  &lt;Int&gt; length of simulation timestep in seconds     rng                 &lt;RNG&gt; random number generator for new monte carlo points</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/simplification.jl#L34-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.split_floe-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT" href="#Subzero.split_floe-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT"><code>Subzero.split_floe</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_floe(
    floe,
    rng,
    fracture_settings,
    floe_settings,
    Œît,
)</code></pre><p>Splits a given floe into pieces using voronoi tesselation. User will recieve a warning if floe isn&#39;t split. Inputs:     floe              &lt;Floe&gt; floe in simulation     rng               &lt;RNG&gt; random number generator used for voronoi tesselation     fracture<em>settings &lt;FractureSettings&gt; simulation&#39;s fracture settings     floe</em>settings     &lt;FloeSettings&gt; simulation&#39;s settings for making floes     Œît                &lt;Int&gt; length of simulation timesteps in seconds Outputs:     new_floes   &lt;StructArray{Floes}&gt; list of pieces floe is split into, each of                     which is a new floe</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L359-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.startup_sim" href="#Subzero.startup_sim"><code>Subzero.startup_sim</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">startup_sim(sim)</code></pre><p>Required actions to setup simulation. For example, setting up the simulation logger. Inputs:     sim                 &lt;Simulation&gt;     logger              &lt;AbstractLogger&gt; logger for simulation - default is                             Subzero logger     messages<em>per</em>tstep  &lt;Int&gt; number of messages to print per timestep if using                             default SubzeroLogger, else not needed Outputs:     None.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/simulation.jl#L222-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.teardown_sim-Tuple{Any}" href="#Subzero.teardown_sim-Tuple{Any}"><code>Subzero.teardown_sim</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">teardown_sim(sim)</code></pre><p>Required actions to tear down simulation. For example, flushing the simulation&#39;s logger and closing the stream. Inputs:     sim &lt;Simulation&gt; Outputs:     None.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/simulation.jl#L247-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.timestep_collisions!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 6}}} where FT&lt;:AbstractFloat" href="#Subzero.timestep_collisions!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 6}}} where FT&lt;:AbstractFloat"><code>Subzero.timestep_collisions!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">timestep_collisions!(
    floes,
    n_init_floes,
    domain,
    consts,
    Œît,
    collision_settings,
    spinlock,
)</code></pre><p>Resolves collisions between pairs of floes and calculates the forces and torques caused by those collisions. Inputs:     floes               &lt;StructArray{Floe}&gt; model&#39;s list of floes     n<em>init</em>floes        &lt;Int&gt; number of floes without ghost floes     domain              &lt;Domain&gt; model&#39;s domain     consts              &lt;Constants&gt; simulation constants     Œît                  &lt;Int&gt; length of simulation timestep in seconds     collision_settings  &lt;CollisionSettings&gt; simulation collision settings     spinlock            &lt;Thread.SpinLock&gt;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L895-L916">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.timestep_coupling!-NTuple{5, Any}" href="#Subzero.timestep_coupling!-NTuple{5, Any}"><code>Subzero.timestep_coupling!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">timestep_coupling!(
    model,
    Œît,
    consts,
    coupling_settings,
    floe_settings,
)</code></pre><p>Calculates the effects of the ocean and atmosphere on the ice and the effects of the ice and atmosphere on the ocean if the coupling is two-way. Inputs:     model               &lt;Model&gt; model     Œît                  &lt;Int&gt; length of timestep in seconds     consts              &lt;Constants&gt; constants used in simulation     coupling<em>settings   &lt;CouplingSettings&gt; settings for coupling     floe</em>settings       &lt;FloeSettings&gt; settings for basic floe properties Outputs:     None. Updates each floe&#39;s ocean/atmosphere forcings (fxOA, fyOA, torqueOA)     and calculates stresses on each ocean grid cell from ice and atmosphere if     two-way coupling is enabled in coupling_settings       </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/coupling.jl#L1683-L1704">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.timestep_floe_properties!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Any, Any}} where FT" href="#Subzero.timestep_floe_properties!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Any, Any}} where FT"><code>Subzero.timestep_floe_properties!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">timestep_floe(floe)</code></pre><p>Update floe position and velocities using second-order time stepping with tendencies calculated at previous timesteps. Height, mass, stress, and strain also updated based on previous timestep thermodynamics and interactions with other floes.  Input:         floe            &lt;Floe&gt;         Œît              &lt;Int&gt; simulation timestep in second         floe_settings   &lt;FloeSettings&gt; simulation floe settings Output:         None. Floe&#39;s fields are updated with values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/update_floe.jl#L455-L468">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.timestep_ridging_rafting!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat" href="#Subzero.timestep_ridging_rafting!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat"><code>Subzero.timestep_ridging_rafting!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">timestep_ridging_rafting!(
    floes,
    pieces_buffer,
    domain,
    max_floe_id,
    ridgeraft_settings::RidgeRaftSettings{FT},
    floe_settings
    simp_settings,
    Œît,
    rng,
)</code></pre><p>Ridge and raft floes that meet probability and height criteria. Inputs:     floes               &lt;StructArray{Floe}&gt; simulation&#39;s list of floes     pieces<em>buffer       &lt;StructArray{Floe}&gt; list of new floe pieces caused by                             breakage of floes     domain              &lt;Domain&gt; simulation&#39;s domain     max</em>floe<em>id         &lt;Int&gt; maximum floe ID before this ridging/rafting     ridgeraft</em>settings  &lt;RidgeRaftSettings&gt; ridge/raft settings     floe<em>settings       &lt;FloeSettings&gt; simulation&#39;s settings for making floes     simp</em>settings       &lt;SimplificationSettings&gt; simplification settings     Œît                  &lt;Int&gt; length of timestep in seconds     rng                 &lt;RandomNumberGenerator&gt; simulation&#39;s rng Outputs:     Updates floes post ridging and rafting and adds any new pieces to the pieces     buffer to be made into new floes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/ridge_raft.jl#L647-L675">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.timestep_sim!" href="#Subzero.timestep_sim!"><code>Subzero.timestep_sim!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>timestep<em>sim!(sim, tstep, start</em>tstep)</p><p>Run one step of the simulation and write output.  Inputs:     sim          &lt;Simulation&gt; simulation to advance     tstep        &lt;Int&gt; current timestep     start_tstep  &lt;Int&gt; timestep simulation started on Outputs:     None. Simulation advances by one timestep. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/simulation_components/simulation.jl#L83-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.timestep_welding!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat" href="#Subzero.timestep_welding!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat"><code>Subzero.timestep_welding!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">timestep_welding!(
    floes,
    max_floe_id,
    grid,
    domain,
    Nx,
    Ny,
    weld_settings::WeldSettings{FT},
    floe_settings
    Œît,
    rng,
)</code></pre><p>Weld floes within sections of the domain that meet overlap and size criteria together, ensuring resulting floe doesn&#39;t surpass maximum floe area.  Inputs:     floes               &lt;StructArray{Floe}&gt; simulation&#39;s list of floes     max<em>floe</em>id         &lt;Int&gt; maximum floe ID before this welding     grid                &lt;RegRectilinearGrid&gt; simulation&#39;s grid     domain              &lt;Domain&gt; simulation&#39;s domain     Nx                  &lt;Int&gt; number of grid cells in the x-direction to split                             domain into for welding groups     Ny                  &lt;Int&gt; number of grid cells in the y-direction to split                             domain into for welding groups     weld<em>settings       &lt;WeldSettings&gt; welding settings     floe</em>settings       &lt;FloeSettings&gt; sim&#39;s settings for making new floes     consts              &lt;Consts&gt; simulation&#39;s constants     Œît                  &lt;Int&gt; length of timestep in seconds     rng                 &lt;RandomNumberGenerator&gt; simulation&#39;s rng Outputs:     Returns nothing. Welds groups of floes together that meet requirments. Floes     that are fused into other floes are marked for removal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/welding.jl#L57-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.translate!-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.translate!-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.translate!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">translate!(coords, Œîx, Œîy)</code></pre><p>Translate each of the given coodinates by given deltas in place Inputs:     coords PolyVec{Float}     vec &lt;Vector{Real}&gt; Output:     Updates given coords</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L182-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.translate-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.translate-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.translate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">translate!(coords, Œîx, Œîy)</code></pre><p>Make a copy of given coordinates and translate by given deltas.  Inputs:     coords PolyVec{Float}     vec &lt;Vector{Real}&gt; Output:     Updates given coords</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L163-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.update_boundaries!-Tuple{Any, Any}" href="#Subzero.update_boundaries!-Tuple{Any, Any}"><code>Subzero.update_boundaries!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_boundaries!(domain)</code></pre><p>Update each boundary in the domain. For now, this simply means moving compression boundaries by their velocities. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L742-L747">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.update_boundary!-Tuple{Union{CollisionBoundary, OpenBoundary, PeriodicBoundary}, Any}" href="#Subzero.update_boundary!-Tuple{Union{CollisionBoundary, OpenBoundary, PeriodicBoundary}, Any}"><code>Subzero.update_boundary!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_boundary!(args...)</code></pre><p>No updates to boundaries that aren&#39;t compression boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L688-L692">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D&lt;:Union{East, West}, FT&lt;:AbstractFloat}" href="#Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D&lt;:Union{East, West}, FT&lt;:AbstractFloat}"><code>Subzero.update_boundary!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_boundary!(boundary, Œît)</code></pre><p>Move East/West compression boundaries by given velocity. Update coords and val fields to reflect new position. Inputs:     boundary    &lt;MovingBoundary{Union{East, West}, AbstractFloat}&gt;                      domain compression boundary     Œît          &lt;Int&gt; number of seconds in a timestep Outputs:     None. Move boundary East/West depending on velocity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L720-L731">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D&lt;:Union{North, South}, FT&lt;:AbstractFloat}" href="#Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D&lt;:Union{North, South}, FT&lt;:AbstractFloat}"><code>Subzero.update_boundary!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_boundary!(boundary, Œît)</code></pre><p>Move North/South compression boundaries by given velocity. Update coords and val fields to reflect new position. Inputs:     boundary    &lt;MovingBoundary{Union{North, South}, AbstractFloat}&gt;                      domain compression boundary     Œît          &lt;Int&gt; number of seconds in a timestep Outputs:     None. Move boundary North or South depending on velocity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/collisions.jl#L699-L710">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.update_criteria!-Tuple{MohrsCone, Any}" href="#Subzero.update_criteria!-Tuple{MohrsCone, Any}"><code>Subzero.update_criteria!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_criteria!(::MohrsCone, floes)</code></pre><p>Mohr&#39;s cone is not time or floe dependent so it doesn&#39;t need to be updates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L244-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.update_criteria!-Union{Tuple{FT}, Tuple{HiblerYieldCurve{FT}, Any}} where FT" href="#Subzero.update_criteria!-Union{Tuple{FT}, Tuple{HiblerYieldCurve{FT}, Any}} where FT"><code>Subzero.update_criteria!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_criteria!(criteria::HiblerYieldCurve, floes)</code></pre><p>Update the Hibler Yield Curve vertices based on the current set of floes. The criteria changes based off of the average height of the floes. Inputs:     criteria    &lt;HiblerYieldCurve&gt; simulation&#39;s fracture criteria     floes       &lt;StructArray{Floe}&gt; model&#39;s list of floes Outputs:     None. Updates the criteria&#39;s vertices field to update new criteria. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/fractures.jl#L223-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.update_ghost_timestep_vals!-Tuple{Any, Any, Any}" href="#Subzero.update_ghost_timestep_vals!-Tuple{Any, Any, Any}"><code>Subzero.update_ghost_timestep_vals!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_ghost_timestep_vals!(floes, idx, parent_idx)</code></pre><p>Update a parent floes and its ghosts to match velocities and accelerations at given index. Inputs:     floes       &lt;StructArray{Floe}&gt; list of floes in the simulation     idx         &lt;Int&gt; index of floe within floes list to copy to floe and ghosts     parent_idx  &lt;Int&gt; index of parent floe to update, along with its ghosts Outputs:     Nothing. Update floe values. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/update_floe.jl#L344-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.update_new_rotation_conserve!-NTuple{9, Any}" href="#Subzero.update_new_rotation_conserve!-NTuple{9, Any}"><code>Subzero.update_new_rotation_conserve!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_new_rotation_conserve!(
    x, y,
    floe1, floe2,
    init_rot_momentum, init_p_rot_momentum,
    diff_orbital, diff_p_orbital,
    Œît,
)</code></pre><p>Update rotational velocities of two floes whose shapes may have changed to maintain conservation of momentum given the floes&#39; intial roational momentums and the change in orbital momentum between their original shape and new shapes. Additionally, both floes will have the same velocity at a given (x,y) point. Inputs:     x                   &lt;Float&gt; x-coordinate of point where floes share same                             rotational velocity     y                   &lt;Float&gt; y-coordinate of point where floes share same                             rotational velocity     floe1               &lt;Union{Floe, LazyRow{Floe}}&gt; first floe in pair     floe2               &lt;Union{Floe, LazyRow{Floe}}&gt; second floe in pair     init<em>rot</em>momentum   &lt;Float&gt; initial rotational momentum of floe 1 before                             shape change     init<em>p</em>rot<em>momentum &lt;Float&gt; initial rotational momentum of floe 2 before                             shape change     diff</em>orbital        &lt;Float&gt; change in floe 1&#39;s orbital velocity after shape                             change     diff<em>p</em>orbital      &lt;Float&gt; change in floe 1&#39;s orbital velocity after shape                             change     Œît                  &lt;Int&gt; length of timestep in seconds Output:     Nothing. Update both floes&#39; rotational velocity, previous rotational     velocity, and rotational acceleration to conserve angular momentum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/physical_processes/update_floe.jl#L172-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.valid_polyvec!-Tuple{Any}" href="#Subzero.valid_polyvec!-Tuple{Any}"><code>Subzero.valid_polyvec!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">valid_polyvec(coords::PolyVec{FT})</code></pre><p>Takes a PolyVec object and make sure that the last element of each &quot;ring&quot; (vector of vector of floats) has the same first element as last element and has not duplicate adjacent elements. Also asserts that each &quot;ring&quot; as at least three distinct elements or else it is not a valid ring, but rather a line segment. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.valid_ringvec!-Tuple{Any}" href="#Subzero.valid_ringvec!-Tuple{Any}"><code>Subzero.valid_ringvec!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">valid_ringvec(coords::RingVec{FT})</code></pre><p>Takes a RingVec object and make sure that the last element has the same first element as last element and that other than these two elements there are no duplicate, adjacent vertices. Also asserts that the ring as at least three elements or else it cannot be made into a valid ring as it is a line segment. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.which_points_on_edges-Tuple{Any, Any}" href="#Subzero.which_points_on_edges-Tuple{Any, Any}"><code>Subzero.which_points_on_edges</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">which_points_on_edges(points, coords; atol = 1e-1)</code></pre><p>Find which points are on the coordinates of the given polygon. Inputs:     points &lt;Vector{Tuple{Float, Float} or Vector{Vector{Float}}}&gt; points to         match to edges within polygon     coords  &lt;PolVec&gt; polygon coordinates     atol    &lt;Float&gt; distance target point can be from an edge before being                 classified as not on the edge</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L364-L374">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.which_vertices_match_points-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Any}} where FT" href="#Subzero.which_vertices_match_points-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Any}} where FT"><code>Subzero.which_vertices_match_points</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">which_vertices_match_points(ipoints, coords, atol)</code></pre><p>Find which vertices in coords match given points Inputs:     points &lt;Vector{Tuple{Float, Float} or Vector{Vector{Float}}}&gt; points to                 match to vertices within polygon     region  &lt;Polygon&gt; polygon      atol    &lt;Float&gt; distance vertex can be away from target point before being                 classified as different points Output:     Vector{Int} indices of points in polygon that match the intersection points Note:      If last coordinate is a repeat of first coordinate, last coordinate index is     NOT recorded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/floe_utils.jl#L315-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.write_checkpoint_data!-Tuple{Any, Any}" href="#Subzero.write_checkpoint_data!-Tuple{Any, Any}"><code>Subzero.write_checkpoint_data!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_checkpoint_data!(sim, tstep)</code></pre><p>Writes model&#39;s floe, ocean, and atmosphere data to JLD2 file. Data can be used to restart simulation run. Inputs:     sim     &lt;Simulation&gt; simulation to run     tstep       &lt;Int&gt; simulation timestep Output:     Writes floes, ocean, and atmosphere to JLD2 file with name writer.fn for     current timestep, which will be the group in the JLD2 file. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L520-L531">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.write_data!-Tuple{Any, Any, Any}" href="#Subzero.write_data!-Tuple{Any, Any, Any}"><code>Subzero.write_data!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_data!(sim, tstep, start_tstep)</code></pre><p>Writes data for the simulation&#39;s writers that are due to write at given tstep. Inputs:     sim         &lt;Simulation&gt; simulation to run     tstep       &lt;Int&gt; simulation timestep     start_tstep &lt;Int&gt; starting timestep of the simulation Output:     Saves writer requested data to files specified in each writer. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L467-L477">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.write_floe_data!-Tuple{Any, Any, Any}" href="#Subzero.write_floe_data!-Tuple{Any, Any, Any}"><code>Subzero.write_floe_data!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_floe_data!(sim, tstep)</code></pre><p>Writes desired FloeOutputWriter data to JLD2 file.</p><p>Inputs:     writers     &lt;StructArray{FloeWriter}&gt; list of floe writers      floes       &lt;StructArray{Floe}&gt; list of floes     tstep       &lt;Int&gt; simulation timestep Output:     Writes desired fields writer.outputs to JLD2 file with name writer.fn for     current timestep, which will be the group in the JLD2 file. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L545-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.write_grid_data!-NTuple{4, Any}" href="#Subzero.write_grid_data!-NTuple{4, Any}"><code>Subzero.write_grid_data!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_grid_data!(sim, tstep)</code></pre><p>Writes desired GridOutputWriter data to NetCDF file. Inputs:     writers     &lt;StructArray{GridWriter}&gt; list of grid writers     floes       &lt;StructArray{Floe}&gt; list of floes     topography  &lt;StructArray{TopographyElement}&gt; list of topography elements     tstep       &lt;Int&gt; simulation timestep Output:     Writes desired fields writer.outputs to file with name writer.fn for current     timestep.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L575-L587">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.write_init_state_data!-Tuple{Any}" href="#Subzero.write_init_state_data!-Tuple{Any}"><code>Subzero.write_init_state_data!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_init_state_data!(sim, tstep)</code></pre><p>Save initial simulation state. Inputs:     sim     &lt;Simulation&gt; simulation to run     tstep   &lt;Int&gt; timestep - not used Outputs:     Saves simulation state to file. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/285032b10105db369913f8609eee98c1e13141cb/src/output.jl#L501-L510">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">¬´ Tutorial</a><a class="docs-footer-nextpage" href="../contribute/">Contributing ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 8 August 2024 21:42">Thursday 8 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
