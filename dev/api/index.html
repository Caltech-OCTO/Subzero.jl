<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Subzero.jl</title><meta name="title" content="API Reference · Subzero.jl"/><meta property="og:title" content="API Reference · Subzero.jl"/><meta property="twitter:title" content="API Reference · Subzero.jl"/><meta name="description" content="Documentation for Subzero.jl."/><meta property="og:description" content="Documentation for Subzero.jl."/><meta property="twitter:description" content="Documentation for Subzero.jl."/><meta property="og:url" content="https://Caltech-OCTO.github.io/SubzeroDocumentation/stable/api/"/><meta property="twitter:url" content="https://Caltech-OCTO.github.io/SubzeroDocumentation/stable/api/"/><link rel="canonical" href="https://Caltech-OCTO.github.io/SubzeroDocumentation/stable/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Subzero.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Grids"><span>Grids</span></a></li><li><a class="tocitem" href="#Directions"><span>Directions</span></a></li><li><a class="tocitem" href="#Boundaries"><span>Boundaries</span></a></li><li><a class="tocitem" href="#Topography"><span>Topography</span></a></li><li><a class="tocitem" href="#Domain"><span>Domain</span></a></li><li><a class="tocitem" href="#Ocean"><span>Ocean</span></a></li><li><a class="tocitem" href="#Atmosphere"><span>Atmosphere</span></a></li><li><a class="tocitem" href="#Developer-Used-Types"><span>Developer-Used Types</span></a></li></ul></li><li><span class="tocitem">Improving Subzero</span><ul><li><a class="tocitem" href="../contribute/">Contributing</a></li><li><a class="tocitem" href="../devdocs/">Developer Documentation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Caltech-OCTO/Subzero.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-Subzero-API-documentation"><a class="docs-heading-anchor" href="#Full-Subzero-API-documentation">Full Subzero API documentation</a><a id="Full-Subzero-API-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Subzero-API-documentation" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This page is still very much WIP!</p></div></div><h2 id="Grids"><a class="docs-heading-anchor" href="#Grids">Grids</a><a id="Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Grids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.AbstractRectilinearGrid" href="#Subzero.AbstractRectilinearGrid"><code>Subzero.AbstractRectilinearGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">YourGridType{FT} &lt;: AbstractRectilinearGrid{FT}</code></pre><p>Each simulation run with Subzero.jl must be run on a grid. A grid defines the points at which the ocean and atmosphere hold velocity data, as well as various other tracers, at grid points. The user must choose an existing subtype of <code>AbstractRectilinearGrid</code> or implement a new subtype to create a simulation. </p><p>Each grid implementation must define the number and dimensions of each grid cell. Right now, this assumes that the ocean and the atmosphere are on the same grid and that the grid is rectangular. We might not want this to be true in the future. Furthermore, each concrete implementation of <code>AbstractRectilinearGrid</code> that will be used to two-way couple with an ocean or an atmosphere must have a field called <code>floe_locations</code> that is a matrix of <a href="#Subzero.CellFloes"><code>CellFloes</code></a>, with one element for each grid point. The user should not worry about <code>CellFloes</code>, this is up to the developer to make sure that their grid contains and populates this field. Again, in the future, this might be related to the ocean and/or atmosphere rather than the grid. For more information, or if you&#39;re interested in working on this, see issue <a href="https://github.com/Caltech-OCTO/Subzero.jl/issues/107">#107</a>.</p><p><strong><em>API</em></strong></p><p>The following methods must be implemented for all subtypes:</p><ul><li><code>_get_grid_extent(grid::AbstractRectilinearGrid)</code>: </li></ul><p>The <code>_get_grid_extent</code> function takes in a concrete subtype of <code>AbstractRectilinearGrid</code> and returns the grid&#39;s minimum x-value, maximum x-value, minimum y-value, and maximum y-value.</p><p>Given the original code was written for <a href="#Subzero.RegRectilinearGrid"><code>RegRectilinearGrid</code></a> objects, the dispatch isn&#39;t fully implemented and other functions should be added to this list. If you were interested in adding a new subtype of <code>AbstractRectilinearGrid</code>, see  issue <a href="https://github.com/Caltech-OCTO/Subzero.jl/issues/108">#108</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/grids.jl#L73-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.RegRectilinearGrid" href="#Subzero.RegRectilinearGrid"><code>Subzero.RegRectilinearGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RegRectilinearGrid{FT} &lt;: AbstractRectilinearGrid{FT}</code></pre><p>A concrete implementation of an <a href="#Subzero.AbstractRectilinearGrid"><code>AbstractRectilinearGrid</code></a> that represents a tessellation of 2-dimensional Euclidean space into <code>n</code>-by-<code>m</code> congruent rectangles. Fields that hold float data are of type <code>FT</code>, a concrete subtype of <code>AbstractFloat</code>.</p><ul><li><code>Nx::Int</code>: number of grid cells in the x-direction</li><li><code>Ny::Int</code>: number of grid cells in the y-direction</li><li><code>Δx::FT</code>: grid cell width</li><li><code>Δy::FT</code>: grid cell height</li><li><code>x0::FT</code>: value of first x grid line</li><li><code>xf::FT</code>: value of final x grid line</li><li><code>y0::FT</code>: value of first y grid line</li><li><code>yf::FT</code>: value of final y grid line</li><li><code>floe_locations::Matrix{CellFloes}</code>: <code>Nx + 1</code> by <code>Ny + 1</code> matrix of <a href="#Subzero.CellFloes"><code>CellFloes</code></a></li></ul><p>Here is how to construct a <code>RegRectilinearGrid</code>:</p><pre><code class="nohighlight hljs">RegRectilinearGrid([FT = Float64]; x0, xf, y0, yf, Nx = nothing, Ny = nothing, Δx = nothing, Δy = nothing)</code></pre><p><strong><em>Positional arguments</em></strong></p><ul><li><code>FT::Type{&lt;:AbstractFloat}</code>: Float type used to run the simulation, either <code>Float64</code> (default) or <code>Float32</code>.</li></ul><p><strong><em>Keyword arguments</em></strong></p><ul><li><code>x0::FT</code>: value of first x grid line</li><li><code>xf::FT</code>: value of final x grid line</li><li><code>y0::FT</code>: value of first y grid line</li><li><code>yf::FT</code>: value of final y grid line</li><li><code>Nx::Int</code>: number of grid cells in the x-direction</li><li><code>Ny::Int</code>: number of grid cells in the y-direction</li><li><code>Δx::FT</code>: grid cell width</li><li><code>Δy::FT</code>: grid cell height</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The user MUST provide <code>x0</code>, <code>xf</code>, <code>y0</code>, and <code>yf</code>; the user then has the choice to provide <code>Nx</code> and <code>Ny</code> OR <code>Δx</code> and <code>Δy</code>. If provided <code>Δx</code> doesn&#39;t evenly divide length <code>xf-x0</code> or <code>Δy</code> doesn&#39;t evenly divide <code>yf-y0</code>, you won&#39;t get full size grid. The grid will be &quot;trimmed&quot; to the nearest full grid square in both directions.</p></div></div><p><strong><em>Examples</em></strong></p><ul><li>Defining a <code>RegRectilinearGrid</code> using <code>Nx</code> and <code>Ny</code>.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; grid = RegRectilinearGrid(; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 10)
RegRectilinearGrid{Float64}
  ⊢x extent (0.0 to 500000.0) with 20 grid cells of size 25000.0 m
  ∟y extent (0.0 to 500000.0) with 10 grid cells of size 50000.0 m</code></pre><ul><li>Defining a <code>RegRectilinearGrid</code> using <code>Δx</code> and <code>Δy</code>.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; grid = RegRectilinearGrid(Float32; x0 = -5e5, xf = 5e5, y0 = 0.0, yf = 5e5, Δx = 5e4, Δy = 5e4)
RegRectilinearGrid{Float32}
  ⊢x extent (-500000.0 to 500000.0) with 20 grid cells of size 50000.0 m
  ∟y extent (0.0 to 500000.0) with 10 grid cells of size 50000.0 m</code></pre><ul><li>Error due to attemping to define a <code>RegRectilinearGrid</code> using <code>Δx</code> and <code>Ny</code>.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; grid = RegRectilinearGrid(; x0 = -5e5, xf = 5e5, y0 = 0.0, yf = 5e5, Δx = 5e4, Ny = 10)
ERROR: ArgumentError: To create a RegRectilinearGrid, either provide Δx and Δy OR Nx and Ny.
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/grids.jl#L118-L179">source</a></section></article><h2 id="Directions"><a class="docs-heading-anchor" href="#Directions">Directions</a><a id="Directions-1"></a><a class="docs-heading-anchor-permalink" href="#Directions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.AbstractDirection" href="#Subzero.AbstractDirection"><code>Subzero.AbstractDirection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">YourDirection &lt;: AbstractDirection</code></pre><p>Each domain within a Subzero.jl <a href="#Model"><code>Model</code></a> must have four (4) boundaries (subtypes of <a href="#Subzero.AbstractBoundary"><code>AbstractBoundary</code></a>) where each of these boundaries is parametrically typed by the direction of the boundary. The user will first choose one of the four cardinal directions, the subtypes of <code>AbstractDirection</code>:</p><ul><li><a href="#Subzero.North"><code>North</code></a></li><li><a href="#Subzero.South"><code>South</code></a></li><li><a href="#Subzero.East"><code>East</code></a></li><li><a href="#Subzero.West"><code>West</code></a></li></ul><p>This abstract type is not meant to be extended by the user, unless the user wants to move away from a rectangular domain with assigned cardinal directions for each wall. This would a more major redesign and the user should check out the <a href="&quot;devdocs.md&quot;">developer documentation</a>.</p><p><strong>_API</strong></p><ul><li><code>_boundary_info_from_extent(D::Type{AbstractDirection}, FT::Type{AbstractFloat}, x0, xf, y0, yf)</code></li></ul><p>The <code>_boundary_info_from_extent</code> function finds the values for the <code>poly</code> and <code>val</code> fields of a subtype of <a href="#Subzero.AbstractBoundary"><code>AbstractBoundary</code></a> of direction <code>D</code> given a region of the extent defined by <code>x0</code>, <code>xf</code>, <code>y0</code>, and <code>yf</code> given that these are the minimum and maximum <code>x</code> and <code>y</code> values of the region desired. The returned extent will have values of type <code>FT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/abstract_domains.jl#L43-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.North" href="#Subzero.North"><code>Subzero.North</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">North&lt;:AbstractDirection</code></pre><p>A simple subtype of <a href="#Subzero.AbstractDirection"><code>AbstractDirection</code></a> used for parametrically typing a subtype of <a href="#Subzero.AbstractBoundary"><code>AbstractBoundary</code></a> if that boundary is the northern boundary in a rectangular domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/boundaries.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.South" href="#Subzero.South"><code>Subzero.South</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">South&lt;:AbstractDirection</code></pre><p>A simple subtype of <a href="#Subzero.AbstractDirection"><code>AbstractDirection</code></a> used for parametrically typing a subtype of <a href="#Subzero.AbstractBoundary"><code>AbstractBoundary</code></a> if that boundary is the southern boundary in a rectangular domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/boundaries.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.East" href="#Subzero.East"><code>Subzero.East</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">East&lt;:AbstractDirection</code></pre><p>A simple subtype of <a href="#Subzero.AbstractDirection"><code>AbstractDirection</code></a> used for parametrically typing a subtype of <a href="#Subzero.AbstractBoundary"><code>AbstractBoundary</code></a> if that boundary is the eastern boundary in a rectangular domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/boundaries.jl#L78-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.West" href="#Subzero.West"><code>Subzero.West</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">West&lt;:AbstractDirection</code></pre><p>A simple subtype of <a href="#Subzero.AbstractDirection"><code>AbstractDirection</code></a> used for parametrically typing a subtype of <a href="#Subzero.AbstractBoundary"><code>AbstractBoundary</code></a> if that boundary is the western boundary in a rectangular domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/boundaries.jl#L115-L121">source</a></section></article><h2 id="Boundaries"><a class="docs-heading-anchor" href="#Boundaries">Boundaries</a><a id="Boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Boundaries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.AbstractBoundary" href="#Subzero.AbstractBoundary"><code>Subzero.AbstractBoundary</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractBoundary{D, FT} &lt;: AbstractDomainElement{FT}</code></pre><p>When running a Subzero simulation, each simulation has a rectangular domain that contains the ice pack. This domain is made up for four boundaries, one in each of the cardinal directions: <a href="#Subzero.North"><code>North</code></a>, <a href="#Subzero.South"><code>South</code></a>, <a href="#Subzero.East"><code>East</code></a>, and <a href="#Subzero.West"><code>West</code></a>. The user will pick four boundary types, each concrete subtypes of <code>AbstractBoundary</code> and assign each of them a direction, <code>D</code> and a float type <code>FT</code>, by typing them <a href="&quot;https://docs.julialang.org/en/v1/manual/types/#Parametric-Types&quot;">parametrically</a>. </p><p>The user can pick from the currently implemented concrete subtypes of <code>AbstractBoundary</code> (<a href="#Subzero.OpenBoundary"><code>OpenBoundary</code></a>, <a href="#Subzero.CollisionBoundary"><code>CollisionBoundary</code></a>, <a href="#Subzero.PeriodicBoundary"><code>PeriodicBoundary</code></a>, and <a href="#Subzero.MovingBoundary"><code>MovingBoundary</code></a>) or implement their own.</p><p>For now, each boundary wall is assumed to be a rectangle. For correct behavior, the corners of each of the boundary rectangles should overlap to make sure that no floes reach outside of the domain without touching a boundary. These rectangles should be represented as polygons with the <code>poly</code> field within each boundary. Furthermore, each boundary should have a <code>val</code> field that represents either the line <code>y = val</code> (for <code>North</code> and <code>South</code> walls) or <code>x = val</code> (for <code>East</code> and <code>West</code> walls) that denotes the line that marks the &quot;inner-most&quot; edge of the domain. If an ice floe passes over the boundary&#39;s <code>val</code> line, the floe interacts with the boundary.</p><pre><code class="language-text hljs"> ________________
|__|____val___|__| &lt;- North coordinates include corners
|  |          |  |
|  |          |  | &lt;- East and west coordinates ALSO include corners
|  |          |  |</code></pre><p>For ease of use, each boundary should have a constructor option where the user can provide an <a href="#Subzero.AbstractRectilinearGrid"><code>AbstractRectilinearGrid</code></a> concrete type to define a boundary where <code>val</code> is at the edge of the grid so that the boundaries form a border right around the grid.</p><p><strong><em>API</em></strong></p><p>In addition to the below function, any new <code>AbstractBoundary</code> subtype must also implement <a href="@ref"><code>AbstractDomainElement</code></a> API functions.</p><ul><li><code>_update_boundary!(boundary::AbstractBoundary, Δt::Int)</code></li><li><code>_periodic_compat(boundary1::AbstractBoundary, boundary2::AbstractBoundary)</code></li></ul><p>The <code>_update_boundary!</code> function updates a boundary&#39;s position (by changing the <code>val</code> and <code>poly</code> fields) at every timestep. Currently, only <code>MovingBoundary</code> elements are updated, and their update depends on the length of the simulation&#39;s timestep, <code>Δt</code>.</p><p>The <code>_periodic_compat</code> function determines if a pair of functions are &quot;periodically compatible&quot;,  that is, could they form a pair on opposite edges of a domain to create a set of functioning periodic boundaries. It is called when creating a <a href="#Domain"><code>Domain</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/abstract_domains.jl#L69-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.OpenBoundary" href="#Subzero.OpenBoundary"><code>Subzero.OpenBoundary</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OpenBoundary{D, FT} &lt;: AbstractBoundary{D, FT}</code></pre><p>A concrete subtype of <a href="#Subzero.AbstractBoundary"><code>AbstractBoundary</code></a> that removes a floe from the simulation if any of the floe&#39;s vertices overlap with the <code>OpenBoundary</code>. This is meant to simulate the floe floating out of the simulation. The floe is immeditaly removed as there might not be ocean <code>u</code> and <code>v</code> values outside of the domian and thus we wouldn&#39;t know how to evolve the floe&#39;s trajectory. This boundary is direction <code>D</code> (<a href="#Subzero.AbstractDirection"><code>AbstractDirection</code></a>) of the domain and has field data of type <code>FT &lt;: AbstractFloat</code>.</p><p><strong><em>Fields</em></strong></p><ul><li><code>poly::StaticQuadrilateral{FT}</code>: rectangular polygon representing <br/></li></ul><p>the shape and location of the boundary on a given timestep with points of float type <code>FT</code>.</p><ul><li><code>val::FT</code>: number of float type <code>FT</code> representing either the line <code>y = val</code> <br/></li></ul><p>(for <code>North</code> and <code>South</code> walls) or <code>x = val</code> (for <code>East</code> and <code>West</code> walls) that denotes the <br/>line marking the inner-most edge of the domain.</p><p>Here is how to construct an <code>OpenBoundary</code>:</p><pre><code class="nohighlight hljs">OpenBoundary(D, [FT = Float64]; grid  = nothing, x0 = nothing, xf = nothing, y0 = nothing, yf = nothing)</code></pre><p>The user must specify which <a href="#Subzero.AbstractDirection"><code>AbstractDirection</code></a> the boundary is. The user also has an opportunity to specify which float type <code>Float64</code> or <code>Float32</code> will be used for field data. The user then must either provide an grid object (<a href="#Subzero.AbstractRectilinearGrid"><code>AbstractRectilinearGrid</code></a>) for the domain to align with the grid edges, or provide four values (<code>x0</code>, <code>xf</code>, <code>y0</code>, and <code>yf</code>) that define the x and y-extents the user wants for the domain.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the user chooses to specify the domain extents, they still must be within the grid in order to make a valid <a href="#Model"><code>Model</code></a>.</p></div></div><p><strong><em>Positional arguments</em></strong></p><ul><li><code>D::Type{&lt;:AbstractDirection}</code>: subtype of AbstractDirection used to represent <br/></li></ul><p>if a boundary is the North, South, East, or West boundary of a simulation</p><ul><li><code>FT::Type{&lt;:AbstractFloat}</code>: Float type used to run the simulation, either <code>Float64</code> (default) or <code>Float32</code>.</li></ul><p><strong><em>Keyword arguments</em></strong></p><ul><li><code>grid::AbstractRectilinearGrid</code>: subtype of AbstractRectilinearGrid representing the grid used within a simulation</li><li><code>x0::FT</code>: minimum x-value of domain extent (region floes will be contained within)</li><li><code>xf::FT</code>: maximum x-value of domain extent (region floes will be contained within)</li><li><code>y0::FT</code>: minimum y-value of domain extent (region floes will be contained within)</li><li><code>yf::FT</code>: maximum y-value of domain extent (region floes will be contained within)</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The user must either provide a <code>grid</code> OR all four (4) of <code>x0</code>, <code>xf</code>, <code>y0</code>, and <code>yf</code>.</p></div></div><p><strong><em>Examples</em></strong></p><ul><li>Defining a Northern <code>OpenBoundary</code> with Float64 (default type) data using the <code>grid</code> keyword.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; g = RegRectilinearGrid(x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);

julia&gt; OpenBoundary(North; grid = g)
OpenBoundary{North, Float64}
  ⊢polygon points are defined by the following set: (-250000.0, 750000.0), (750000.0, 500000.0), (750000.0, 750000.0), (-250000.0, 500000.0)
  ∟val is 500000.0</code></pre><ul><li>Defining a Southern <code>OpenBoundary</code> with Float32 data using the <code>x0</code>, <code>xf</code>, <code>y0</code> and <code>yf</code> keywords.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; OpenBoundary(South, Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5)
OpenBoundary{South, Float32}
  ⊢polygon points are defined by the following set: (750000.0f0, 0.0f0), (750000.0f0, -250000.0f0), (-250000.0f0, 0.0f0), (-250000.0f0, -250000.0f0)
  ∟val is 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/boundaries.jl#L158-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.PeriodicBoundary" href="#Subzero.PeriodicBoundary"><code>Subzero.PeriodicBoundary</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PeriodicBoundary &lt;: AbstractBoundary</code></pre><p>A concrete subtype of <a href="#Subzero.AbstractBoundary"><code>AbstractBoundary</code></a> that moves a floe from one side of the domain to the opposite side of the domain (<a href="#Subzero.North"><code>North</code></a> to <a href="#Subzero.South"><code>South</code></a> and <a href="#Subzero.East"><code>East</code></a> to <a href="#Subzero.West"><code>West</code></a> and visa versa) when its centroid crosses the <code>PeriodicBoundary</code>, bringing the floe back into the domain. Due to this behavior, <code>PeriodicBoundary</code> pairs are required to form a valid domain.  This boundary is direction <code>D</code> (<a href="#Subzero.AbstractDirection"><code>AbstractDirection</code></a>) of the domain and has field data of type <code>FT &lt;: AbstractFloat</code>.</p><p><strong><em>Fields</em></strong></p><ul><li><code>poly::StaticQuadrilateral{FT}</code>: rectangular polygon representing <br/></li></ul><p>the shape and location of the boundary on a given timestep with points of float type <code>FT</code>.</p><ul><li><code>val::FT</code>: number of float type <code>FT</code> representing either the line <code>y = val</code> <br/></li></ul><p>(for <code>North</code> and <code>South</code> walls) or <code>x = val</code> (for <code>East</code> and <code>West</code> walls) that denotes the <br/>line marking the inner-most edge of the domain.</p><p>Here is how to construct an <code>PeriodicBoundary</code>:</p><pre><code class="nohighlight hljs">PeriodicBoundary(D, [FT = Float64]; grid  = nothing, x0 = nothing, xf = nothing, y0 = nothing, yf = nothing)</code></pre><p>The user must specify which <a href="#Subzero.AbstractDirection"><code>AbstractDirection</code></a> the boundary is. The user also has an opportunity to specify which float type <code>Float64</code> or <code>Float32</code> will be used for field data. The user then must either provide an grid object (<a href="#Subzero.AbstractRectilinearGrid"><code>AbstractRectilinearGrid</code></a>) for the domain to align with the grid edges, or provide four values (<code>x0</code>, <code>xf</code>, <code>y0</code>, and <code>yf</code>) that define the x and y-extents the user wants for the domain.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the user chooses to specify the domain extents, they still must be within the grid in order to make a valid <a href="#Model"><code>Model</code></a>.</p></div></div><p><strong><em>Positional arguments</em></strong></p><ul><li><code>D::Type{&lt;:AbstractDirection}</code>: subtype of AbstractDirection used to represent <br/></li></ul><p>if a boundary is the North, South, East, or West boundary of a simulation</p><ul><li><code>FT::Type{&lt;:AbstractFloat}</code>: Float type used to run the simulation, either <code>Float64</code> (default) or <code>Float32</code>.</li></ul><p><strong><em>Keyword arguments</em></strong></p><ul><li><code>grid::AbstractRectilinearGrid</code>: subtype of AbstractRectilinearGrid representing the grid used within a simulation</li><li><code>x0::FT</code>: minimum x-value of domain extent (region floes will be contained within)</li><li><code>xf::FT</code>: maximum x-value of domain extent (region floes will be contained within)</li><li><code>y0::FT</code>: minimum y-value of domain extent (region floes will be contained within)</li><li><code>yf::FT</code>: maximum y-value of domain extent (region floes will be contained within)</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The user must either provide a <code>grid</code> OR all four (4) of <code>x0</code>, <code>xf</code>, <code>y0</code>, and <code>yf</code>.</p></div></div><p><strong><em>Examples</em></strong></p><ul><li>Defining an Eastern <code>PeriodicBoundary</code> with Float32 data using the <code>grid</code> keyword.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; g = RegRectilinearGrid(Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);

julia&gt; PeriodicBoundary(East; grid = g)
PeriodicBoundary{East, Float64}
  ⊢polygon points are defined by the following set: (750000.0, -250000.0), (500000.0, -250000.0), (750000.0, 750000.0), (500000.0, 750000.0)
  ∟val is 500000.0</code></pre><ul><li>Defining a Western <code>PeriodicBoundary</code> with Float64 data using the <code>x0</code>, <code>xf</code>, <code>y0</code> and <code>yf</code> keywords.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; PeriodicBoundary(West, Float64; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5)
PeriodicBoundary{West, Float64}
  ⊢polygon points are defined by the following set: (0.0, -250000.0), (-250000.0, 750000.0), (0.0, 750000.0), (-250000.0, -250000.0)
  ∟val is 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/boundaries.jl#L245-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CollisionBoundary" href="#Subzero.CollisionBoundary"><code>Subzero.CollisionBoundary</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CollisionBoundary &lt;: AbstractBoundary</code></pre><p>A concrete subtype of <a href="#Subzero.AbstractBoundary"><code>AbstractBoundary</code></a> that calculates collision forces of a floe against the boundary if any of the floe&#39;s vertices overlap with the <code>CollisionBoundary</code>. This is meant to simulate any barrier that might stop a floe from flowing into or out of a given region, like the edges of a cove. With this type of wall, a <code>CollisionBoundary</code> is treated as an immovable, unbreakable floe for the purposes of calculations. This boundary is direction <code>D</code> (<a href="#Subzero.AbstractDirection"><code>AbstractDirection</code></a>) of the domain and has field data of type <code>FT &lt;: AbstractFloat</code>.</p><p><strong><em>Fields</em></strong></p><ul><li><code>poly::StaticQuadrilateral{FT}</code>: rectangular polygon representing <br/></li></ul><p>the shape and location of the boundary on a given timestep with points of float type <code>FT</code>.</p><ul><li><code>val::FT</code>: number of float type <code>FT</code> representing either the line <code>y = val</code> <br/></li></ul><p>(for <code>North</code> and <code>South</code> walls) or <code>x = val</code> (for <code>East</code> and <code>West</code> walls) that denotes the <br/>line marking the inner-most edge of the domain.</p><p>Here is how to construct an <code>CollisionBoundary</code>:</p><pre><code class="nohighlight hljs">CollisionBoundary(D, [FT = Float64]; grid  = nothing, x0 = nothing, xf = nothing, y0 = nothing, yf = nothing)</code></pre><p>The user must specify which <a href="#Subzero.AbstractDirection"><code>AbstractDirection</code></a> the boundary is. The user also has an opportunity to specify which float type <code>Float64</code> or <code>Float32</code> will be used for field data. The user then must either provide an grid object (<a href="#Subzero.AbstractRectilinearGrid"><code>AbstractRectilinearGrid</code></a>) for the domain to align with the grid edges, or provide four values (<code>x0</code>, <code>xf</code>, <code>y0</code>, and <code>yf</code>) that define the x and y-extents the user wants for the domain.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the user chooses to specify the domain extents, they still must be within the grid in order to make a valid <a href="#Model"><code>Model</code></a>.</p></div></div><p><strong><em>Positional arguments</em></strong></p><ul><li><code>D::Type{&lt;:AbstractDirection}</code>: subtype of AbstractDirection used to represent <br/></li></ul><p>if a boundary is the North, South, East, or West boundary of a simulation</p><ul><li><code>FT::Type{&lt;:AbstractFloat}</code>: Float type used to run the simulation, either <code>Float64</code> (default) or <code>Float32</code>.</li></ul><p><strong><em>Keyword arguments</em></strong></p><ul><li><code>grid::AbstractRectilinearGrid</code>: subtype of AbstractRectilinearGrid representing the grid used within a simulation</li><li><code>x0::FT</code>: minimum x-value of domain extent (region floes will be contained within)</li><li><code>xf::FT</code>: maximum x-value of domain extent (region floes will be contained within)</li><li><code>y0::FT</code>: minimum y-value of domain extent (region floes will be contained within)</li><li><code>yf::FT</code>: maximum y-value of domain extent (region floes will be contained within)</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The user must either provide a <code>grid</code> OR all four (4) of <code>x0</code>, <code>xf</code>, <code>y0</code>, and <code>yf</code>.</p></div></div><p><strong><em>Examples</em></strong></p><ul><li>Defining an Northern <code>CollisionBoundary</code> with Float64 data using the <code>grid</code> keyword.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; g = RegRectilinearGrid(Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);

julia&gt; CollisionBoundary(North; grid = g)
CollisionBoundary{North, Float64}
  ⊢polygon points are defined by the following set: (-250000.0, 750000.0), (750000.0, 500000.0), (750000.0, 750000.0), (-250000.0, 500000.0)
  ∟val is 500000.0</code></pre><ul><li>Defining a Western <code>CollisionBoundary</code> with Float64 data using the <code>x0</code>, <code>xf</code>, <code>y0</code> and <code>yf</code> keywords.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; CollisionBoundary(West, Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5)
CollisionBoundary{West, Float32}
  ⊢polygon points are defined by the following set: (0.0f0, -250000.0f0), (-250000.0f0, 750000.0f0), (0.0f0, 750000.0f0), (-250000.0f0, -250000.0f0)
  ∟val is 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/boundaries.jl#L332-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.MovingBoundary" href="#Subzero.MovingBoundary"><code>Subzero.MovingBoundary</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MovingBoundary &lt;: AbstractBoundary</code></pre><p>A concrete subtype of <a href="#Subzero.AbstractBoundary"><code>AbstractBoundary</code></a> that can provide a compressive or shear  force on the floes within the domain by moving parallel or perpendicular to the domain. The <code>MovingBoundary</code> calcuates the forces on the floe exactly the same as a <a href="#Subzero.CollisionBoundary"><code>CollisionBoundary</code></a>, by acting as a immovable, unbreakable floe. This boundary is direction <code>D</code> (<a href="#Subzero.AbstractDirection"><code>AbstractDirection</code></a>) of the domain and has field data of type <code>FT &lt;: AbstractFloat</code>.</p><p>If a <code>North</code> or <code>South</code> wall has a non-zero <code>v</code> velocity this will provide a compressive stress as the floe moves towards the center of the domain along the vector <code>x = cx</code> where <code>(cx, cy)</code> is the centroid of the domain (or decompresses with opposite sign velocities). The <code>poly</code> and  <code>val</code> fields are updated to represent the movement of the domain at the user-provided velocities, <code>u</code> and <code>v</code> m/s.</p><p>Alternatively, if a <code>North</code> or <code>South</code> wall has a non-zero <code>u</code> velocity this will provide a  shear stress as the domain &quot;moves&quot; along the line <code>y = y0</code> (for <code>North</code>) or <code>y = yf</code> (for South). In this case, this only changes the frictional forces and we do not need up actually change the <code>poly</code> or <code>val</code> fields.</p><p><strong><em>Fields</em></strong></p><ul><li><code>poly::StaticQuadrilateral{FT}</code>: rectangular polygon representing <br/></li></ul><p>the shape and location of the boundary on a given timestep with points of float type <code>FT</code>.</p><ul><li><code>val::FT</code>: number of float type <code>FT</code> representing either the line <code>y = val</code> <br/></li></ul><p>(for <code>North</code> and <code>South</code> walls) or <code>x = val</code> (for <code>East</code> and <code>West</code> walls) that denotes the <br/>line marking the inner-most edge of the domain.</p><ul><li><code>u::FT</code>: boundary&#39;s u-velocity</li><li><code>v::FT</code>: boundary&#39;s v-velocity</li></ul><p>Here is how to construct an <code>MovingBoundary</code>:</p><pre><code class="nohighlight hljs">MovingBoundary(D, [FT = Float64]; u = 0.0, v = 0.0, grid  = nothing, x0 = nothing, xf = nothing, y0 = nothing, yf = nothing)</code></pre><p>The user must specify which <a href="#Subzero.AbstractDirection"><code>AbstractDirection</code></a> the boundary is. The user also has an opportunity to specify which float type <code>Float64</code> or <code>Float32</code> will be used for field data. The user then must either provide an grid object (<a href="#Subzero.AbstractRectilinearGrid"><code>AbstractRectilinearGrid</code></a>) for the domain to align with the grid edges, or provide four values (<code>x0</code>, <code>xf</code>, <code>y0</code>, and <code>yf</code>) that define the x and y-extents the user wants for the domain.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the user chooses to specify the domain extents, they still must be within the grid in order to make a valid <a href="#Model"><code>Model</code></a>.</p></div></div><p><strong><em>Positional arguments</em></strong></p><ul><li><code>D::Type{&lt;:AbstractDirection}</code>: subtype of AbstractDirection used to represent <br/></li></ul><p>if a boundary is the North, South, East, or West boundary of a simulation</p><ul><li><code>FT::Type{&lt;:AbstractFloat}</code>: Float type used to run the simulation, either <code>Float64</code> (default) or <code>Float32</code>.</li></ul><p><strong><em>Keyword arguments</em></strong></p><ul><li><code>u::FT</code>: boundary&#39;s u-velocity</li><li><code>v::FT</code>: boundary&#39;s v-velocity</li><li><code>grid::AbstractRectilinearGrid</code>: subtype of AbstractRectilinearGrid representing the grid used within a simulation</li><li><code>x0::FT</code>: minimum x-value of domain extent (region floes will be contained within)</li><li><code>xf::FT</code>: maximum x-value of domain extent (region floes will be contained within)</li><li><code>y0::FT</code>: minimum y-value of domain extent (region floes will be contained within)</li><li><code>yf::FT</code>: maximum y-value of domain extent (region floes will be contained within)</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The user must either provide a <code>grid</code> OR all four (4) of <code>x0</code>, <code>xf</code>, <code>y0</code>, and <code>yf</code>. If the user does not provide values for <code>u</code> or <code>v</code>, the boundary will not move.</p></div></div><p><strong><em>Examples</em></strong></p><ul><li>Defining an Northern <code>MovingBoundary</code> with Float64 data using the <code>grid</code> keyword. Assigning u-velocity of 0.5m/s.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; g = RegRectilinearGrid(Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);

julia&gt; MovingBoundary(North; u = 0.5, grid = g)
MovingBoundary{North, Float64}
  ⊢polygon points are defined by the following set: (-250000.0, 750000.0), (750000.0, 500000.0), (750000.0, 750000.0), (-250000.0, 500000.0)
  ⊢val is 500000.0
  ⊢u-velocity of 0.5 m/s
  ∟v-velocity of 0.0 m/s</code></pre><ul><li>Defining a Southern <code>MovingBoundary</code> with Float32 data using the <code>x0</code>, <code>xf</code>, <code>y0</code> and <code>yf</code> keywords.</li></ul><p>Assigning u-velocity of 0.3 m/s and v-velocity of 0.25 m/s</p><pre><code class="language-julia-repl hljs">julia&gt; MovingBoundary(South, Float32; u = 0.3, v = 0.25, x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5)
MovingBoundary{South, Float32}
  ⊢polygon points are defined by the following set: (750000.0f0, 0.0f0), (750000.0f0, -250000.0f0), (-250000.0f0, 0.0f0), (-250000.0f0, -250000.0f0)
  ⊢val is 0.0
  ⊢u-velocity of 0.3 m/s
  ∟v-velocity of 0.25 m/s</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/boundaries.jl#L422-L502">source</a></section></article><h2 id="Topography"><a class="docs-heading-anchor" href="#Topography">Topography</a><a id="Topography-1"></a><a class="docs-heading-anchor-permalink" href="#Topography" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.TopographyElement" href="#Subzero.TopographyElement"><code>Subzero.TopographyElement</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TopographyElement{FT}&lt;:AbstractDomainElement{FT}</code></pre><p>A concrete subtype of <a href="@ref"><code>AbstractDomainElement</code></a> that represent topography in a given simulation. These <code>TopographyElement</code> objects will be treated as be treated as islands or coastline within the model in that they will not move or break due to floe interactions, but they will affect floes that collide with them. </p><p>Similar to <a href="@ref"><code>Floe</code></a> objects, we store the shape of each <code>TopographyElement</code> with a <code>poly</code> field. We also store the <code>centroid</code> and the shape&#39;s maximum radius (<code>rmax</code>) in order to calculate simple interaction checks with Floes.</p><p><strong><em>Fields</em></strong></p><ul><li><code>poly::Polys{FT}</code>: Polygon used to represent the shape of a floe or topography</li><li><code>centroid::Vector{FT}</code>: Two-element vector meant to represent the (x, y) point that is the centroid of either a floe or topography</li><li><code>rmax::FT</code>: Float length representing the maximum radius of a floe or topography from the centroid to any given vertex</li></ul><p>Here is how to construct an <code>TopographyElement</code>:</p><pre><code class="nohighlight hljs">TopographyElement([FT = Float64]; poly::Polys)</code></pre><p>The user must provide a <code>GeoInterface</code> polygon of the specific type defined by <code>Polys</code>. The user also has an opportunity to specify which float type <code>Float64</code> or <code>Float32</code> will be used for field data.</p><p><strong><em>Positional arguments</em></strong></p><ul><li><code>FT::Type{&lt;:AbstractFloat}</code>: Float type used to run the simulation, either <code>Float64</code> (default) or <code>Float32</code>.</li></ul><p><strong><em>Keyword arguments</em></strong></p><ul><li><code>poly::Polys{FT}</code>: Polygon used to represent the shape of a floe or topography</li></ul><p><strong><em>Note</em>: The user should <strong>NOT</strong> be using this constructor. The user should create a topography</strong></p><p>field using <a href="#Subzero.initialize_topography_field"><code>initialize_topography_field</code></a> rather than creating individual topography elements. This allows the abstraction of the use of the <code>StructArrays</code> package away from the user.</p><p><strong><em>Examples</em></strong></p><pre><code class="language-julia-repl hljs">julia&gt; import GeoInterface as GI;

julia&gt; poly = GI.Polygon([[(0.0, 0.0), (0.0, 1e3), (1e3, 1e3), (1e3, 0.0), (0.0, 0.0)]]);

julia&gt; TopographyElement(Float64; poly)
TopographyElement{Float64}
  ⊢centroid is (500.0, 500.0) in meters
  ∟maximum radius is 707.1067811865476 meters</code></pre><pre><code class="language-julia-repl hljs">julia&gt; TopographyElement(Float32; poly)
TopographyElement{Float32}
  ⊢centroid is (500.0, 500.0) in meters
  ∟maximum radius is 707.1068 meters</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/topography.jl#L11-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.initialize_topography_field" href="#Subzero.initialize_topography_field"><code>Subzero.initialize_topography_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_topography_field([::Type{FT} = Float64]; polys = nothing, coords = nothing)</code></pre><p>This function allows for easy initialization of a field of [<code>TopographyElement(@ref)s and collects them into a</code>StructArray<code>so that they can be passed into a [</code>Model`](@ref).</p><p>This is the suggested way to create a topography field for a simulation. Do NOT construct individual <code>TopographyElement</code> objects as that method does not correct the field as a whole to ensure no topography polygons overlap and does not create a struct array that can be passed to a <code>Model</code>.</p><p>The user can create a topography field by either passing a list of polygons or by passing a list of coordiantes, which will then be made into polygons.</p><p><strong><em>Positional arguments</em></strong></p><ul><li><code>FT::Type{&lt;:AbstractFloat}</code>: Float type used to run the simulation, either <code>Float64</code> (default) or <code>Float32</code>.</li></ul><p><strong><em>Keyword arguments</em></strong></p><ul><li><code>polys::Vector{&lt;:Polygon}</code>: list of polygons meant to represent a field of floes or topography elements. Polygons can be any polygon type that supports GeoInterface.</li><li><code>coords::Vector{&lt;:PolyVec}</code>: list of polygon coordinates meant to represent a field of floes or topography elements. PolyVec refers to a Vector{Vector{&lt;:Points}} where the points can be tuples, vectors, or static vectors and the innermost vector refers to each ring of the polygon.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Topography field elements must not be intersecting, so the corrections within this function may lead to a different number of polygons than input to make a valid topography field.</p></div></div><p><strong><em>Examples</em></strong></p><ul><li>Defining a topography field with coordinates</li></ul><pre><code class="language-julia-repl hljs">julia&gt; coords = [[[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (0.0, 0.0)]], [[(10.0, 0.0), (10.0, 1.0), (11.0, 1.0), (10.0, 0.0)]]];

julia&gt; initialize_topography_field(Float64; coords)
2-element TopographyField{Float64} list:
 TopographyElement{Float64}
  ⊢centroid is (0.3333333333333333, 0.6666666666666666) in meters
  ∟maximum radius is 0.74535599249993 meters
 TopographyElement{Float64}
  ⊢centroid is (10.333333333333334, 0.6666666666666666) in meters
  ∟maximum radius is 0.7453559924999301 meters</code></pre><ul><li>Defining a topography field with polygons</li></ul><pre><code class="language-julia-repl hljs">julia&gt; import GeoInterface as GI;

julia&gt; polys = [GI.Polygon(c) for c in coords];

julia&gt; initialize_topography_field(Float32; polys)
2-element TopographyField{Float32} list:
 TopographyElement{Float32}
  ⊢centroid is (0.33333334, 0.6666667) in meters
  ∟maximum radius is 0.745356 meters
 TopographyElement{Float32}
  ⊢centroid is (10.333333, 0.6666667) in meters
  ∟maximum radius is 0.74535626 meters</code></pre><ul><li>Creating an empty topography field without polys or coords</li></ul><pre><code class="language-julia-repl hljs">julia&gt; initialize_topography_field(Float64)
0-element TopographyField{Float64} list</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/topography.jl#L91-L153">source</a></section></article><h2 id="Domain"><a class="docs-heading-anchor" href="#Domain">Domain</a><a id="Domain-1"></a><a class="docs-heading-anchor-permalink" href="#Domain" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Domain" href="#Subzero.Domain"><code>Subzero.Domain</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Domain{FT, NB, SB, EB, WB, TT}</code></pre><p>A simulation <code>Domain</code> holds four (4) boundary elements (concrete subtypes of <a href="#Subzero.AbstractBoundary"><code>AbstractBoundary</code></a>) and a list (potentially empty) of <a href="#Subzero.TopographyElement"><code>TopographyElement</code></a> objects. There must be a wall typed by each cardinal direction, and each wall must hold data of the same float type <code>FT</code>. Additionally, the <a href="#Subzero.North"><code>North</code></a> boundary should be &quot;higher&quot; (on the y-axis) than the <a href="#Subzero.South"><code>South</code></a> boundary and the <a href="#Subzero.East"><code>East</code></a> should be futher to the &quot;right&quot; (on the x-axis) than the <a href="#Subzero.West"><code>West</code></a> boundary. Aditionally, the boundary walls should be overlapping as detailed in <a href="#Subzero.AbstractBoundary"><code>AbstractBoundary</code></a>.</p><p>Additionally, the set of walls must be periodically compatible. This means that pairs of opposite boundaries (<code>North</code> and <code>South</code> AND <code>East</code> and <code>West</code>) both need to be periodic if one of them is periodic. This is because if a floe exits a periodic boundary, it must be able to re-enter the opposite boundary to fulfill its definition of periodic.</p><p><strong><em>Fields</em></strong></p><ul><li><code>north::NB</code>: Northern boundary where <code>NB &lt;: AbstractBoundary{North, FT}</code></li><li><code>south::SB</code>: Southern boundary where <code>SB &lt;: AbstractBoundary{South, FT}</code></li><li><code>east::EB</code>: Eastern boundary where <code>EB &lt;: AbstractBoundary{East, FT}</code></li><li><code>west::WB</code>: Western boundary where <code>WB &lt;: AbstractBoundary{West, FT}</code></li><li><code>topography::tT</code>: Field of topography elements where <code>TT &lt;: TopographyField{FT}</code></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>All <code>FT</code> values above must be the same float type to form a valid domain.</li><li>The code depends on the boundaries forming a rectangle oriented along the cartesian grid. Other shapes/orientations are not supported at this time. </li></ul></div></div><p>Here is how to construct an <code>MovingBoundary</code>:</p><pre><code class="nohighlight hljs">Domain(; north::NB, south::SB, east::EB, west::WB, topography::TT = nothing)</code></pre><p>The user must provide the four (4) boundaries. They then have an option to provide topography. If no topography is provided, an empty <code>TopographyField</code> will be created with the same <code>FT</code> as the first of the boundaries (which should be shared amoung boundaries).</p><p><strong><em>Keyword arguments</em></strong></p><ul><li><code>north::NB</code>: domain&#39;s northern boundary</li><li><code>south::SB</code>: domain&#39;s southern boundary</li><li><code>east::EB</code>: domain&#39;s eastern boundary</li><li><code>west::WB</code>: domain&#39;s western boundary</li><li><code>topography::TT</code>: domain&#39;s topography field, if there is one, else an empty field is created</li></ul><p><strong><em>Examples</em></strong></p><ul><li>Creating a <code>Domain</code> with <em>NO</em> <code>topography</code></li></ul><pre><code class="language-julia-repl hljs">julia&gt; grid = RegRectilinearGrid(Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);

julia&gt; north = OpenBoundary(North, Float64; grid);

julia&gt; south = OpenBoundary(South, Float64; grid);

julia&gt; east = PeriodicBoundary(East, Float64; grid);

julia&gt; west = PeriodicBoundary(West, Float64; grid);

julia&gt; Domain(; north, south, east, west)
Domain
  ⊢Northern boundary of type OpenBoundary{North, Float64}
  ⊢Southern boundary of type OpenBoundary{South, Float64}
  ⊢Eastern boundary of type PeriodicBoundary{East, Float64}
  ⊢Western boundary of type PeriodicBoundary{West, Float64}
  ∟0-element TopograpahyElement{Float64} list</code></pre><ul><li>Creating a <code>Domain</code> with <code>topography</code></li></ul><pre><code class="language-julia-repl hljs">julia&gt; import GeoInterface as GI;

julia&gt; topo_polys = [GI.Polygon([[(1e4, 1e4), (1e4, 3e4), (3e4, 1e4), (1e4, 1e4)]]), GI.Polygon([[(8e4, 8e4), (8e4, 9e4), (9e4, 9e4), (9e4, 8e4), (8e4, 8e4)]])];

julia&gt; topography = initialize_topography_field(; polys = topo_polys);

julia&gt; Domain(; north, south, east, west, topography)
Domain
  ⊢Northern boundary of type OpenBoundary{North, Float64}
  ⊢Southern boundary of type OpenBoundary{South, Float64}
  ⊢Eastern boundary of type PeriodicBoundary{East, Float64}
  ⊢Western boundary of type PeriodicBoundary{West, Float64}
  ∟2-element TopograpahyElement{Float64} list</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/domains.jl#L36-L116">source</a></section></article><h2 id="Ocean"><a class="docs-heading-anchor" href="#Ocean">Ocean</a><a id="Ocean-1"></a><a class="docs-heading-anchor-permalink" href="#Ocean" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Ocean" href="#Subzero.Ocean"><code>Subzero.Ocean</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ocean{FT}</code></pre><p>Each simulation needs ocean values on the grid to drive the ice floes. The <code>Ocean</code> struct holds the needed fields to perform coupling, including vector fields (like u-velocity, v-velocity, x-stress, and y-stress) and tracer fields (like temperature, heatflux, and  dissolved ice mass). We also hold and calculate the sea ice fraction in any given grid cell.</p><p>Right now, all values are stored on grid points as defined by an <a href="#Subzero.AbstractRectilinearGrid"><code>AbstractRectilinearGrid</code></a>. This should eventually change to a c-grid. If interested in this change, see issue <a href="https://github.com/Caltech-OCTO/Subzero.jl/issues/30">#30</a>. This will require a big change in behavior, but is an important change for consistency and to match with Oceananigans for two-way coupling.</p><p>Coupling beyond velocity (for example thermodynamically) is not very well developed. If you are interested in working on this see issue <a href="https://github.com/Caltech-OCTO/Subzero.jl/issues/9">#9</a>. The <code>hflx_factor</code> field is related to thermodynamic coupling.</p><p><strong><em>Fields</em></strong></p><ul><li><code>u::Matrix{FT}</code>: ocean u-velocities in the x-direction on each grid point</li><li><code>v::Matrix{FT}</code>: ocean v-velocities in the y-direction on each grid point</li><li><code>temp::Matrix{FT}</code>: ocean temperature on each grid point</li><li><code>hflx_factor::Matrix{FT}</code>: factor to calculate the ocean-atmosphere heat flux for a grid cell</li><li><code>scells::Matrix{CellStresses}</code>: used to accumulate stresses on the ocean per grid cell from floes in cell (see <a href="#Subzero.CellStresses"><code>CellStresses</code></a>)</li><li><code>τx::Matrix{FT}</code>: stress on the ocean in the x-direction on each grid point</li><li><code>τy::Matrix{FT}</code>: stress on the ocean in the y-direction on each grid point</li><li><code>si_frac::Matrix{FT}</code>: fraction of area in each grid cell (centered on grid points) that is covered in sea-ice (between 0-1)</li><li><code>dissolved::Matrix{FT}</code>: total mass from ice floes dissolved in each grid cell (centered on grid points)</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If a periodic boundary is used in the domain, the last grid cell in that direction will not be used as it is equivalent to the first grid cell. Thus, for all of these fields, the first and last value in the x and/or y direction should be equal if the east-west or north-south boundary pair are periodic respectively. In the future, it might be worth having the ocean re-sizing to not included this repeated point dispatching off of the boundary types.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For each of the fields, the rows represent the <code>x</code>-values of the grid, while the columns represent the <code>y</code>-values of the grid. This makes it easy to index into the grid for a point <code>(x, y)</code>, although it does mean that the fields provided don&#39;t &quot;look&quot; like the grid if plotted directly and instead need to be transposed. </p></div></div><p>Here is how to construct an <code>Ocean</code>:</p><pre><code class="nohighlight hljs">Ocean([FT = Float64]; u, v, temp, grid = nothing)</code></pre><p><strong><em>Positional arguments</em></strong></p><ul><li><code>FT::Type{&lt;:AbstractFloat}</code>: Float type used to run the simulation, either <code>Float64</code> (default) or <code>Float32</code>.</li></ul><p><strong><em>Keyword arguments</em></strong></p><ul><li><code>u::Union{Real, Matrix{Real}}</code>: user can either provide a single u-velocity value (a constant field the size of the <code>grid</code> will be created) or provide a matrix field of  u-velocity values</li><li><code>v::Union{Real, Matrix{Real}}</code>: user can either provide a single v-velocity value (a constant field the size of the <code>grid</code> will be created) or provide a matrix field of v-velocity values</li><li><code>temp::Union{Real, Matrix{Real}}</code>: user can either provide a single temperature value (a constant field the size of the <code>grid</code> will be created) or provide a matrix field of temperature values</li><li><code>grid::AbstractRectilinearGrid</code>: subtype of AbstractRectilinearGrid representing the grid used within a simulation</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The user MUST provide <code>u</code>, <code>v</code>, and <code>temp</code>, although they have the option of these being <code>Real</code> values or <code>Matrix{&lt;:Real}</code>. If the user chooses to provide <code>Real</code> values for any of those fields, then a <code>grid</code> IS required to create a constant field of the correct size. If user chooses to provide a field, they should be of size <code>(grid.Nx + 1, grid.Ny + 1)</code> and the user doesn&#39;t require a <code>grid</code> input.</p></div></div><p><strong><em>Examples</em></strong></p><ul><li>Creating <code>Ocean</code> with constant <code>u</code>-velocity, <code>v-velocity</code>, and <code>temp</code></li></ul><pre><code class="language-julia-repl hljs">julia&gt; grid = RegRectilinearGrid(; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 10);

julia&gt; Ocean(; u = 0.5, v = 0.25, temp = 0.0, grid)
Ocean{Float64}
  ⊢Vector fields of dimension (21, 11)
  ⊢Tracer fields of dimension (21, 11)
  ⊢Average u-velocity of: 0.5 m/s
  ⊢Average v-velocity of: 0.25 m/s
  ∟Average temperature of: 0.0 C</code></pre><ul><li>Creating <code>Ocean</code> with user-defined <code>u</code> and <code>v</code> and a constant <code>temp</code> with <code>Float32</code> data</li></ul><pre><code class="language-julia-repl hljs">julia&gt; import Random.Xoshiro;

julia&gt; seeded_rng = Xoshiro(100);

julia&gt; u_field = rand(seeded_rng, grid.Nx + 1, grid.Ny + 1);

julia&gt; v_field = rand(seeded_rng, grid.Nx + 1, grid.Ny + 1);

julia&gt; Ocean(Float32; u = u_field, v = v_field, temp = 0.0, grid)
Ocean{Float32}
  ⊢Vector fields of dimension (21, 11)
  ⊢Tracer fields of dimension (21, 11)
  ⊢Average u-velocity of: 0.4856711 m/s
  ⊢Average v-velocity of: 0.5319979 m/s
  ∟Average temperature of: 0.0 C</code></pre><ul><li>Trying to create an <code>Ocean</code> with a constant field and NO grid</li></ul><pre><code class="language-julia-repl hljs">julia&gt; Ocean(; u = 0.2, v = 0.1, temp = 0.0)
ERROR: ArgumentError: To create a matrix from the constant value provided, you must provide a grid.
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/oceans.jl#L108-L206">source</a></section></article><h2 id="Atmosphere"><a class="docs-heading-anchor" href="#Atmosphere">Atmosphere</a><a id="Atmosphere-1"></a><a class="docs-heading-anchor-permalink" href="#Atmosphere" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Atmos" href="#Subzero.Atmos"><code>Subzero.Atmos</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Atmos{FT}</code></pre><p>Each simulation needs atmosphere/wind values on the grid to drive the ice floes. The <code>Atmos</code> struct holds the needed fields to perform coupling of vector fields (u-velocity and  v-velocity) and tracer fields (temperature).</p><p>Right now, all values are stored on grid points as defined by an <a href="#Subzero.AbstractRectilinearGrid"><code>AbstractRectilinearGrid</code></a>. This should eventually change to a c-grid. If interested in this change, see issue <a href="https://github.com/Caltech-OCTO/Subzero.jl/issues/30">#30</a>.</p><p>Coupling beyond velocity (for example thermodynamically) is not very well developed. If you are interested in working on this see issue <a href="https://github.com/Caltech-OCTO/Subzero.jl/issues/9">#9</a>. The <code>hflx_factor</code> field is related to thermodynamic coupling.</p><p><strong><em>Fields</em></strong></p><ul><li><code>u::Matrix{FT}</code>: atmosphere/wind u-velocities in the x-direction on each grid point</li><li><code>v::Matrix{FT}</code>: atmosphere/wind v-velocities in the y-direction on each grid point</li><li><code>temp::Matrix{FT}</code>: atmosphere/wind temperature on each grid point</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If a periodic boundary is used in the domain, the last grid cell in that direction will not be used as it is equivalent to the first grid cell. Thus, for all of these fields, the first and last value in the x and/or y direction should be equal if the east-west or north-south boundary pair are periodic respectively. In the future, it might be worth having the atmos re-sizing to not included this repeated point dispatching off of the boundary types.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For each of the fields, the rows represent the <code>x</code>-values of the grid, while the columns represent the <code>y</code>-values of the grid. This makes it easy to index into the grid for a point <code>(x, y)</code>, although it does mean that the fields provided don&#39;t &quot;look&quot; like the grid if plotted directly and instead need to be transposed. </p></div></div><p>Here is how to construct an <code>Atmos</code>:</p><pre><code class="nohighlight hljs">Atmos([FT = Float64]; u, v, temp, grid = nothing)</code></pre><p><strong><em>Positional arguments</em></strong></p><ul><li><code>FT::Type{&lt;:AbstractFloat}</code>: Float type used to run the simulation, either <code>Float64</code> (default) or <code>Float32</code>.</li></ul><p><strong><em>Keyword arguments</em></strong></p><ul><li><code>u::Union{Real, Matrix{Real}}</code>: user can either provide a single u-velocity value (a constant field the size of the <code>grid</code> will be created) or provide a matrix field of  u-velocity values</li><li><code>v::Union{Real, Matrix{Real}}</code>: user can either provide a single v-velocity value (a constant field the size of the <code>grid</code> will be created) or provide a matrix field of v-velocity values</li><li><code>temp::Union{Real, Matrix{Real}}</code>: user can either provide a single temperature value (a constant field the size of the <code>grid</code> will be created) or provide a matrix field of temperature values</li><li><code>grid::AbstractRectilinearGrid</code>: subtype of AbstractRectilinearGrid representing the grid used within a simulation</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The user MUST provide <code>u</code>, <code>v</code>, and <code>temp</code>, although they have the option of these being <code>Real</code> values or <code>Matrix{&lt;:Real}</code>. If the user chooses to provide <code>Real</code> values for any of those fields, then a <code>grid</code> IS required to create a constant field of the correct size. If user chooses to provide a field, they should be of size <code>(grid.Nx + 1, grid.Ny + 1)</code> and the user doesn&#39;t require a <code>grid</code> input.</p></div></div><p><strong><em>Examples</em></strong></p><ul><li>Creating <code>Atmos</code> with constant <code>u</code>-velocity, <code>v-velocity</code>, and <code>temp</code></li></ul><pre><code class="language-julia-repl hljs">julia&gt; grid = RegRectilinearGrid(; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 10);

julia&gt; Atmos(; u = 0.5, v = 0.25, temp = 0.0, grid)
Atmos{Float64}
  ⊢Vector fields of dimension (21, 11)
  ⊢Tracer fields of dimension (21, 11)
  ⊢Average u-velocity of: 0.5 m/s
  ⊢Average v-velocity of: 0.25 m/s
  ∟Average temperature of: 0.0 C</code></pre><ul><li>Creating <code>Atmos</code> with user-defined <code>u</code> and <code>v</code> and a constant <code>temp</code> with <code>Float32</code> data</li></ul><pre><code class="language-julia-repl hljs">julia&gt; import Random.Xoshiro;

julia&gt; seeded_rng = Xoshiro(200);

julia&gt; u_field = rand(seeded_rng, grid.Nx + 1, grid.Ny + 1);

julia&gt; v_field = rand(seeded_rng, grid.Nx + 1, grid.Ny + 1);

julia&gt; Atmos(Float32; u = u_field, v = v_field, temp = 0.0, grid)
Atmos{Float32}
  ⊢Vector fields of dimension (21, 11)
  ⊢Tracer fields of dimension (21, 11)
  ⊢Average u-velocity of: 0.4965465 m/s
  ⊢Average v-velocity of: 0.5340565 m/s
  ∟Average temperature of: 0.0 C</code></pre><ul><li>Trying to create an <code>Atmos</code> with a constant field and NO grid</li></ul><pre><code class="language-julia-repl hljs">julia&gt; Atmos(; u = 0.2, v = 0.1, temp = 0.0)
ERROR: ArgumentError: To create a matrix from the constant value provided, you must provide a grid.
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/atmos.jl#L18-L107">source</a></section></article><h3 id="Model"><a class="docs-heading-anchor" href="#Model">Model</a><a id="Model-1"></a><a class="docs-heading-anchor-permalink" href="#Model" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.Model" href="#Subzero.Model"><code>Subzero.Model</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Model which holds grid, ocean, atmos structs, each with the same underlying float type (either Float32 of Float64) and size. It also holds the domain information, which includes the topography and the boundaries. It holds a  StructArray of floe structs, again each relying on the same underlying float type. Finally, it also holds the maximum floe id used thus far in the simulation. This should be the length of the floes array at the beginning of the run. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/model.jl#L38-L46">source</a></section></article><h2 id="Developer-Used-Types"><a class="docs-heading-anchor" href="#Developer-Used-Types">Developer-Used Types</a><a id="Developer-Used-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-Used-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CellFloes" href="#Subzero.CellFloes"><code>Subzero.CellFloes</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CellFloes{FT}</code></pre><p>A <code>CellFloes</code> struct represents a single grid cell and accumulates the indices of floes with area in that grid cell. This is used to accumulate the forces of floes in a grid cell on the ocean below it. Due to the prevalence of periodic boundaries, the grid cell represented by a <code>CellFloes</code> object are centered on grid points (translated by <code>Δx/2</code> and <code>Δy/2</code> in the x and y directions for a <a href="#Subzero.RegRectilinearGrid"><code>RegRectilinearGrid</code></a>), rather than on the grid cells defined by the grid object itself. Floes are recorded with their index in the  list of floes. Furthermore, in a model with periodic boundaries, some floes may be in multiple grid cells on different edges of the domain if they pass through a periodic boundary. In these cases, the floe &quot;linked&quot; to with its index must be translated by a vector to get its &quot;ghost&quot; on the other side of the domain. This non-integer translation data is of float type <code>FT</code>. <code>CellFloes</code> are used with <a href="#Subzero.CellStresses"><code>CellStresses</code></a> objects, which aggregate the stress from each of the floes recorded in a given <code>CellFloes</code> object.</p><p><strong><em>Fields</em></strong></p><ul><li><code>floeidx</code>: see keyword arguments</li><li><code>Δx</code>: see keyword arguments</li><li><code>Δy</code>: see keyword arguments</li></ul><p>Here is how to construct a <code>CellFloes</code> object:</p><pre><code class="nohighlight hljs">CellFloes([FT = Float64]; floeidx = nothing, Δx = nothing, Δy = nothing)</code></pre><p><strong><em>Positional arguments</em></strong></p><ul><li><code>FT::Type{&lt;:AbstractFloat}</code>: Float type used to run the simulation, either <code>Float64</code> (default) or <code>Float32</code>.</li></ul><p><strong><em>Keyword arguments</em></strong></p><ul><li><code>floeidx::Vector{Int}</code>: vector of floe indicies in the list of model floes for floes with area in the grid</li><li><code>Δx::Vector{FT}</code>: vector of x-translations for a floe at the corresponding index of the</li></ul><p><code>floeidx</code> vector to be in the cell represented with the <code>CellFloes</code> object.</p><ul><li><code>Δy::Vector{FT}</code>: vector of y-translations for a floe at the corresponding index of the</li></ul><p><code>floeidx</code> vector to be in the cell represented with the <code>CellFloes</code> object.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If no keyword arguments are provide by the user, an <code>CellFloes</code> object with empty fields will be created. This is the <strong>standard useage</strong> of these objects and they are added to during the coupling step. If keyword arguments are provided, then all three must be provided and each vector must be the same size.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/grids.jl#L10-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.CellStresses" href="#Subzero.CellStresses"><code>Subzero.CellStresses</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CellStresses{FT}</code></pre><p>Struct to collect stress from ice floes on ocean grid cells. One <code>CellStresses</code> corresponds to one grid cell and is &quot;linked&quot; to a corresponding <a href="#Subzero.CellFloes"><code>CellFloes</code></a> object. The <code>CellFloes</code> object records which floes are in a given grid cell and the <code>CellStresses</code> aggregates the total stress felt on the ocean from the ice (on each of the floe&#39;s sub-floe points generated by a subtype of <a href="@ref"><code>AbstractSubFloePointsGenerator</code></a>) in a given grid cell. This is needed ONLY for two-way coupling. Due to the prevalence of periodic boundaries, the grid cell represented by a <code>CellStresses</code> object are centered on grid points (translated by <code>Δx/2</code> and <code>Δy/2</code> in the x and y directions for a <a href="#Subzero.RegRectilinearGrid"><code>RegRectilinearGrid</code></a>), rather than on the grid cells defined by the grid object itself. A <code>CellStresses</code> object holds a list of stresses on the ocean where each element is from a single floe within grid cell. The ith element of the <code>τx</code> and <code>τy</code> fields are measures of the total stress from the ith floe in the cell and the <code>npoints</code> field is a measure of how many of the ith floe&#39;s sub-floe points contributed to the running total of the stress. Again, each element in the list corresponds to one floe, which is denoted in the corresponding <a href="#Subzero.CellFloes"><code>CellFloes</code></a> matrix within the grid. </p><p><strong><em>Fields</em></strong></p><ul><li><code>τx::Vector{FT}</code>: list of total x-stress caused by each floe in a cell on the ocean</li><li><code>τy::Vector{FT}</code>: list of total y-stress caused by each floe in a cell on the ocean</li><li><code>npoints::Vector{Int}</code>: list of total number of sub-floe points contributing to each individial floe&#39;s stress</li></ul><p>Here is how to construct a <code>CellStresses</code> object:</p><pre><code class="nohighlight hljs">CellStresses([FT = Float64]; τx = nothing, τy = nothing, npoints = nothing)</code></pre><p><strong><em>Positional arguments</em></strong></p><ul><li><code>FT::Type{&lt;:AbstractFloat}</code>: Float type used to run the simulation, either <code>Float64</code> (default) or <code>Float32</code>.</li></ul><p><strong><em>Keyword arguments</em></strong></p><ul><li><code>τx::Vector{FT}</code>: list of total x-stress caused by each floe in a cell on the ocean</li><li><code>τy::Vector{FT}</code>: list of total y-stress caused by each floe in a cell on the ocean</li><li><code>npoints::Vector{Int}</code>: list of total number of sub-floe points contributing to each individial floe&#39;s stress</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If no keyword arguments are provide by the user, an <code>CellStresses</code> object with empty fields will be created. This is the <strong>standard useage</strong> of these objects and they are added to during the coupling step. If keyword arguments are provided, then all three must be provided and each vector must be the same size.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/oceans.jl#L10-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Subzero.TopographyField" href="#Subzero.TopographyField"><code>Subzero.TopographyField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TopographyField{FT}</code></pre><p>Alias for StructArray type with TopographyElement elements with data of type <code>FT</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is not designed to be used by users, but is useful for dispatch by developers. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/be0ed1000a50182864f90c26130bba26be9acf85/src/simulation_components/domain_components/topography.jl#L171-L178">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../contribute/">Contributing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Sunday 25 August 2024 15:40">Sunday 25 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
