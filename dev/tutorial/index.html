<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Subzero.jl</title><meta name="title" content="Tutorial · Subzero.jl"/><meta property="og:title" content="Tutorial · Subzero.jl"/><meta property="twitter:title" content="Tutorial · Subzero.jl"/><meta name="description" content="Documentation for Subzero.jl."/><meta property="og:description" content="Documentation for Subzero.jl."/><meta property="twitter:description" content="Documentation for Subzero.jl."/><meta property="og:url" content="https://Caltech-OCTO.github.io/SubzeroDocumentation/stable/tutorial/"/><meta property="twitter:url" content="https://Caltech-OCTO.github.io/SubzeroDocumentation/stable/tutorial/"/><link rel="canonical" href="https://Caltech-OCTO.github.io/SubzeroDocumentation/stable/tutorial/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Subzero.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Tutorial-copy-pasteable-version"><span>Tutorial - copy-pasteable version</span></a></li><li><a class="tocitem" href="#Core-ideas-behind-Subzero.jl-simulations"><span>Core ideas behind Subzero.jl simulations</span></a></li><li><a class="tocitem" href="#Creating-a-Grid"><span>Creating a Grid</span></a></li><li><a class="tocitem" href="#Creating-Boundaries"><span>Creating Boundaries</span></a></li><li><a class="tocitem" href="#Creating-Topography"><span>Creating Topography</span></a></li><li><a class="tocitem" href="#Creating-a-Domian"><span>Creating a Domian</span></a></li><li><a class="tocitem" href="#Creating-an-Ocean"><span>Creating an Ocean</span></a></li><li><a class="tocitem" href="#Creating-an-Atmosphere"><span>Creating an Atmosphere</span></a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><span class="tocitem">Improving Subzero</span><ul><li><a class="tocitem" href="../contribute/">Contributing</a></li><li><a class="tocitem" href="../devdocs/">Developer Documentation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Caltech-OCTO/Subzero.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Caltech-OCTO/Subzero.jl/blob/main/docs/literate/tutorial.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This is the user tutorial for Subzero.jl. It will walk you through the typical workflow of buidling a discrete-element model (DEM) with Subzero.jl as well as running and plotting your simulatuion.</p><h2 id="Tutorial-copy-pasteable-version"><a class="docs-heading-anchor" href="#Tutorial-copy-pasteable-version">Tutorial - copy-pasteable version</a><a id="Tutorial-copy-pasteable-version-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-copy-pasteable-version" title="Permalink"></a></h2><h2 id="Core-ideas-behind-Subzero.jl-simulations"><a class="docs-heading-anchor" href="#Core-ideas-behind-Subzero.jl-simulations">Core ideas behind Subzero.jl simulations</a><a id="Core-ideas-behind-Subzero.jl-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Core-ideas-behind-Subzero.jl-simulations" title="Permalink"></a></h2><p>The very first step of running a Subzero simulation is to bring the package into scope.</p><pre><code class="language-julia hljs">using Subzero  # bring Subzero into scope
using CairoMakie, GeoInterfaceMakie # bring plotting packages into scope
import GeoInterface as GI</code></pre><h2 id="Creating-a-Grid"><a class="docs-heading-anchor" href="#Creating-a-Grid">Creating a Grid</a><a id="Creating-a-Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-Grid" title="Permalink"></a></h2><p>Each Subzero model requires a grid object. The grid object defines the grid for the ocean and atmosphere. Ocean and atmosphere vectors (like <code>u</code> and <code>v</code> velocities) and tracers (like temperature) are recorded on these grid points and grid lines. The grid points are then used for interpolation for coupling between the ice, ocean, and atmosphere.</p><p>All Subzero grid objects are concrete types of the abstract type <a href="../api/#Subzero.AbstractRectilinearGrid"><code>AbstractRectilinearGrid</code></a>. Right now, all grid objects must be Rectilinear. Currently the only implemented concrete type is a <a href="../api/#Subzero.RegRectilinearGrid"><code>RegRectilinearGrid</code></a>. If you are interested in implementing another type of grid, see the <a href="&quot;devdocs.md&quot;">developer documentation</a>.</p><p>Here, we will go ahead and create an instance of <code>RegRectilinearGrid</code>. We need to specify the grid endpoints and either the number of grid cells in both directions, or the size of the grid cells. Here we will specity the number of grid cells in the x-direction, <code>Nx</code>, and in the y-direction, <code>Ny</code>.</p><pre><code class="language-julia hljs">grid = RegRectilinearGrid(; x0 = -1e5, xf = 1e5, y0 = 0.0, yf = 1e5, Nx = 20, Ny = 10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RegRectilinearGrid{Float64}
  ⊢x extent (-100000.0 to 100000.0) with 20 grid cells of size 10000.0 m
  ∟y extent (0.0 to 100000.0) with 10 grid cells of size 10000.0 m</code></pre><p>We plot a dashed box around the grid so that we can see the that the grid matches the extent given. We also place tick-marks at the desired grid cell lengths. Finally, set the plot&#39;s aspect ration to <code>2</code> as the x-extent is two-times larger than the y-extent.</p><pre><code class="language-julia hljs">fig = Figure();
ax1 = Axis(fig[1, 1];  # set up axis tick marks to match grid cells
    title = &quot;Grid Setup&quot;,
    xticks = range(grid.x0, grid.xf, 5), xminorticks = IntervalsBetween(5),
    xminorticksvisible = true, xminorgridvisible = true, xticklabelrotation = pi/4,
    yticks = range(grid.y0, grid.yf, 3), yminorticks = IntervalsBetween(5),
    yminorticksvisible = true, yminorgridvisible = true,
)
lines!(  # plot boundary of grid with a dashed line
    [grid.x0, grid.x0, grid.xf, grid.xf, grid.x0],  # point x-values
    [grid.y0, grid.yf, grid.yf, grid.y0, grid.y0];  # point y-values
    linestyle = :dash, linewidth = 3.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MakieCore.Lines{Tuple{Vector{GeometryBasics.Point{2, Float64}}}}</code></pre><p>Resize grid to layout</p><pre><code class="language-julia hljs">colsize!(fig.layout, 1, Aspect(1, 2))
resize_to_layout!(fig)
fig  # display the figure</code></pre><img src="380ff316.png" alt="Example block output"/><h2 id="Creating-Boundaries"><a class="docs-heading-anchor" href="#Creating-Boundaries">Creating Boundaries</a><a id="Creating-Boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Boundaries" title="Permalink"></a></h2><p>Next, each Subzero.jl model needs a <code>Domain</code>. A <code>Domain</code> defines the region of the grid that the ice floes are allowed in, what happens to them when they reach the boundaries of that region, and if there is any topography in the model, along with the ice, in that region.</p><p>Similarly to the <code>grid</code> above, the <code>Domain</code> will be rectilinear, defined by four boundaries, one for each of the cardinal direction. You will be able to pass each of the cardinal directions (<a href="../api/#Subzero.North"><code>North</code></a>, <a href="../api/#Subzero.South"><code>South</code></a>, <a href="../api/#Subzero.East"><code>East</code></a>, and <a href="../api/#Subzero.West"><code>West</code></a>), defined as types by Subzero, to the boundary constructors. Each boundary can have different behavior, allowing the user to create a wide variety of domain behavior. Right now, four types of <code>AbstractBoundaries</code> are implemented: <a href="../api/#Subzero.OpenBoundary"><code>OpenBoundary</code></a>, <a href="../api/#Subzero.PeriodicBoundary"><code>PeriodicBoundary</code></a>, <a href="../api/#Subzero.CollisionBoundary"><code>CollisionBoundary</code></a>, and <a href="../api/#Subzero.MovingBoundary"><code>MovingBoundary</code></a>.</p><p>In this example, we will use two <code>CollisionBoundary</code> walls and two <code>PeriodicBoundary</code> walls to create a channel that the ice can infinitly flow through, from the east back to the west. In the north and the south, the ice will collide with the boundaries, as if there was shoreline preventing it from leaving the channel.</p><p>We will use the grid we made above to define the boundaries so that they exactly border the grid.</p><pre><code class="language-julia hljs">north_bound = CollisionBoundary(North; grid)
south_bound = CollisionBoundary(South; grid)
east_bound = PeriodicBoundary(East; grid)
west_bound = PeriodicBoundary(West; grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PeriodicBoundary{West, Float64}
  ⊢polygon points are defined by the following set: (-100000.0, 150000.0), (-100000.0, -50000.0), (-200000.0, 150000.0), (-200000.0, -50000.0)
  ∟val is -100000.0</code></pre><p>If we plot the polygons that are created within each boundary object, we can see that they border the grid. These polygons are how we well when the ice floes are interacting with each of the boundaries. We can also see that the boundaries overlap in the corners to ensure there is a solid border around the grid. The <code>PeriodicBoundary</code> elements are in purple while the <code>CollisionBoundary</code> elements are in teal.</p><pre><code class="language-julia hljs">poly!(   # plot each of the boundaries with a 50% transparent color so we can see the overlap
    [north_bound.poly, south_bound.poly, east_bound.poly, west_bound.poly];
    color = [(:purple, 0.5), (:purple, 0.5), (:teal, 0.5), (:teal, 0.5)],
)
ax1.title = &quot;Grid and Boundary Setup&quot;
fig  # display the figure</code></pre><img src="29cb306c.png" alt="Example block output"/><h2 id="Creating-Topography"><a class="docs-heading-anchor" href="#Creating-Topography">Creating Topography</a><a id="Creating-Topography-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Topography" title="Permalink"></a></h2><p>We then have the option to add in a <a href="../api/#Subzero.TopographyField"><code>TopographyField</code></a>, which is a collection of <a href="../api/#Subzero.TopographyElement"><code>TopographyElement</code></a>s. If we want to add in topography field, we can create one using the <a href="../api/#Subzero.initialize_topography_field"><code>initialize_topography_field</code></a> function. Here we will create two islands in the channel. For simplcity, both will be triangles. I create the polygons that define the shape of each island using <a href="https://github.com/JuliaGeo/GeoInterface.jl"><code>GeoInterface</code></a> and defining the points with tuples:</p><pre><code class="language-julia hljs">island1 = GI.Polygon([[(-6e4, 7.5e4), (-4e4, 5e4), (-2.5e4, 7e4), (-6e4, 7.5e4)]])
island2 = GI.Polygon([[(5e4, 2.5e4), (5e4, 5.5e4), (7.5e4, 3e4), (5e4, 2.5e4)]])
topo_list = [island1, island2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}}, Nothing, Nothing}}:
 GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}}, Nothing, Nothing}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}([(-60000.0, 75000.0), (-40000.0, 50000.0), (-25000.0, 70000.0), (-60000.0, 75000.0)], nothing, nothing)], nothing, nothing)
 GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}}, Nothing, Nothing}(GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}[GeoInterface.Wrappers.LinearRing{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}([(50000.0, 25000.0), (50000.0, 55000.0), (75000.0, 30000.0), (50000.0, 25000.0)], nothing, nothing)], nothing, nothing)</code></pre><p>We can then pass these to <code>initialize_topography_field</code> with the <code>polys</code> keyword. We could also have defined them just by their coordinates and passed in the coordiantes by the <code>coords</code> keyword.</p><pre><code class="language-julia hljs">topo_field = initialize_topography_field(; polys = topo_list)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element TopographyField{Float64} list:
 TopographyElement{Float64}
  ⊢centroid is (-41666.666666666664, 65000.0) in meters
  ∟maximum radius is 20883.27347690278 meters
 TopographyElement{Float64}
  ⊢centroid is (58333.333333333336, 36666.666666666664) in meters
  ∟maximum radius is 20138.409955990955 meters</code></pre><p>We can now plot the topography within the domain.</p><pre><code class="language-julia hljs">topo_color = RGBf(115/255, 93/255, 55/255)  # brown color for topography
poly!(topo_field.poly; color = topo_color) # plot the topography
ax1.title = &quot;Grid and Domain Setup&quot;
fig  # display the figure</code></pre><img src="89d01735.png" alt="Example block output"/><h2 id="Creating-a-Domian"><a class="docs-heading-anchor" href="#Creating-a-Domian">Creating a Domian</a><a id="Creating-a-Domian-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-Domian" title="Permalink"></a></h2><p>We now have all of the pieces needed to create a <a href="../api/#Domain"><code>Domain</code></a>. We will combine the four (4) boundaries we created, and the topography, into one <code>Domain</code> object. The collection of boundaries and topography define where the floes can and cannot go in the simulation and add in boundary behavior.We can do that as follows:</p><pre><code class="language-julia hljs">domain = Domain(; north = north_bound, south = south_bound, east = east_bound, west = west_bound, topography = topo_field)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Domain
  ⊢Northern boundary of type CollisionBoundary{North, Float64}
  ⊢Southern boundary of type CollisionBoundary{South, Float64}
  ⊢Eastern boundary of type PeriodicBoundary{East, Float64}
  ⊢Western boundary of type PeriodicBoundary{West, Float64}
  ∟2-element TopograpahyElement{Float64} list</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We could have skipped adding the topography to the domain. That is an optional   keyword and an empty <code>topography</code> field will be automatically created if the user does not   provide one.</p></div></div><p>At this point, we have already plotted all of the <code>Domain</code> objects, so we will move in to adding environmental forcing from the ocean and the atmosphere.</p><h2 id="Creating-an-Ocean"><a class="docs-heading-anchor" href="#Creating-an-Ocean">Creating an Ocean</a><a id="Creating-an-Ocean-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-Ocean" title="Permalink"></a></h2><p>We can provide a ocean velocity and temperature fields to drive the floes within the simulatation. By default, this is a static vector field and does not change throughout the simulation. However, if you are interested in updating the code to make it easier to update the ocean/atmosphere fields throughout the simulation please see issue <a href="https://github.com/Caltech-OCTO/Subzero.jl/issues/111">#111</a>.</p><p>You can either provide a single constant value for each of the fields (and then also provide the <code>grid</code> as input) or provide a user-defined field. If providing a user-defined field, the field should be of size <code>(grid.Nx + 1, grid.Ny + 1)</code>. The rows represent velocities at the <code>x</code>-values of the grid (from <code>x0</code> to <code>xf</code>), while the columns represent velocities at the the <code>y</code>-values of the grid (from <code>y0</code> to <code>yf</code>). This makes it easy to index into the grid for values at point <code>(x, y)</code>. If <code>x</code> is the <code>i</code>th x-value between <code>x0</code> to <code>xf</code> and <code>y</code> is the <code>j</code>the <code>j</code>th y-value between <code>y0</code> to <code>yf</code> then you simply retrive the field values at index <code>[i, j]</code>. This does mean that the fields provided don&#39;t &quot;look&quot; like the grid when output directly in the terminal and would need to be transposed instead.</p><p>Here we will then define a <code>u</code>-velocity field that will impose a shear flow on the floes so that ocean is flowing faster in the middle of the y-values (at 0.25 m/s) and then symetrically slowing to 0m/s at the edges where the <code>CollisionBoundary</code> elements are. We will then provide a constant <code>temp</code>erature of -1 C and a constant <code>v</code>-velocity of 0m/s.</p><pre><code class="language-julia hljs">function shear_flow(Nx, Ny, min_u, max_u)
    increasing = true
    curr_u = min_u
    Δu = fld(Nx, 2)  # divide Nx by 2 and round down
    u_vals = zeros(Nx, Ny)
    for (i, col) in enumerate(eachcol(u_vals))
        (i == 1 || i == Ny) &amp;&amp; continue  # edges already set to 0m/s
        col .= curr_u
        if increasing &amp;&amp; curr_u == max_u  # reach max value and start decreasing velocity
            increasing = false
        end
        if increasing  # update velocity for next column
            curr_u += Δu
        else
            curr_u -= Δu
        end
    end
    return curr_u
end

u_vals = shear_flow(grid.Nx + 1, grid.Ny + 1, 0.0, 0.25)
ocean = Ocean(; u = u_vals, v = 0.0, temp = -1.0, grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Ocean{Float64}
  ⊢Vector fields of dimension (21, 11)
  ⊢Tracer fields of dimension (21, 11)
  ⊢Average u-velocity of: 90.0 m/s
  ⊢Average v-velocity of: 0.0 m/s
  ∟Average temperature of: -1.0 C</code></pre><p>We can now plot our ocean velocity values on an axis below our <code>grid</code> and <code>domain</code> setup.</p><pre><code class="language-julia hljs">ax2 = Axis(fig[2, 1]; title = &quot;Ocean U-Velocities [m/s]&quot;, xticklabelrotation = pi/4)
xs = grid.x0:grid.Δx:grid.xf
ys = grid.y0:grid.Δy:grid.yf
u_hm = heatmap!(ax2, xs, ys, ocean.u)
Colorbar(fig[2, end+1], u_hm)
resize_to_layout!(fig)
fig</code></pre><img src="a6d34a2b.png" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <a href="https://docs.makie.org/v0.21/reference/plots/heatmap"><code>heatmap</code></a>   already transposes the matrix input, assuming, as we do, that you index into the   matrix with x-values for rows and y-values for columns. If you want to see your   input as it would look on the grid, rather than manually transposing, just use the   <code>heatmap</code> function.</p></div></div><p>Since the other ocean fields are constant values for each index, we won&#39;t plot these.</p><h2 id="Creating-an-Atmosphere"><a class="docs-heading-anchor" href="#Creating-an-Atmosphere">Creating an Atmosphere</a><a id="Creating-an-Atmosphere-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-Atmosphere" title="Permalink"></a></h2><p>The atmosphere works almost iddntically to the <code>Ocean</code>. It also requires inputs for <code>u</code>-velocities, <code>v</code>-velocities, and <code>temp</code>erature and these fields are considered static throughtout the simulation by default. Again, if you are interested in changing this, please see issue <a href="https://github.com/Caltech-OCTO/Subzero.jl/issues/111">#111</a>.</p><p>Just like with the <code>Ocean</code> constructor, you can either provide the <code>Atmos</code> constructor a single constant value for each of the fields (and then also provide the grid as input) or provide a user-defined field.</p><p>Here, we will just provide constant values of 5m/s for the <code>u</code>-velocities, 0.0m/s for the <code>v</code>-velocities and 0 C for the <code>temp</code>erature. If you are intersted in providing non-constant fields, see the <code>Ocean</code> example above.</p><pre><code class="language-julia hljs">atmos = Atmos(; grid, u = 5.0, v = 0.0, temp = 0.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Atmos{Float64}
  ⊢Vector fields of dimension (21, 11)
  ⊢Tracer fields of dimension (21, 11)
  ⊢Average u-velocity of: 5.0 m/s
  ⊢Average v-velocity of: 0.0 m/s
  ∟Average temperature of: 0.0 C</code></pre><p>Again since all of the fields are constant, we won&#39;t plot them, but you can, using the <code>heatmap</code> function as shown above.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 26 September 2024 20:58">Thursday 26 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
