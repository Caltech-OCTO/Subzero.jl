var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = Subzero","category":"page"},{"location":"api/#Full-Subzero-API-documentation","page":"API Reference","title":"Full Subzero API documentation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"warning: Warning\nThis page is still very much WIP!","category":"page"},{"location":"api/#Grids","page":"API Reference","title":"Grids","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AbstractRectilinearGrid\nRegRectilinearGrid","category":"page"},{"location":"api/#Subzero.AbstractRectilinearGrid","page":"API Reference","title":"Subzero.AbstractRectilinearGrid","text":"YourGridType{FT} <: AbstractRectilinearGrid{FT}\n\nEach simulation run with Subzero.jl must be run on a grid. A grid defines the points at which the ocean and atmosphere hold velocity data, as well as various other tracers, at grid points. The user must choose an existing subtype of AbstractRectilinearGrid or implement a new subtype to create a simulation. \n\nEach grid implementation must define the number and dimensions of each grid cell. Right now, this assumes that the ocean and the atmosphere are on the same grid and that the grid is rectangular. We might not want this to be true in the future. Furthermore, each concrete implementation of AbstractRectilinearGrid that will be used to two-way couple with an ocean or an atmosphere must have a field called floe_locations that is a matrix of CellFloes, with one element for each grid point. The user should not worry about CellFloes, this is up to the developer to make sure that their grid contains and populates this field. Again, in the future, this might be related to the ocean and/or atmosphere rather than the grid. For more information, or if you're interested in working on this, see issue #107.\n\nAPI\n\nThe following methods must be implemented for all subtypes:\n\n_get_grid_extent(grid::AbstractRectilinearGrid): \n\nThe _get_grid_extent function takes in a concrete subtype of AbstractRectilinearGrid and returns the grid's minimum x-value, maximum x-value, minimum y-value, and maximum y-value.\n\nGiven the original code was written for RegRectilinearGrid objects, the dispatch isn't fully implemented and other functions should be added to this list. If you were interested in adding a new subtype of AbstractRectilinearGrid, see  issue #108.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.RegRectilinearGrid","page":"API Reference","title":"Subzero.RegRectilinearGrid","text":"RegRectilinearGrid{FT} <: AbstractRectilinearGrid{FT}\n\nA concrete implementation of an AbstractRectilinearGrid that represents a tessellation of 2-dimensional Euclidean space into n-by-m congruent rectangles. Fields that hold float data are of type FT, a concrete subtype of AbstractFloat.\n\nNx::Int: number of grid cells in the x-direction\nNy::Int: number of grid cells in the y-direction\nÎ”x::FT: grid cell width\nÎ”y::FT: grid cell height\nx0::FT: value of first x grid line\nxf::FT: value of final x grid line\ny0::FT: value of first y grid line\nyf::FT: value of final y grid line\nfloe_locations::Matrix{CellFloes}: Nx + 1 by Ny + 1 matrix of CellFloes\n\nHere is how to construct a RegRectilinearGrid:\n\nRegRectilinearGrid([FT = Float64]; x0, xf, y0, yf, Nx = nothing, Ny = nothing, Î”x = nothing, Î”y = nothing)\n\nPositional arguments\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\nx0::FT: value of first x grid line\nxf::FT: value of final x grid line\ny0::FT: value of first y grid line\nyf::FT: value of final y grid line\nNx::Int: number of grid cells in the x-direction\nNy::Int: number of grid cells in the y-direction\nÎ”x::FT: grid cell width\nÎ”y::FT: grid cell height\n\nNote: the user MUST provide x0, xf, y0, and yf; the user then has the choice to provide Nx and Ny OR Î”x and Î”y. If provided Î”x doesn't evenly divide length xf-x0 or Î”y doesn't evenly divide yf-y0, you won't get full size grid. The grid will be \"trimmed\" to the nearest full grid square in both directions.\n\nExamples\n\nDefining a RegRectilinearGrid using Nx and Ny.\n\njulia> grid = RegRectilinearGrid(; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 10)\nRegRectilinearGrid{Float64}\n  âŠ¢x extent (0.0 to 500000.0) with 20 grid cells of size 25000.0 m\n  âˆŸy extent (0.0 to 500000.0) with 10 grid cells of size 50000.0 m\n\nDefining a RegRectilinearGrid using Î”x and Î”y.\n\njulia> grid = RegRectilinearGrid(Float32; x0 = -5e5, xf = 5e5, y0 = 0.0, yf = 5e5, Î”x = 5e4, Î”y = 5e4)\nRegRectilinearGrid{Float32}\n  âŠ¢x extent (-500000.0 to 500000.0) with 20 grid cells of size 50000.0 m\n  âˆŸy extent (0.0 to 500000.0) with 10 grid cells of size 50000.0 m\n\nError due to attemping to define a RegRectilinearGrid using Î”x and Ny.\n\njulia> grid = RegRectilinearGrid(; x0 = -5e5, xf = 5e5, y0 = 0.0, yf = 5e5, Î”x = 5e4, Ny = 10)\nERROR: ArgumentError: To create a RegRectilinearGrid, either provide Î”x and Î”y OR Nx and Ny.\n[...]\n\n\n\n\n\n","category":"type"},{"location":"api/#Directions","page":"API Reference","title":"Directions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AbstractDirection\nNorth\nSouth\nEast\nWest","category":"page"},{"location":"api/#Subzero.AbstractDirection","page":"API Reference","title":"Subzero.AbstractDirection","text":"YourDirection <: AbstractDirection\n\nEach domain within a Subzero.jl Model must have four (4) boundaries (subtypes of AbstractBoundary) where each of these boundaries is parametrically typed by the direction of the boundary. The user will first choose one of the four cardinal directions, the subtypes of AbstractDirection:\n\nNorth\nSouth\nEast\nWest\n\nThis abstract type is not meant to be extended by the user, unless the user wants to move away from a rectangular domain with assigned cardinal directions for each wall. This would a more major redesign and the user should check out the developer documentation.\n\n_API\n\n_boundary_info_from_extent(D::Type{AbstractDirection}, FT::Type{AbstractFloat}, x0, xf, y0, yf)\n\nThe _boundary_info_from_extent function finds the values for the poly and val fields of a subtype of AbstractBoundary of direction D given a region of the extent defined by x0, xf, y0, and yf given that these are the minimum and maximum x and y values of the region desired. The returned extent will have values of type FT.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.North","page":"API Reference","title":"Subzero.North","text":"North<:AbstractDirection\n\nA simple subtype of AbstractDirection used for parametrically typing a subtype of AbstractBoundary if that boundary is the northern boundary in a rectangular domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.South","page":"API Reference","title":"Subzero.South","text":"South<:AbstractDirection\n\nA simple subtype of AbstractDirection used for parametrically typing a subtype of AbstractBoundary if that boundary is the southern boundary in a rectangular domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.East","page":"API Reference","title":"Subzero.East","text":"East<:AbstractDirection\n\nA simple subtype of AbstractDirection used for parametrically typing a subtype of AbstractBoundary if that boundary is the eastern boundary in a rectangular domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.West","page":"API Reference","title":"Subzero.West","text":"West<:AbstractDirection\n\nA simple subtype of AbstractDirection used for parametrically typing a subtype of AbstractBoundary if that boundary is the western boundary in a rectangular domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Boundaries","page":"API Reference","title":"Boundaries","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AbstractBoundary\nOpenBoundary\nPeriodicBoundary\nCollisionBoundary\nMovingBoundary","category":"page"},{"location":"api/#Subzero.AbstractBoundary","page":"API Reference","title":"Subzero.AbstractBoundary","text":"AbstractBoundary{D, FT} <: AbstractDomainElement{FT}\n\nWhen running a Subzero simulation, each simulation has a rectangular domain that contains the ice pack. This domain is made up for four boundaries, one in each of the cardinal directions: North, South, East, and West. The user will pick four boundary types, each concrete subtypes of AbstractBoundary and assign each of them a direction, D and a float type FT, by typing them parametrically. \n\nThe user can pick from the currently implemented concrete subtypes of AbstractBoundary (OpenBoundary, CollisionBoundary, PeriodicBoundary, and MovingBoundary) or implement their own.\n\nFor now, each boundary wall is assumed to be a rectangle. For correct behavior, the corners of each of the boundary rectangles should overlap to make sure that no floes reach outside of the domain without touching a boundary. These rectangles should be represented as polygons with the poly field within each boundary. Furthermore, each boundary should have a val field that represents either the line y = val (for North and South walls) or x = val (for East and West walls) that denotes the line that marks the \"inner-most\" edge of the domain. If an ice floe passes over the boundary's val line, the floe interacts with the boundary.\n\n ________________\n|__|____val___|__| <- North coordinates include corners\n|  |          |  |\n|  |          |  | <- East and west coordinates ALSO include corners\n|  |          |  |\n\nFor ease of use, each boundary should have a constructor option where the user can provide an AbstractRectilinearGrid concrete type to define a boundary where val is at the edge of the grid so that the boundaries form a border right around the grid.\n\nAPI\n\nIn addition to the below function, any new AbstractBoundary subtype must also implement AbstractDomainElement API functions.\n\n_update_boundary!(boundary::AbstractBoundary, Î”t::Int)\n_periodic_compat(boundary1::AbstractBoundary, boundary2::AbstractBoundary)\n\nThe _update_boundary! function updates a boundary's position (by changing the val and poly fields) at every timestep. Currently, only MovingBoundary elements are updated, and their update depends on the length of the simulation's timestep, Î”t.\n\nThe _periodic_compat function determines if a pair of functions are \"periodically compatible\",  that is, could they form a pair on opposite edges of a domain to create a set of functioning periodic boundaries. It is called when creating a Domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.OpenBoundary","page":"API Reference","title":"Subzero.OpenBoundary","text":"OpenBoundary{D, FT} <: AbstractBoundary{D, FT}\n\nA concrete subtype of AbstractBoundary that removes a floe from the simulation if any of the floe's vertices overlap with the OpenBoundary. This is meant to simulate the floe floating out of the simulation. The floe is immeditaly removed as there might not be ocean u and v values outside of the domian and thus we wouldn't know how to evolve the floe's trajectory. This boundary is direction D (AbstractDirection) of the domain and has field data of type FT <: AbstractFloat.\n\nFields\n\npoly::StaticQuadrilateral{FT}: rectangular polygon representing \n\n\nthe shape and location of the boundary on a given timestep with points of float type FT.\n\nval::FT: number of float type FT representing either the line y = val \n\n\n(for North and South walls) or x = val (for East and West walls) that denotes the \nline marking the inner-most edge of the domain.\n\nHere is how to construct an OpenBoundary:\n\nOpenBoundary(D, [FT = Float64]; grid  = nothing, x0 = nothing, xf = nothing, y0 = nothing, yf = nothing)\n\nThe user must specify which AbstractDirection the boundary is. The user also has an opportunity to specify which float type Float64 or Float32 will be used for field data. The user then must either provide an grid object (AbstractRectilinearGrid) for the domain to align with the grid edges, or provide four values (x0, xf, y0, and yf) that define the x and y-extents the user wants for the domain. Note: if the user chooses to specify the domain extents, they still must be within the grid in order to make a valid Model.\n\nPositional arguments\n\nD::Type{<:AbstractDirection}: subtype of AbstractDirection used to represent \n\n\nif a boundary is the North, South, East, or West boundary of a simulation\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\ngrid::AbstractRectilinearGrid: subtype of AbstractRectilinearGrid representing the grid used within a simulation\nx0::FT: minimum x-value of domain extent (region floes will be contained within)\nxf::FT: maximum x-value of domain extent (region floes will be contained within)\ny0::FT: minimum y-value of domain extent (region floes will be contained within)\nyf::FT: maximum y-value of domain extent (region floes will be contained within)\n\nNote: the user must either provide a grid OR all four (4) of x0, xf, y0, and yf.\n\nExamples\n\nDefining a Northern OpenBoundary with Float64 (default type) data using the grid keyword.\n\njulia> g = RegRectilinearGrid(x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);\n\njulia> OpenBoundary(North; grid = g)\nOpenBoundary{North, Float64}\n  âŠ¢polygon points are defined by the following set: (-250000.0, 750000.0), (750000.0, 500000.0), (750000.0, 750000.0), (-250000.0, 500000.0)\n  âˆŸval is 500000.0\n\nDefining a Southern OpenBoundary with Float32 data using the x0, xf, y0 and yf keywords.\n\njulia> OpenBoundary(South, Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5)\nOpenBoundary{South, Float32}\n  âŠ¢polygon points are defined by the following set: (750000.0f0, 0.0f0), (750000.0f0, -250000.0f0), (-250000.0f0, 0.0f0), (-250000.0f0, -250000.0f0)\n  âˆŸval is 0.0\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.PeriodicBoundary","page":"API Reference","title":"Subzero.PeriodicBoundary","text":"PeriodicBoundary <: AbstractBoundary\n\nA concrete subtype of AbstractBoundary that moves a floe from one side of the domain to the opposite side of the domain (North to South and East to West and visa versa) when its centroid crosses the PeriodicBoundary, bringing the floe back into the domain. Due to this behavior, PeriodicBoundary pairs are required to form a valid domain.  This boundary is direction D (AbstractDirection) of the domain and has field data of type FT <: AbstractFloat.\n\nFields\n\npoly::StaticQuadrilateral{FT}: rectangular polygon representing \n\n\nthe shape and location of the boundary on a given timestep with points of float type FT.\n\nval::FT: number of float type FT representing either the line y = val \n\n\n(for North and South walls) or x = val (for East and West walls) that denotes the \nline marking the inner-most edge of the domain.\n\nHere is how to construct an PeriodicBoundary:\n\nPeriodicBoundary(D, [FT = Float64]; grid  = nothing, x0 = nothing, xf = nothing, y0 = nothing, yf = nothing)\n\nThe user must specify which AbstractDirection the boundary is. The user also has an opportunity to specify which float type Float64 or Float32 will be used for field data. The user then must either provide an grid object (AbstractRectilinearGrid) for the domain to align with the grid edges, or provide four values (x0, xf, y0, and yf) that define the x and y-extents the user wants for the domain. Note: if the user chooses to specify the domain extents, they still must be within the grid in order to make a valid Model.\n\nPositional arguments\n\nD::Type{<:AbstractDirection}: subtype of AbstractDirection used to represent \n\n\nif a boundary is the North, South, East, or West boundary of a simulation\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\ngrid::AbstractRectilinearGrid: subtype of AbstractRectilinearGrid representing the grid used within a simulation\nx0::FT: minimum x-value of domain extent (region floes will be contained within)\nxf::FT: maximum x-value of domain extent (region floes will be contained within)\ny0::FT: minimum y-value of domain extent (region floes will be contained within)\nyf::FT: maximum y-value of domain extent (region floes will be contained within)\n\nNote: the user must either provide a grid OR all four (4) of x0, xf, y0, and yf.\n\nExamples\n\nDefining an Eastern PeriodicBoundary with Float32 data using the grid keyword.\n\njulia> g = RegRectilinearGrid(Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);\n\njulia> PeriodicBoundary(East; grid = g)\nPeriodicBoundary{East, Float64}\n  âŠ¢polygon points are defined by the following set: (750000.0, -250000.0), (500000.0, -250000.0), (750000.0, 750000.0), (500000.0, 750000.0)\n  âˆŸval is 500000.0\n\nDefining a Western PeriodicBoundary with Float64 data using the x0, xf, y0 and yf keywords.\n\njulia> PeriodicBoundary(West, Float64; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5)\nPeriodicBoundary{West, Float64}\n  âŠ¢polygon points are defined by the following set: (0.0, -250000.0), (-250000.0, 750000.0), (0.0, 750000.0), (-250000.0, -250000.0)\n  âˆŸval is 0.0\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.CollisionBoundary","page":"API Reference","title":"Subzero.CollisionBoundary","text":"CollisionBoundary <: AbstractBoundary\n\nA concrete subtype of AbstractBoundary that calculates collision forces of a floe against the boundary if any of the floe's vertices overlap with the CollisionBoundary. This is meant to simulate any barrier that might stop a floe from flowing into or out of a given region, like the edges of a cove. With this type of wall, a CollisionBoundary is treated as an immovable, unbreakable floe for the purposes of calculations. This boundary is direction D (AbstractDirection) of the domain and has field data of type FT <: AbstractFloat.\n\nFields\n\npoly::StaticQuadrilateral{FT}: rectangular polygon representing \n\n\nthe shape and location of the boundary on a given timestep with points of float type FT.\n\nval::FT: number of float type FT representing either the line y = val \n\n\n(for North and South walls) or x = val (for East and West walls) that denotes the \nline marking the inner-most edge of the domain.\n\nHere is how to construct an CollisionBoundary:\n\nCollisionBoundary(D, [FT = Float64]; grid  = nothing, x0 = nothing, xf = nothing, y0 = nothing, yf = nothing)\n\nThe user must specify which AbstractDirection the boundary is. The user also has an opportunity to specify which float type Float64 or Float32 will be used for field data. The user then must either provide an grid object (AbstractRectilinearGrid) for the domain to align with the grid edges, or provide four values (x0, xf, y0, and yf) that define the x and y-extents the user wants for the domain. Note: if the user chooses to specify the domain extents, they still must be within the grid in order to make a valid Model.\n\nPositional arguments\n\nD::Type{<:AbstractDirection}: subtype of AbstractDirection used to represent \n\n\nif a boundary is the North, South, East, or West boundary of a simulation\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\ngrid::AbstractRectilinearGrid: subtype of AbstractRectilinearGrid representing the grid used within a simulation\nx0::FT: minimum x-value of domain extent (region floes will be contained within)\nxf::FT: maximum x-value of domain extent (region floes will be contained within)\ny0::FT: minimum y-value of domain extent (region floes will be contained within)\nyf::FT: maximum y-value of domain extent (region floes will be contained within)\n\nNote: the user must either provide a grid OR all four (4) of x0, xf, y0, and yf.\n\nExamples\n\nDefining an Northern CollisionBoundary with Float64 data using the grid keyword.\n\njulia> g = RegRectilinearGrid(Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);\n\njulia> CollisionBoundary(North; grid = g)\nCollisionBoundary{North, Float64}\n  âŠ¢polygon points are defined by the following set: (-250000.0, 750000.0), (750000.0, 500000.0), (750000.0, 750000.0), (-250000.0, 500000.0)\n  âˆŸval is 500000.0\n\nDefining a Western CollisionBoundary with Float64 data using the x0, xf, y0 and yf keywords.\n\njulia> CollisionBoundary(West, Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5)\nCollisionBoundary{West, Float32}\n  âŠ¢polygon points are defined by the following set: (0.0f0, -250000.0f0), (-250000.0f0, 750000.0f0), (0.0f0, 750000.0f0), (-250000.0f0, -250000.0f0)\n  âˆŸval is 0.0\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.MovingBoundary","page":"API Reference","title":"Subzero.MovingBoundary","text":"MovingBoundary <: AbstractBoundary\n\nA concrete subtype of AbstractBoundary that can provide a compressive or shear  force on the floes within the domain by moving parallel or perpendicular to the domain. The MovingBoundary calcuates the forces on the floe exactly the same as a CollisionBoundary, by acting as a immovable, unbreakable floe. This boundary is direction D (AbstractDirection) of the domain and has field data of type FT <: AbstractFloat.\n\nIf a North or South wall has a non-zero v velocity this will provide a compressive stress as the floe moves towards the center of the domain along the vector x = cx where (cx, cy) is the centroid of the domain (or decompresses with opposite sign velocities). The poly and  val fields are updated to represent the movement of the domain at the user-provided velocities, u and v m/s.\n\nAlternatively, if a North or South wall has a non-zero u velocity this will provide a  shear stress as the domain \"moves\" along the line y = y0 (for North) or y = yf (for South). In this case, this only changes the frictional forces and we do not need up actually change the poly or val fields.\n\nFields\n\npoly::StaticQuadrilateral{FT}: rectangular polygon representing \n\n\nthe shape and location of the boundary on a given timestep with points of float type FT.\n\nval::FT: number of float type FT representing either the line y = val \n\n\n(for North and South walls) or x = val (for East and West walls) that denotes the \nline marking the inner-most edge of the domain.\n\nu::FT: boundary's u-velocity\nv::FT: boundary's v-velocity\n\nHere is how to construct an MovingBoundary:\n\nMovingBoundary(D, [FT = Float64]; u = 0.0, v = 0.0, grid  = nothing, x0 = nothing, xf = nothing, y0 = nothing, yf = nothing)\n\nThe user must specify which AbstractDirection the boundary is. The user also has an opportunity to specify which float type Float64 or Float32 will be used for field data. The user then must either provide an grid object (AbstractRectilinearGrid) for the domain to align with the grid edges, or provide four values (x0, xf, y0, and yf) that define the x and y-extents the user wants for the domain. Note: if the user chooses to specify the domain extents, they still must be within the grid in order to make a valid Model.\n\nPositional arguments\n\nD::Type{<:AbstractDirection}: subtype of AbstractDirection used to represent \n\n\nif a boundary is the North, South, East, or West boundary of a simulation\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\nu::FT: boundary's u-velocity\nv::FT: boundary's v-velocity\ngrid::AbstractRectilinearGrid: subtype of AbstractRectilinearGrid representing the grid used within a simulation\nx0::FT: minimum x-value of domain extent (region floes will be contained within)\nxf::FT: maximum x-value of domain extent (region floes will be contained within)\ny0::FT: minimum y-value of domain extent (region floes will be contained within)\nyf::FT: maximum y-value of domain extent (region floes will be contained within)\n\nNote: the user must either provide a grid OR all four (4) of x0, xf, y0, and yf. If the user does not provide values for u or v, the boundary will not move.\n\nExamples\n\nDefining an Northern MovingBoundary with Float64 data using the grid keyword. Assigning u-velocity of 0.5m/s.\n\njulia> g = RegRectilinearGrid(Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);\n\njulia> MovingBoundary(North; u = 0.5, grid = g)\nMovingBoundary{North, Float64}\n  âŠ¢polygon points are defined by the following set: (-250000.0, 750000.0), (750000.0, 500000.0), (750000.0, 750000.0), (-250000.0, 500000.0)\n  âŠ¢val is 500000.0\n  âŠ¢u-velocity of 0.5 m/s\n  âˆŸv-velocity of 0.0 m/s\n\nDefining a Southern MovingBoundary with Float32 data using the x0, xf, y0 and yf keywords.\n\nAssigning u-velocity of 0.3 m/s and v-velocity of 0.25 m/s\n\njulia> MovingBoundary(South, Float32; u = 0.3, v = 0.25, x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5)\nMovingBoundary{South, Float32}\n  âŠ¢polygon points are defined by the following set: (750000.0f0, 0.0f0), (750000.0f0, -250000.0f0), (-250000.0f0, 0.0f0), (-250000.0f0, -250000.0f0)\n  âŠ¢val is 0.0\n  âŠ¢u-velocity of 0.3 m/s\n  âˆŸv-velocity of 0.25 m/s\n\n\n\n\n\n","category":"type"},{"location":"api/#Topography","page":"API Reference","title":"Topography","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"TopographyElement\ninitialize_topography_field","category":"page"},{"location":"api/#Subzero.TopographyElement","page":"API Reference","title":"Subzero.TopographyElement","text":"TopographyElement{FT}<:AbstractDomainElement{FT}\n\nA concrete subtype of AbstractDomainElement that represent topography in a given simulation. These TopographyElement objects will be treated as be treated as islands or coastline within the model in that they will not move or break due to floe interactions, but they will affect floes that collide with them. \n\nSimilar to Floe objects, we store the shape of each TopographyElement with a poly field. We also store the centroid and the shape's maximum radius (rmax) in order to calculate simple interaction checks with Floes.\n\nFields\n\npoly::Polys{FT}: Polygon used to represent the shape of a floe or topography\ncentroid::Vector{FT}: Two-element vector meant to represent the (x, y) point that is the centroid of either a floe or topography\nrmax::FT: Float length representing the maximum radius of a floe or topography from the centroid to any given vertex\n\nHere is how to construct an TopographyElement:\n\nTopographyElement([FT = Float64]; poly::Polys)\n\nThe user must provide a GeoInterface polygon of the specific type defined by Polys. The user also has an opportunity to specify which float type Float64 or Float32 will be used for field data.\n\nPositional arguments\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\npoly::Polys{FT}: Polygon used to represent the shape of a floe or topography\n\nNote: The user should NOT be using this constructor. The user should create a topography\n\nfield using initialize_topography_field rather than creating individual topography elements. This allows the abstraction of the use of the StructArrays package away from the user.\n\nExamples\n\njulia> import GeoInterface as GI;\n\njulia> poly = GI.Polygon([[(0.0, 0.0), (0.0, 1e3), (1e3, 1e3), (1e3, 0.0), (0.0, 0.0)]]);\n\njulia> TopographyElement(Float64; poly)\nTopographyElement{Float64}\n  âŠ¢centroid is (500.0, 500.0) in meters\n  âˆŸmaximum radius is 707.1067811865476 meters\n\njulia> TopographyElement(Float32; poly)\nTopographyElement{Float32}\n  âŠ¢centroid is (500.0, 500.0) in meters\n  âˆŸmaximum radius is 707.1068 meters\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.initialize_topography_field","page":"API Reference","title":"Subzero.initialize_topography_field","text":"initialize_topography_field([::Type{FT} = Float64]; polys = nothing, coords = nothing)\n\nThis function allows for easy initialization of a field of [TopographyElement(@ref)s and collects them into aStructArrayso that they can be passed into a [Model`](@ref).\n\nThis is the suggested way to create a topography field for a simulation. Do NOT construct individual TopographyElement objects as that method does not correct the field as a whole to ensure no topography polygons overlap and does not create a struct array that can be passed to a Model.\n\nThe user can create a topography field by either passing a list of polygons or by passing a list of coordiantes, which will then be made into polygons.\n\nPositional arguments\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\npolys::Vector{<:Polygon}: list of polygons meant to represent a field of floes or topography elements. Polygons can be any polygon type that supports GeoInterface.\ncoords::Vector{<:PolyVec}: list of polygon coordinates meant to represent a field of floes or topography elements. PolyVec refers to a Vector{Vector{<:Points}} where the points can be tuples, vectors, or static vectors and the innermost vector refers to each ring of the polygon.\n\nNote: Topography field elements must not be intersecting, so the corrections within this function may lead to more polygons than input to make a valid topography field.\n\nExamples\n\nDefining a topography field with coordinates\n\njulia> coords = [[[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (0.0, 0.0)]], [[(10.0, 0.0), (10.0, 1.0), (11.0, 1.0), (10.0, 0.0)]]];\n\njulia> initialize_topography_field(Float64; coords)\n2-element TopographyField{Float64} list:\n TopographyElement{Float64}\n  âŠ¢centroid is (0.3333333333333333, 0.6666666666666666) in meters\n  âˆŸmaximum radius is 0.74535599249993 meters\n TopographyElement{Float64}\n  âŠ¢centroid is (10.333333333333334, 0.6666666666666666) in meters\n  âˆŸmaximum radius is 0.7453559924999301 meters\n\nDefining a topography field with polygons\n\njulia> import GeoInterface as GI;\n\njulia> polys = [GI.Polygon(c) for c in coords];\n\njulia> initialize_topography_field(Float32; polys)\n2-element TopographyField{Float32} list:\n TopographyElement{Float32}\n  âŠ¢centroid is (0.33333334, 0.6666667) in meters\n  âˆŸmaximum radius is 0.745356 meters\n TopographyElement{Float32}\n  âŠ¢centroid is (10.333333, 0.6666667) in meters\n  âˆŸmaximum radius is 0.74535626 meters\n\nCreating an empty topography field without polys or coords\n\njulia> initialize_topography_field(Float64)\n0-element TopographyField{Float64} list\n\n\n\n\n\n","category":"function"},{"location":"api/#Domain","page":"API Reference","title":"Domain","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Domain","category":"page"},{"location":"api/#Subzero.Domain","page":"API Reference","title":"Subzero.Domain","text":"Domain{FT, NB, SB, EB, WB, TT}\n\nA simulation Domain holds four (4) boundary elements (concrete subtypes of AbstractBoundary) and a list (potentially empty) of TopographyElement objects. There must be a wall typed by each cardinal direction, and each wall must hold data of the same float type FT. Additionally, the North boundary should be \"higher\" (on the y-axis) than the South boundary and the East should be futher to the \"right\" (on the x-axis) than the West boundary. Aditionally, the boundary walls should be overlapping as detailed in AbstractBoundary.\n\nAdditionally, the set of walls must be periodically compatible. This means that pairs of opposite boundaries (North and South AND East and West) both need to be periodic if one of them is periodic. This is because if a floe exits a periodic boundary, it must be able to re-enter the opposite boundary to fulfill its definition of periodic.\n\nFields\n\nnorth::NB: Northern boundary where NB <: AbstractBoundary{North, FT}\nsouth::SB: Southern boundary where SB <: AbstractBoundary{South, FT}\neast::EB: Eastern boundary where EB <: AbstractBoundary{East, FT}\nwest::WB: Western boundary where WB <: AbstractBoundary{West, FT}\ntopography::tT: Field of topography elements where TT <: TopographyField{FT}\n\nNotes:\n\nAll FT values above must be the same float type to form a valid domain.\nThe code depends on the boundaries forming a rectangle oriented along the\n\ncartesian grid. Other shapes/orientations are not supported at this time. \n\nHere is how to construct an MovingBoundary:\n\nDomain(; north::NB, south::SB, east::EB, west::WB, topography::TT = nothing)\n\nThe user must provide the four (4) boundaries. They then have an option to provide topography. If no topography is provided, an empty TopographyField will be created with the same FT as the first of the boundaries (which should be shared amoung boundaries).\n\nKeyword arguments\n\nnorth::NB: domain's northern boundary\nsouth::SB: domain's southern boundary\neast::EB: domain's eastern boundary\nwest::WB: domain's western boundary\ntopography::TT: domain's topography field, if there is one, else an empty field is created\n\nExamples\n\nCreating a Domain with NO topography\n\njulia> grid = RegRectilinearGrid(Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);\n\njulia> north = OpenBoundary(North, Float64; grid);\n\njulia> south = OpenBoundary(South, Float64; grid);\n\njulia> east = PeriodicBoundary(East, Float64; grid);\n\njulia> west = PeriodicBoundary(West, Float64; grid);\n\njulia> Domain(; north, south, east, west)\nDomain\n  âŠ¢Northern boundary of type OpenBoundary{North, Float64}\n  âŠ¢Southern boundary of type OpenBoundary{South, Float64}\n  âŠ¢Eastern boundary of type PeriodicBoundary{East, Float64}\n  âŠ¢Western boundary of type PeriodicBoundary{West, Float64}\n  âˆŸ0-element TopograpahyElement{Float64} list\n\nCreating a Domain with topography\n\njulia> import GeoInterface as GI;\n\njulia> topo_polys = [GI.Polygon([[(1e4, 1e4), (1e4, 3e4), (3e4, 1e4), (1e4, 1e4)]]), GI.Polygon([[(8e4, 8e4), (8e4, 9e4), (9e4, 9e4), (9e4, 8e4), (8e4, 8e4)]])];\n\njulia> topography = initialize_topography_field(; polys = topo_polys);\n\njulia> Domain(; north, south, east, west, topography)\nDomain\n  âŠ¢Northern boundary of type OpenBoundary{North, Float64}\n  âŠ¢Southern boundary of type OpenBoundary{South, Float64}\n  âŠ¢Eastern boundary of type PeriodicBoundary{East, Float64}\n  âŠ¢Western boundary of type PeriodicBoundary{West, Float64}\n  âˆŸ2-element TopograpahyElement{Float64} list\n\n\n\n\n\n","category":"type"},{"location":"api/#Model","page":"API Reference","title":"Model","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Model","category":"page"},{"location":"api/#Subzero.Model","page":"API Reference","title":"Subzero.Model","text":"Model which holds grid, ocean, atmos structs, each with the same underlying float type (either Float32 of Float64) and size. It also holds the domain information, which includes the topography and the boundaries. It holds a  StructArray of floe structs, again each relying on the same underlying float type. Finally, it also holds the maximum floe id used thus far in the simulation. This should be the length of the floes array at the beginning of the run. \n\n\n\n\n\n","category":"type"},{"location":"api/#Developer-Used-Types","page":"API Reference","title":"Developer-Used Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"CellFloes\nTopographyField","category":"page"},{"location":"api/#Subzero.CellFloes","page":"API Reference","title":"Subzero.CellFloes","text":"CellFloes([FT = Float64]; floeidx, Î”x, Î”y)\n\nConstructor for struct that represents a single grid cell and accumulates the indices of floes with area in that grid cell. This is used for two-way coupling to accumulate the forces of floes in a grid cell on the ocean below it. Due to the prevalence of periodic boundaries, the grid cell represented by a CellFloes object are centered on grid points (translated by Î”x/2 and Î”y/2 in the x and y directions for a RegRectilinearGrid), rather than on the grid cells defined by the grid object itself. Floes are recorded with their index in the  list of floes. Furthermore, in a model with periodic boundaries, some floes may be in multiple grid cells on different edges of the domain if they pass through a periodic boundary. In these cases, the floe \"linked\" to with its index must be translated by a vector to get its \"ghost\" on the other side of the domain. This mon-integer translation data is of float type FT.\n\nNote: If no keyword arguments are provide by the user, an CellFloes object with empty fields will be created. This is the standard useage of these objects and they are added to during the coupling step. If keyword arguments are provided, then all three must be provided and each vector must be the same size.\n\nPositional arguments\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\nfloeidx::Vector{Int}: vector of floe indicies in the list of model floes for floes with area in the grid\nÎ”x::Vector{FT}: vector of x-translations for a floe at the corresponding index of the\n\nfloeidx vector to be in the cell represented with the CellFloes object.\n\nÎ”y::Vector{FT}: vector of y-translations for a floe at the corresponding index of the\n\nfloeidx vector to be in the cell represented with the CellFloes object.\n\nCellFloes Fields\n\nfloeidx: see keyword arguments\nÎ”x: see keyword arguments\nÎ”y: see keyword arguments\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.TopographyField","page":"API Reference","title":"Subzero.TopographyField","text":"TopographyField{FT}\n\nAlias for StructArray type with TopographyElement elements with data of type FT. Note: this is not designed to be used by users, but is useful for dispatch by developers. \n\n\n\n\n\n","category":"type"},{"location":"","page":"Introduction","title":"Introduction","text":"Subzero","category":"page"},{"location":"#Subzero","page":"Introduction","title":"Subzero","text":"(Image: Subzero.jl)\n\n(Image: Docs) (Image: CI) (Image: CodeCov) (Image: Status)\n\nFast and Flexible Sea Ice Dynamics\n\nSubzero.jl is a native Julia discrete-element model (DEM) for exploring fine-scale sea ice dynamics,  reimplementing and enhancing MATLAB model SubZero by Manucharyan and Montemuro.\n\nðŸš€ Runs over 35 times faster that original MATLAB model for title simulation!\nðŸ§© Modular simulation model makes it easy to customize simulations!\nEnable and disable physical processes such as fracturing, ridging, and welding\nChoose algorithms for key processes (or add your own!)\n\nDocumentation\n\nTo learn how to build and run simulations, check out our documentation and tutorials!\n\nInstallation\n\nSubzero is a registered Julia package. So to install it,\n\nDownload Julia (version 1.9 or later).\nLaunch Julia and type\n\njulia> using Pkg\n\njulia> Pkg.add(\"Subzero\")\n\nCiting\n\nIf you use Subzero.jl as part of your research, teaching, or other activities, we would be grateful if you could cite our work. We are currently working on a JOSS paper, which will be linked here. If you are ready to publish before that, please reach out to us to discuss citations.\n\nContributing\n\nIf youâ€™re interested in contributing to the development Subzero, we would love to have you! We welcome all kinds of contributions from bug reports, to documentation, to features, and suggestions. We can't wait to talk to you.\n\nPlease check out our contributers' guide for more details.\n\nAuthors\n\nPrimary Author: Skylar Gering (@skygering)\n\nThe list of Subzero contributors:\n\n(Image: Contributers)\n\n\n\n\n\n","category":"module"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"../literate/tutorial.jl\"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is the user tutorial for Subzero.jl. It will walk you through the typical workflow of buidling a discrete-element model (DEM) with Subzero.jl as well as running and plotting your simulatuion.","category":"page"},{"location":"tutorial/#Tutorial-copy-pasteable-version","page":"Tutorial","title":"Tutorial - copy-pasteable version","text":"","category":"section"},{"location":"tutorial/#Core-ideas-behind-Subzero.jl-simulations","page":"Tutorial","title":"Core ideas behind Subzero.jl simulations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The very first step of running a Subzero simulation is to bring the package into scope.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Subzero  # bring Subzero into scope\nusing CairoMakie, GeoInterfaceMakie # bring plotting packages into scope\nimport GeoInterface as GI","category":"page"},{"location":"tutorial/#Creating-a-Grid","page":"Tutorial","title":"Creating a Grid","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Each Subzero model requires a grid object. The grid object defines the grid for the ocean and atmosphere. Ocean and atmosphere vectors (like u and v velocities) and tracers (like temperature) are recorded on these grid points and grid lines. The grid points are then used for interpolation for coupling between the ice, ocean, and atmosphere.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"All Subzero grid objects are concrete types of the abstract type AbstractRectilinearGrid. Right now, all grid objects must be Rectilinear. Currently the only implemented concrete type is a RegRectilinearGrid. If you are interested in implementing another type of grid, see the developer documentation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, we will go ahead and create an instance of RegRectilinearGrid. We need to specify the grid endpoints and either the number of grid cells in both directions, or the size of the grid cells. Here we will specity the number of grid cells in the x-direction, Nx, and in the y-direction, Ny.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"grid = RegRectilinearGrid(; x0 = -1e5, xf = 1e5, y0 = 0.0, yf = 1e5, Nx = 20, Ny = 10)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We plot a dashed box around the grid so that we can see the that the grid matches the extent given. We also place tick-marks at the desired grid cell lengths. Finally, set the plot's aspect ration to 2 as the x-extent is two-times larger than the y-extent.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fig = Figure();\nAxis(fig[1, 1];  # set up axis tick marks to match grid cells\n    xticks = range(grid.x0, grid.xf, 5), xminorticks = IntervalsBetween(5),\n    xminorticksvisible = true, xminorgridvisible = true,\n    yticks = range(grid.y0, grid.yf, 3), yminorticks = IntervalsBetween(5),\n    yminorticksvisible = true, yminorgridvisible = true,\n)\nlines!(  # plot boundary of grid with a dashed line\n    [grid.x0, grid.x0, grid.xf, grid.xf, grid.x0],  # point x-values\n    [grid.y0, grid.yf, grid.yf, grid.y0, grid.y0];  # point y-values\n    linestyle = :dash, linewidth = 3.0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Resize grid to layout","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"colsize!(fig.layout, 1, Aspect(1, 2))\nresize_to_layout!(fig)\nfig  # display the figure","category":"page"},{"location":"tutorial/#Creating-Boundaries","page":"Tutorial","title":"Creating Boundaries","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, each Subzero.jl model needs a Domain. A Domain defines the region of the grid that the ice floes are allowed in, what happens to them when they reach the boundaries of that region, and if there is any topography in the model, along with the ice, in that region.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly to the grid above, the Domain will be rectilinear, defined by four boundaries, one for each of the cardinal direction. You will be able to pass each of the cardinal directions (North, South, East, and West), defined as types by Subzero, to the boundary constructors. Each boundary can have different behavior, allowing the user to create a wide variety of domain behavior. Right now, four types of AbstractBoundaries are implemented: OpenBoundary, PeriodicBoundary, CollisionBoundary, and MovingBoundary.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this example, we will use two CollisionBoundary walls and two PeriodicBoundary walls to create a channel that the ice can infinitly flow through, from the east back to the west. In the north and the south, the ice will collide with the boundaries, as if there was shoreline preventing it from leaving the channel.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will use the grid we made above to define the boundaries so that they exactly border the grid.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"north_bound = CollisionBoundary(North; grid)\nsouth_bound = CollisionBoundary(South; grid)\neast_bound = PeriodicBoundary(East; grid)\nwest_bound = PeriodicBoundary(West; grid)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If we plot the polygons that are created within each boundary object, we can see that they border the grid. These polygons are how we well when the ice floes are interacting with each of the boundaries. We can also see that the boundaries overlap in the corners to ensure there is a solid border around the grid. The PeriodicBoundary elements are in purple while the CollisionBoundary elements are in teal.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"poly!(   # plot each of the boundaries with a 50% transparent color so we can see the overlap\n    [north_bound.poly, south_bound.poly, east_bound.poly, west_bound.poly];\n    color = [(:purple, 0.5), (:purple, 0.5), (:teal, 0.5), (:teal, 0.5)],\n)\nfig  # display the figure","category":"page"},{"location":"tutorial/#Creating-Topography","page":"Tutorial","title":"Creating Topography","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We then have the option to add in a TopographyField, which is a collection of TopographyElements. If we want to add in topography field, we can create one using the initialize_topography_field function. Here we will create two islands in the channel. For simplcity, both will be triangles. I create the polygons that define the shape of each island using GeoInterface and defining the points with tuples:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"island1 = GI.Polygon([[(-6e4, 7.5e4), (-4e4, 5e4), (-2.5e4, 7e4), (-6e4, 7.5e4)]])\nisland2 = GI.Polygon([[(5e4, 2.5e4), (5e4, 5.5e4), (7.5e4, 3e4), (5e4, 2.5e4)]])\ntopo_list = [island1, island2]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then pass these to initialize_topography_field with the polys keyword. We could also have defined them just by their coordinates and passed in the coordiantes by the coords keyword.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"topo_field = initialize_topography_field(; polys = topo_list)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now plot the topography within the domain.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"topo_color = RGBf(115/255, 93/255, 55/255)  # brown color for topography\npoly!(topo_field.poly; color = topo_color) # plot the topography\nfig  # display the figure","category":"page"},{"location":"tutorial/#Creating-a-Domian","page":"Tutorial","title":"Creating a Domian","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We now have all of the pieces needed to create a Domain. We will combine the four (4) boundaries we created, and the topography, into one Domain object. The collection of boundaries and topography define where the floes can and cannot go in the simulation and add in boundary behavior.We can do that as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"domain = Domain(; north = north_bound, south = south_bound, east = east_bound, west = west_bound, topography = topo_field)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nWe could have skipped adding the topography to the domain. That is an optional   keyword and an empty topography field will be automatically created if the user does not   provide one.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"At this point, we have already plotted all of the Domain objects, so we will move in to adding environmental forcing from the ocean and the atmosphere.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
