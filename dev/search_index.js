var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = Subzero","category":"page"},{"location":"api/#Full-Subzero-API-documentation","page":"API Reference","title":"Full Subzero API documentation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"warning: Warning\nThis page is still very much WIP!","category":"page"},{"location":"api/#Grids","page":"API Reference","title":"Grids","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AbstractRectilinearGrid\nRegRectilinearGrid","category":"page"},{"location":"api/#Subzero.AbstractRectilinearGrid","page":"API Reference","title":"Subzero.AbstractRectilinearGrid","text":"YourGridType{FT} <: AbstractRectilinearGrid{FT}\n\nEach simulation run with Subzero.jl must be run on a grid. A grid defines the points at which the ocean and atmosphere hold velocity data, as well as various other tracers, at grid points. The user must choose an existing subtype of AbstractRectilinearGrid or implement a new subtype to create a simulation. \n\nEach grid implementation must define the number and dimensions of each grid cell. Right now, this assumes that the ocean and the atmosphere are on the same grid and that the grid is rectangular. We might not want this to be true in the future. Furthermore, each concrete implementation of AbstractRectilinearGrid that will be used to two-way couple with an ocean or an atmosphere must have a field called floe_locations that is a matrix of CellFloes, with one element for each grid point. The user should not worry about CellFloes, this is up to the developer to make sure that their grid contains and populates this field. Again, in the future, this might be related to the ocean and/or atmosphere rather than the grid. For more information, or if you're interested in working on this, see issue #107.\n\nAPI\n\nThe following methods must be implemented for all subtypes:\n\n_get_grid_extent(grid::AbstractRectilinearGrid): \n\nThe _get_grid_extent function takes in a concrete subtype of AbstractRectilinearGrid and returns the grid's minimum x-value, maximum x-value, minimum y-value, and maximum y-value.\n\nGiven the original code was written for RegRectilinearGrid objects, the dispatch isn't fully implemented and other functions should be added to this list. If you were interested in adding a new subtype of AbstractRectilinearGrid, see  issue #108.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.RegRectilinearGrid","page":"API Reference","title":"Subzero.RegRectilinearGrid","text":"RegRectilinearGrid{FT} <: AbstractRectilinearGrid{FT}\n\nA concrete implementation of an AbstractRectilinearGrid that represents a tessellation of 2-dimensional Euclidean space into n-by-m congruent rectangles. Fields that hold float data are of type FT, a concrete subtype of AbstractFloat.\n\nNx::Int: number of grid cells in the x-direction\nNy::Int: number of grid cells in the y-direction\nΔx::FT: grid cell width\nΔy::FT: grid cell height\nx0::FT: value of first x grid line\nxf::FT: value of final x grid line\ny0::FT: value of first y grid line\nyf::FT: value of final y grid line\nfloe_locations::Matrix{CellFloes}: Nx + 1 by Ny + 1 matrix of CellFloes\n\nHere is how to construct a RegRectilinearGrid:\n\nRegRectilinearGrid([FT = Float64]; x0, xf, y0, yf, Nx = nothing, Ny = nothing, Δx = nothing, Δy = nothing)\n\nPositional arguments\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\nx0::FT: value of first x grid line\nxf::FT: value of final x grid line\ny0::FT: value of first y grid line\nyf::FT: value of final y grid line\nNx::Int: number of grid cells in the x-direction\nNy::Int: number of grid cells in the y-direction\nΔx::FT: grid cell width\nΔy::FT: grid cell height\n\nnote: Note\nThe user MUST provide x0, xf, y0, and yf; the user then has the choice to provide Nx and Ny OR Δx and Δy. If provided Δx doesn't evenly divide length xf-x0 or Δy doesn't evenly divide yf-y0, you won't get full size grid. The grid will be \"trimmed\" to the nearest full grid square in both directions.\n\nExamples\n\nDefining a RegRectilinearGrid using Nx and Ny.\n\njulia> grid = RegRectilinearGrid(; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 10)\nRegRectilinearGrid{Float64}\n  ⊢x extent (0.0 to 500000.0) with 20 grid cells of size 25000.0 m\n  ∟y extent (0.0 to 500000.0) with 10 grid cells of size 50000.0 m\n\nDefining a RegRectilinearGrid using Δx and Δy.\n\njulia> grid = RegRectilinearGrid(Float32; x0 = -5e5, xf = 5e5, y0 = 0.0, yf = 5e5, Δx = 5e4, Δy = 5e4)\nRegRectilinearGrid{Float32}\n  ⊢x extent (-500000.0 to 500000.0) with 20 grid cells of size 50000.0 m\n  ∟y extent (0.0 to 500000.0) with 10 grid cells of size 50000.0 m\n\nError due to attemping to define a RegRectilinearGrid using Δx and Ny.\n\njulia> grid = RegRectilinearGrid(; x0 = -5e5, xf = 5e5, y0 = 0.0, yf = 5e5, Δx = 5e4, Ny = 10)\nERROR: ArgumentError: To create a RegRectilinearGrid, either provide Δx and Δy OR Nx and Ny.\n[...]\n\n\n\n\n\n","category":"type"},{"location":"api/#Directions","page":"API Reference","title":"Directions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AbstractDirection\nNorth\nSouth\nEast\nWest","category":"page"},{"location":"api/#Subzero.AbstractDirection","page":"API Reference","title":"Subzero.AbstractDirection","text":"YourDirection <: AbstractDirection\n\nEach domain within a Subzero.jl Model must have four (4) boundaries (subtypes of AbstractBoundary) where each of these boundaries is parametrically typed by the direction of the boundary. The user will first choose one of the four cardinal directions, the subtypes of AbstractDirection:\n\nNorth\nSouth\nEast\nWest\n\nThis abstract type is not meant to be extended by the user, unless the user wants to move away from a rectangular domain with assigned cardinal directions for each wall. This would a more major redesign and the user should check out the developer documentation.\n\n_API\n\n_boundary_info_from_extent(D::Type{AbstractDirection}, FT::Type{AbstractFloat}, x0, xf, y0, yf)\n\nThe _boundary_info_from_extent function finds the values for the poly and val fields of a subtype of AbstractBoundary of direction D given a region of the extent defined by x0, xf, y0, and yf given that these are the minimum and maximum x and y values of the region desired. The returned extent will have values of type FT.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.North","page":"API Reference","title":"Subzero.North","text":"North<:AbstractDirection\n\nA simple subtype of AbstractDirection used for parametrically typing a subtype of AbstractBoundary if that boundary is the northern boundary in a rectangular domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.South","page":"API Reference","title":"Subzero.South","text":"South<:AbstractDirection\n\nA simple subtype of AbstractDirection used for parametrically typing a subtype of AbstractBoundary if that boundary is the southern boundary in a rectangular domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.East","page":"API Reference","title":"Subzero.East","text":"East<:AbstractDirection\n\nA simple subtype of AbstractDirection used for parametrically typing a subtype of AbstractBoundary if that boundary is the eastern boundary in a rectangular domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.West","page":"API Reference","title":"Subzero.West","text":"West<:AbstractDirection\n\nA simple subtype of AbstractDirection used for parametrically typing a subtype of AbstractBoundary if that boundary is the western boundary in a rectangular domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Boundaries","page":"API Reference","title":"Boundaries","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AbstractBoundary\nOpenBoundary\nPeriodicBoundary\nCollisionBoundary\nMovingBoundary","category":"page"},{"location":"api/#Subzero.AbstractBoundary","page":"API Reference","title":"Subzero.AbstractBoundary","text":"AbstractBoundary{D, FT} <: AbstractDomainElement{FT}\n\nWhen running a Subzero simulation, each simulation has a rectangular domain that contains the ice pack. This domain is made up for four boundaries, one in each of the cardinal directions: North, South, East, and West. The user will pick four boundary types, each concrete subtypes of AbstractBoundary and assign each of them a direction, D and a float type FT, by typing them parametrically. \n\nThe user can pick from the currently implemented concrete subtypes of AbstractBoundary (OpenBoundary, CollisionBoundary, PeriodicBoundary, and MovingBoundary) or implement their own.\n\nFor now, each boundary wall is assumed to be a rectangle. For correct behavior, the corners of each of the boundary rectangles should overlap to make sure that no floes reach outside of the domain without touching a boundary. These rectangles should be represented as polygons with the poly field within each boundary. Furthermore, each boundary should have a val field that represents either the line y = val (for North and South walls) or x = val (for East and West walls) that denotes the line that marks the \"inner-most\" edge of the domain. If an ice floe passes over the boundary's val line, the floe interacts with the boundary.\n\n ________________\n|__|____val___|__| <- North coordinates include corners\n|  |          |  |\n|  |          |  | <- East and west coordinates ALSO include corners\n|  |          |  |\n\nFor ease of use, each boundary should have a constructor option where the user can provide an AbstractRectilinearGrid concrete type to define a boundary where val is at the edge of the grid so that the boundaries form a border right around the grid.\n\nAPI\n\nIn addition to the below function, any new AbstractBoundary subtype must also implement AbstractDomainElement API functions.\n\n_update_boundary!(boundary::AbstractBoundary, Δt::Int)\n_periodic_compat(boundary1::AbstractBoundary, boundary2::AbstractBoundary)\n\nThe _update_boundary! function updates a boundary's position (by changing the val and poly fields) at every timestep. Currently, only MovingBoundary elements are updated, and their update depends on the length of the simulation's timestep, Δt.\n\nThe _periodic_compat function determines if a pair of functions are \"periodically compatible\",  that is, could they form a pair on opposite edges of a domain to create a set of functioning periodic boundaries. It is called when creating a Domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.OpenBoundary","page":"API Reference","title":"Subzero.OpenBoundary","text":"OpenBoundary{D, FT} <: AbstractBoundary{D, FT}\n\nA concrete subtype of AbstractBoundary that removes a floe from the simulation if any of the floe's vertices overlap with the OpenBoundary. This is meant to simulate the floe floating out of the simulation. The floe is immeditaly removed as there might not be ocean u and v values outside of the domian and thus we wouldn't know how to evolve the floe's trajectory. This boundary is direction D (AbstractDirection) of the domain and has field data of type FT <: AbstractFloat.\n\nFields\n\npoly::StaticQuadrilateral{FT}: rectangular polygon representing \n\n\nthe shape and location of the boundary on a given timestep with points of float type FT.\n\nval::FT: number of float type FT representing either the line y = val \n\n\n(for North and South walls) or x = val (for East and West walls) that denotes the \nline marking the inner-most edge of the domain.\n\nHere is how to construct an OpenBoundary:\n\nOpenBoundary(D, [FT = Float64]; grid  = nothing, x0 = nothing, xf = nothing, y0 = nothing, yf = nothing)\n\nThe user must specify which AbstractDirection the boundary is. The user also has an opportunity to specify which float type Float64 or Float32 will be used for field data. The user then must either provide an grid object (AbstractRectilinearGrid) for the domain to align with the grid edges, or provide four values (x0, xf, y0, and yf) that define the x and y-extents the user wants for the domain.\n\nnote: Note\nIf the user chooses to specify the domain extents, they still must be within the grid in order to make a valid Model.\n\nPositional arguments\n\nD::Type{<:AbstractDirection}: subtype of AbstractDirection used to represent \n\n\nif a boundary is the North, South, East, or West boundary of a simulation\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\ngrid::AbstractRectilinearGrid: subtype of AbstractRectilinearGrid representing the grid used within a simulation\nx0::FT: minimum x-value of domain extent (region floes will be contained within)\nxf::FT: maximum x-value of domain extent (region floes will be contained within)\ny0::FT: minimum y-value of domain extent (region floes will be contained within)\nyf::FT: maximum y-value of domain extent (region floes will be contained within)\n\nnote: Note\nThe user must either provide a grid OR all four (4) of x0, xf, y0, and yf.\n\nExamples\n\nDefining a Northern OpenBoundary with Float64 (default type) data using the grid keyword.\n\njulia> g = RegRectilinearGrid(x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);\n\njulia> OpenBoundary(North; grid = g)\nOpenBoundary{North, Float64}\n  ⊢polygon points are defined by the following set: (-250000.0, 750000.0), (750000.0, 500000.0), (750000.0, 750000.0), (-250000.0, 500000.0)\n  ∟val is 500000.0\n\nDefining a Southern OpenBoundary with Float32 data using the x0, xf, y0 and yf keywords.\n\njulia> OpenBoundary(South, Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5)\nOpenBoundary{South, Float32}\n  ⊢polygon points are defined by the following set: (750000.0f0, 0.0f0), (750000.0f0, -250000.0f0), (-250000.0f0, 0.0f0), (-250000.0f0, -250000.0f0)\n  ∟val is 0.0\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.PeriodicBoundary","page":"API Reference","title":"Subzero.PeriodicBoundary","text":"PeriodicBoundary <: AbstractBoundary\n\nA concrete subtype of AbstractBoundary that moves a floe from one side of the domain to the opposite side of the domain (North to South and East to West and visa versa) when its centroid crosses the PeriodicBoundary, bringing the floe back into the domain. Due to this behavior, PeriodicBoundary pairs are required to form a valid domain.  This boundary is direction D (AbstractDirection) of the domain and has field data of type FT <: AbstractFloat.\n\nFields\n\npoly::StaticQuadrilateral{FT}: rectangular polygon representing \n\n\nthe shape and location of the boundary on a given timestep with points of float type FT.\n\nval::FT: number of float type FT representing either the line y = val \n\n\n(for North and South walls) or x = val (for East and West walls) that denotes the \nline marking the inner-most edge of the domain.\n\nHere is how to construct an PeriodicBoundary:\n\nPeriodicBoundary(D, [FT = Float64]; grid  = nothing, x0 = nothing, xf = nothing, y0 = nothing, yf = nothing)\n\nThe user must specify which AbstractDirection the boundary is. The user also has an opportunity to specify which float type Float64 or Float32 will be used for field data. The user then must either provide an grid object (AbstractRectilinearGrid) for the domain to align with the grid edges, or provide four values (x0, xf, y0, and yf) that define the x and y-extents the user wants for the domain.\n\nnote: Note\nIf the user chooses to specify the domain extents, they still must be within the grid in order to make a valid Model.\n\nPositional arguments\n\nD::Type{<:AbstractDirection}: subtype of AbstractDirection used to represent \n\n\nif a boundary is the North, South, East, or West boundary of a simulation\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\ngrid::AbstractRectilinearGrid: subtype of AbstractRectilinearGrid representing the grid used within a simulation\nx0::FT: minimum x-value of domain extent (region floes will be contained within)\nxf::FT: maximum x-value of domain extent (region floes will be contained within)\ny0::FT: minimum y-value of domain extent (region floes will be contained within)\nyf::FT: maximum y-value of domain extent (region floes will be contained within)\n\nnote: Note\nThe user must either provide a grid OR all four (4) of x0, xf, y0, and yf.\n\nExamples\n\nDefining an Eastern PeriodicBoundary with Float32 data using the grid keyword.\n\njulia> g = RegRectilinearGrid(Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);\n\njulia> PeriodicBoundary(East; grid = g)\nPeriodicBoundary{East, Float64}\n  ⊢polygon points are defined by the following set: (750000.0, -250000.0), (500000.0, -250000.0), (750000.0, 750000.0), (500000.0, 750000.0)\n  ∟val is 500000.0\n\nDefining a Western PeriodicBoundary with Float64 data using the x0, xf, y0 and yf keywords.\n\njulia> PeriodicBoundary(West, Float64; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5)\nPeriodicBoundary{West, Float64}\n  ⊢polygon points are defined by the following set: (0.0, -250000.0), (-250000.0, 750000.0), (0.0, 750000.0), (-250000.0, -250000.0)\n  ∟val is 0.0\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.CollisionBoundary","page":"API Reference","title":"Subzero.CollisionBoundary","text":"CollisionBoundary <: AbstractBoundary\n\nA concrete subtype of AbstractBoundary that calculates collision forces of a floe against the boundary if any of the floe's vertices overlap with the CollisionBoundary. This is meant to simulate any barrier that might stop a floe from flowing into or out of a given region, like the edges of a cove. With this type of wall, a CollisionBoundary is treated as an immovable, unbreakable floe for the purposes of calculations. This boundary is direction D (AbstractDirection) of the domain and has field data of type FT <: AbstractFloat.\n\nFields\n\npoly::StaticQuadrilateral{FT}: rectangular polygon representing \n\n\nthe shape and location of the boundary on a given timestep with points of float type FT.\n\nval::FT: number of float type FT representing either the line y = val \n\n\n(for North and South walls) or x = val (for East and West walls) that denotes the \nline marking the inner-most edge of the domain.\n\nHere is how to construct an CollisionBoundary:\n\nCollisionBoundary(D, [FT = Float64]; grid  = nothing, x0 = nothing, xf = nothing, y0 = nothing, yf = nothing)\n\nThe user must specify which AbstractDirection the boundary is. The user also has an opportunity to specify which float type Float64 or Float32 will be used for field data. The user then must either provide an grid object (AbstractRectilinearGrid) for the domain to align with the grid edges, or provide four values (x0, xf, y0, and yf) that define the x and y-extents the user wants for the domain.\n\nnote: Note\nIf the user chooses to specify the domain extents, they still must be within the grid in order to make a valid Model.\n\nPositional arguments\n\nD::Type{<:AbstractDirection}: subtype of AbstractDirection used to represent \n\n\nif a boundary is the North, South, East, or West boundary of a simulation\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\ngrid::AbstractRectilinearGrid: subtype of AbstractRectilinearGrid representing the grid used within a simulation\nx0::FT: minimum x-value of domain extent (region floes will be contained within)\nxf::FT: maximum x-value of domain extent (region floes will be contained within)\ny0::FT: minimum y-value of domain extent (region floes will be contained within)\nyf::FT: maximum y-value of domain extent (region floes will be contained within)\n\nnote: Note\nThe user must either provide a grid OR all four (4) of x0, xf, y0, and yf.\n\nExamples\n\nDefining an Northern CollisionBoundary with Float64 data using the grid keyword.\n\njulia> g = RegRectilinearGrid(Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);\n\njulia> CollisionBoundary(North; grid = g)\nCollisionBoundary{North, Float64}\n  ⊢polygon points are defined by the following set: (-250000.0, 750000.0), (750000.0, 500000.0), (750000.0, 750000.0), (-250000.0, 500000.0)\n  ∟val is 500000.0\n\nDefining a Western CollisionBoundary with Float64 data using the x0, xf, y0 and yf keywords.\n\njulia> CollisionBoundary(West, Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5)\nCollisionBoundary{West, Float32}\n  ⊢polygon points are defined by the following set: (0.0f0, -250000.0f0), (-250000.0f0, 750000.0f0), (0.0f0, 750000.0f0), (-250000.0f0, -250000.0f0)\n  ∟val is 0.0\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.MovingBoundary","page":"API Reference","title":"Subzero.MovingBoundary","text":"MovingBoundary <: AbstractBoundary\n\nA concrete subtype of AbstractBoundary that can provide a compressive or shear  force on the floes within the domain by moving parallel or perpendicular to the domain. The MovingBoundary calcuates the forces on the floe exactly the same as a CollisionBoundary, by acting as a immovable, unbreakable floe. This boundary is direction D (AbstractDirection) of the domain and has field data of type FT <: AbstractFloat.\n\nIf a North or South wall has a non-zero v velocity this will provide a compressive stress as the floe moves towards the center of the domain along the vector x = cx where (cx, cy) is the centroid of the domain (or decompresses with opposite sign velocities). The poly and  val fields are updated to represent the movement of the domain at the user-provided velocities, u and v m/s.\n\nAlternatively, if a North or South wall has a non-zero u velocity this will provide a  shear stress as the domain \"moves\" along the line y = y0 (for North) or y = yf (for South). In this case, this only changes the frictional forces and we do not need up actually change the poly or val fields.\n\nFields\n\npoly::StaticQuadrilateral{FT}: rectangular polygon representing \n\n\nthe shape and location of the boundary on a given timestep with points of float type FT.\n\nval::FT: number of float type FT representing either the line y = val \n\n\n(for North and South walls) or x = val (for East and West walls) that denotes the \nline marking the inner-most edge of the domain.\n\nu::FT: boundary's u-velocity\nv::FT: boundary's v-velocity\n\nHere is how to construct an MovingBoundary:\n\nMovingBoundary(D, [FT = Float64]; u = 0.0, v = 0.0, grid  = nothing, x0 = nothing, xf = nothing, y0 = nothing, yf = nothing)\n\nThe user must specify which AbstractDirection the boundary is. The user also has an opportunity to specify which float type Float64 or Float32 will be used for field data. The user then must either provide an grid object (AbstractRectilinearGrid) for the domain to align with the grid edges, or provide four values (x0, xf, y0, and yf) that define the x and y-extents the user wants for the domain.\n\nnote: Note\nIf the user chooses to specify the domain extents, they still must be within the grid in order to make a valid Model.\n\nPositional arguments\n\nD::Type{<:AbstractDirection}: subtype of AbstractDirection used to represent \n\n\nif a boundary is the North, South, East, or West boundary of a simulation\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\nu::FT: boundary's u-velocity\nv::FT: boundary's v-velocity\ngrid::AbstractRectilinearGrid: subtype of AbstractRectilinearGrid representing the grid used within a simulation\nx0::FT: minimum x-value of domain extent (region floes will be contained within)\nxf::FT: maximum x-value of domain extent (region floes will be contained within)\ny0::FT: minimum y-value of domain extent (region floes will be contained within)\nyf::FT: maximum y-value of domain extent (region floes will be contained within)\n\nnote: Note\nThe user must either provide a grid OR all four (4) of x0, xf, y0, and yf. If the user does not provide values for u or v, the boundary will not move.\n\nExamples\n\nDefining an Northern MovingBoundary with Float64 data using the grid keyword. Assigning u-velocity of 0.5m/s.\n\njulia> g = RegRectilinearGrid(Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);\n\njulia> MovingBoundary(North; u = 0.5, grid = g)\nMovingBoundary{North, Float64}\n  ⊢polygon points are defined by the following set: (-250000.0, 750000.0), (750000.0, 500000.0), (750000.0, 750000.0), (-250000.0, 500000.0)\n  ⊢val is 500000.0\n  ⊢u-velocity of 0.5 m/s\n  ∟v-velocity of 0.0 m/s\n\nDefining a Southern MovingBoundary with Float32 data using the x0, xf, y0 and yf keywords.\n\nAssigning u-velocity of 0.3 m/s and v-velocity of 0.25 m/s\n\njulia> MovingBoundary(South, Float32; u = 0.3, v = 0.25, x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5)\nMovingBoundary{South, Float32}\n  ⊢polygon points are defined by the following set: (750000.0f0, 0.0f0), (750000.0f0, -250000.0f0), (-250000.0f0, 0.0f0), (-250000.0f0, -250000.0f0)\n  ⊢val is 0.0\n  ⊢u-velocity of 0.3 m/s\n  ∟v-velocity of 0.25 m/s\n\n\n\n\n\n","category":"type"},{"location":"api/#Topography","page":"API Reference","title":"Topography","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"TopographyElement\ninitialize_topography_field","category":"page"},{"location":"api/#Subzero.TopographyElement","page":"API Reference","title":"Subzero.TopographyElement","text":"TopographyElement{FT}<:AbstractDomainElement{FT}\n\nA concrete subtype of AbstractDomainElement that represent topography in a given simulation. These TopographyElement objects will be treated as be treated as islands or coastline within the model in that they will not move or break due to floe interactions, but they will affect floes that collide with them. \n\nSimilar to Floe objects, we store the shape of each TopographyElement with a poly field. We also store the centroid and the shape's maximum radius (rmax) in order to calculate simple interaction checks with Floes.\n\nFields\n\npoly::Polys{FT}: Polygon used to represent the shape of a floe or topography\ncentroid::Vector{FT}: Two-element vector meant to represent the (x, y) point that is the centroid of either a floe or topography\nrmax::FT: Float length representing the maximum radius of a floe or topography from the centroid to any given vertex\n\nHere is how to construct an TopographyElement:\n\nTopographyElement([FT = Float64]; poly::Polys)\n\nThe user must provide a GeoInterface polygon of the specific type defined by Polys. The user also has an opportunity to specify which float type Float64 or Float32 will be used for field data.\n\nPositional arguments\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\npoly::Polys{FT}: Polygon used to represent the shape of a floe or topography\n\nNote: The user should NOT be using this constructor. The user should create a topography\n\nfield using initialize_topography_field rather than creating individual topography elements. This allows the abstraction of the use of the StructArrays package away from the user.\n\nExamples\n\njulia> import GeoInterface as GI;\n\njulia> poly = GI.Polygon([[(0.0, 0.0), (0.0, 1e3), (1e3, 1e3), (1e3, 0.0), (0.0, 0.0)]]);\n\njulia> TopographyElement(Float64; poly)\nTopographyElement{Float64}\n  ⊢centroid is (500.0, 500.0) in meters\n  ∟maximum radius is 707.1067811865476 meters\n\njulia> TopographyElement(Float32; poly)\nTopographyElement{Float32}\n  ⊢centroid is (500.0, 500.0) in meters\n  ∟maximum radius is 707.1068 meters\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.initialize_topography_field","page":"API Reference","title":"Subzero.initialize_topography_field","text":"initialize_topography_field([::Type{FT} = Float64]; polys = nothing, coords = nothing)\n\nThis function allows for easy initialization of a field of [TopographyElement(@ref)s and collects them into aStructArrayso that they can be passed into a [Model`](@ref).\n\nThis is the suggested way to create a topography field for a simulation. Do NOT construct individual TopographyElement objects as that method does not correct the field as a whole to ensure no topography polygons overlap and does not create a struct array that can be passed to a Model.\n\nThe user can create a topography field by either passing a list of polygons or by passing a list of coordiantes, which will then be made into polygons.\n\nPositional arguments\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\npolys::Vector{<:Polygon}: list of polygons meant to represent a field of floes or topography elements. Polygons can be any polygon type that supports GeoInterface.\ncoords::Vector{<:PolyVec}: list of polygon coordinates meant to represent a field of floes or topography elements. PolyVec refers to a Vector{Vector{<:Points}} where the points can be tuples, vectors, or static vectors and the innermost vector refers to each ring of the polygon.\n\nnote: Note\nTopography field elements must not be intersecting, so the corrections within this function may lead to a different number of polygons than input to make a valid topography field.\n\nExamples\n\nDefining a topography field with coordinates\n\njulia> coords = [[[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (0.0, 0.0)]], [[(10.0, 0.0), (10.0, 1.0), (11.0, 1.0), (10.0, 0.0)]]];\n\njulia> initialize_topography_field(Float64; coords)\n2-element TopographyField{Float64} list:\n TopographyElement{Float64}\n  ⊢centroid is (0.3333333333333333, 0.6666666666666666) in meters\n  ∟maximum radius is 0.74535599249993 meters\n TopographyElement{Float64}\n  ⊢centroid is (10.333333333333334, 0.6666666666666666) in meters\n  ∟maximum radius is 0.7453559924999301 meters\n\nDefining a topography field with polygons\n\njulia> import GeoInterface as GI;\n\njulia> polys = [GI.Polygon(c) for c in coords];\n\njulia> initialize_topography_field(Float32; polys)\n2-element TopographyField{Float32} list:\n TopographyElement{Float32}\n  ⊢centroid is (0.33333334, 0.6666667) in meters\n  ∟maximum radius is 0.745356 meters\n TopographyElement{Float32}\n  ⊢centroid is (10.333333, 0.6666667) in meters\n  ∟maximum radius is 0.74535626 meters\n\nCreating an empty topography field without polys or coords\n\njulia> initialize_topography_field(Float64)\n0-element TopographyField{Float64} list\n\n\n\n\n\n","category":"function"},{"location":"api/#Domain","page":"API Reference","title":"Domain","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Domain","category":"page"},{"location":"api/#Subzero.Domain","page":"API Reference","title":"Subzero.Domain","text":"Domain{FT, NB, SB, EB, WB, TT}\n\nA simulation Domain holds four (4) boundary elements (concrete subtypes of AbstractBoundary) and a list (potentially empty) of TopographyElement objects. There must be a wall typed by each cardinal direction, and each wall must hold data of the same float type FT. Additionally, the North boundary should be \"higher\" (on the y-axis) than the South boundary and the East should be futher to the \"right\" (on the x-axis) than the West boundary. Aditionally, the boundary walls should be overlapping as detailed in AbstractBoundary.\n\nAdditionally, the set of walls must be periodically compatible. This means that pairs of opposite boundaries (North and South AND East and West) both need to be periodic if one of them is periodic. This is because if a floe exits a periodic boundary, it must be able to re-enter the opposite boundary to fulfill its definition of periodic.\n\nFields\n\nnorth::NB: Northern boundary where NB <: AbstractBoundary{North, FT}\nsouth::SB: Southern boundary where SB <: AbstractBoundary{South, FT}\neast::EB: Eastern boundary where EB <: AbstractBoundary{East, FT}\nwest::WB: Western boundary where WB <: AbstractBoundary{West, FT}\ntopography::tT: Field of topography elements where TT <: TopographyField{FT}\n\nnote: Note\nAll FT values above must be the same float type to form a valid domain.\nThe code depends on the boundaries forming a rectangle oriented along the cartesian grid. Other shapes/orientations are not supported at this time. \n\nHere is how to construct an MovingBoundary:\n\nDomain(; north::NB, south::SB, east::EB, west::WB, topography::TT = nothing)\n\nThe user must provide the four (4) boundaries. They then have an option to provide topography. If no topography is provided, an empty TopographyField will be created with the same FT as the first of the boundaries (which should be shared amoung boundaries).\n\nKeyword arguments\n\nnorth::NB: domain's northern boundary\nsouth::SB: domain's southern boundary\neast::EB: domain's eastern boundary\nwest::WB: domain's western boundary\ntopography::TT: domain's topography field, if there is one, else an empty field is created\n\nExamples\n\nCreating a Domain with NO topography\n\njulia> grid = RegRectilinearGrid(Float32; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 20);\n\njulia> north = OpenBoundary(North, Float64; grid);\n\njulia> south = OpenBoundary(South, Float64; grid);\n\njulia> east = PeriodicBoundary(East, Float64; grid);\n\njulia> west = PeriodicBoundary(West, Float64; grid);\n\njulia> Domain(; north, south, east, west)\nDomain\n  ⊢Northern boundary of type OpenBoundary{North, Float64}\n  ⊢Southern boundary of type OpenBoundary{South, Float64}\n  ⊢Eastern boundary of type PeriodicBoundary{East, Float64}\n  ⊢Western boundary of type PeriodicBoundary{West, Float64}\n  ∟0-element TopograpahyElement{Float64} list\n\nCreating a Domain with topography\n\njulia> import GeoInterface as GI;\n\njulia> topo_polys = [GI.Polygon([[(1e4, 1e4), (1e4, 3e4), (3e4, 1e4), (1e4, 1e4)]]), GI.Polygon([[(8e4, 8e4), (8e4, 9e4), (9e4, 9e4), (9e4, 8e4), (8e4, 8e4)]])];\n\njulia> topography = initialize_topography_field(; polys = topo_polys);\n\njulia> Domain(; north, south, east, west, topography)\nDomain\n  ⊢Northern boundary of type OpenBoundary{North, Float64}\n  ⊢Southern boundary of type OpenBoundary{South, Float64}\n  ⊢Eastern boundary of type PeriodicBoundary{East, Float64}\n  ⊢Western boundary of type PeriodicBoundary{West, Float64}\n  ∟2-element TopograpahyElement{Float64} list\n\n\n\n\n\n","category":"type"},{"location":"api/#Ocean","page":"API Reference","title":"Ocean","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Ocean","category":"page"},{"location":"api/#Subzero.Ocean","page":"API Reference","title":"Subzero.Ocean","text":"Ocean{FT}\n\nEach simulation needs ocean values on the grid to drive the ice floes. The Ocean struct holds the needed fields to perform coupling, including vector fields (like u-velocity, v-velocity, x-stress, and y-stress) and tracer fields (like temperature, heatflux, and  dissolved ice mass). We also hold and calculate the sea ice fraction in any given grid cell.\n\nRight now, all values are stored on grid points as defined by an AbstractRectilinearGrid. This should eventually change to a c-grid. If interested in this change, see issue #30. This will require a big change in behavior, but is an important change for consistency and to match with Oceananigans for two-way coupling.\n\nCoupling beyond velocity (for example thermodynamically) is not very well developed. If you are interested in working on this see issue #9. The hflx_factor field is related to thermodynamic coupling.\n\nFields\n\nu::Matrix{FT}: ocean u-velocities in the x-direction on each grid point\nv::Matrix{FT}: ocean v-velocities in the y-direction on each grid point\ntemp::Matrix{FT}: ocean temperature on each grid point\nhflx_factor::Matrix{FT}: factor to calculate the ocean-atmosphere heat flux for a grid cell\nscells::Matrix{CellStresses}: used to accumulate stresses on the ocean per grid cell from floes in cell (see CellStresses)\nτx::Matrix{FT}: stress on the ocean in the x-direction on each grid point\nτy::Matrix{FT}: stress on the ocean in the y-direction on each grid point\nsi_frac::Matrix{FT}: fraction of area in each grid cell (centered on grid points) that is covered in sea-ice (between 0-1)\ndissolved::Matrix{FT}: total mass from ice floes dissolved in each grid cell (centered on grid points)\n\nnote: Note\nIf a periodic boundary is used in the domain, the last grid cell in that direction will not be used as it is equivalent to the first grid cell. Thus, for all of these fields, the first and last value in the x and/or y direction should be equal if the east-west or north-south boundary pair are periodic respectively. In the future, it might be worth having the ocean re-sizing to not included this repeated point dispatching off of the boundary types.\n\nnote: Note\nFor each of the fields, the rows represent the x-values of the grid, while the columns represent the y-values of the grid. This makes it easy to index into the grid for a point (x, y), although it does mean that the fields provided don't \"look\" like the grid if plotted directly and instead need to be transposed. \n\nHere is how to construct an Ocean:\n\nOcean([FT = Float64]; u, v, temp, grid = nothing)\n\nPositional arguments\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\nu::Union{Real, Matrix{Real}}: user can either provide a single u-velocity value (a constant field the size of the grid will be created) or provide a matrix field of  u-velocity values\nv::Union{Real, Matrix{Real}}: user can either provide a single v-velocity value (a constant field the size of the grid will be created) or provide a matrix field of v-velocity values\ntemp::Union{Real, Matrix{Real}}: user can either provide a single temperature value (a constant field the size of the grid will be created) or provide a matrix field of temperature values\ngrid::AbstractRectilinearGrid: subtype of AbstractRectilinearGrid representing the grid used within a simulation\n\nnote: Note\nThe user MUST provide u, v, and temp, although they have the option of these being Real values or Matrix{<:Real}. If the user chooses to provide Real values for any of those fields, then a grid IS required to create a constant field of the correct size. If user chooses to provide a field, they should be of size (grid.Nx + 1, grid.Ny + 1) and the user doesn't require a grid input.\n\nExamples\n\nCreating Ocean with constant u-velocity, v-velocity, and temp\n\njulia> grid = RegRectilinearGrid(; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 10);\n\njulia> Ocean(; u = 0.5, v = 0.25, temp = 0.0, grid)\nOcean{Float64}\n  ⊢Vector fields of dimension (21, 11)\n  ⊢Tracer fields of dimension (21, 11)\n  ⊢Average u-velocity of: 0.5 m/s\n  ⊢Average v-velocity of: 0.25 m/s\n  ∟Average temperature of: 0.0 C\n\nCreating Ocean with user-defined u and v and a constant temp with Float32 data\n\njulia> import Random.Xoshiro;\n\njulia> seeded_rng = Xoshiro(100);\n\njulia> u_field = rand(seeded_rng, grid.Nx + 1, grid.Ny + 1);\n\njulia> v_field = rand(seeded_rng, grid.Nx + 1, grid.Ny + 1);\n\njulia> Ocean(Float32; u = u_field, v = v_field, temp = 0.0, grid)\nOcean{Float32}\n  ⊢Vector fields of dimension (21, 11)\n  ⊢Tracer fields of dimension (21, 11)\n  ⊢Average u-velocity of: 0.4856711 m/s\n  ⊢Average v-velocity of: 0.5319979 m/s\n  ∟Average temperature of: 0.0 C\n\nTrying to create an Ocean with a constant field and NO grid\n\njulia> Ocean(; u = 0.2, v = 0.1, temp = 0.0)\nERROR: ArgumentError: To create a matrix from the constant value provided, you must provide a grid.\n[...]\n\n\n\n\n\n","category":"type"},{"location":"api/#Atmosphere","page":"API Reference","title":"Atmosphere","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Atmos","category":"page"},{"location":"api/#Subzero.Atmos","page":"API Reference","title":"Subzero.Atmos","text":"Atmos{FT}\n\nEach simulation needs atmosphere/wind values on the grid to drive the ice floes. The Atmos struct holds the needed fields to perform coupling of vector fields (u-velocity and  v-velocity) and tracer fields (temperature).\n\nRight now, all values are stored on grid points as defined by an AbstractRectilinearGrid. This should eventually change to a c-grid. If interested in this change, see issue #30.\n\nCoupling beyond velocity (for example thermodynamically) is not very well developed. If you are interested in working on this see issue #9. The hflx_factor field is related to thermodynamic coupling.\n\nFields\n\nu::Matrix{FT}: atmosphere/wind u-velocities in the x-direction on each grid point\nv::Matrix{FT}: atmosphere/wind v-velocities in the y-direction on each grid point\ntemp::Matrix{FT}: atmosphere/wind temperature on each grid point\n\nnote: Note\nIf a periodic boundary is used in the domain, the last grid cell in that direction will not be used as it is equivalent to the first grid cell. Thus, for all of these fields, the first and last value in the x and/or y direction should be equal if the east-west or north-south boundary pair are periodic respectively. In the future, it might be worth having the atmos re-sizing to not included this repeated point dispatching off of the boundary types.\n\nnote: Note\nFor each of the fields, the rows represent the x-values of the grid, while the columns represent the y-values of the grid. This makes it easy to index into the grid for a point (x, y), although it does mean that the fields provided don't \"look\" like the grid if plotted directly and instead need to be transposed. \n\nHere is how to construct an Atmos:\n\nAtmos([FT = Float64]; u, v, temp, grid = nothing)\n\nPositional arguments\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\nu::Union{Real, Matrix{Real}}: user can either provide a single u-velocity value (a constant field the size of the grid will be created) or provide a matrix field of  u-velocity values\nv::Union{Real, Matrix{Real}}: user can either provide a single v-velocity value (a constant field the size of the grid will be created) or provide a matrix field of v-velocity values\ntemp::Union{Real, Matrix{Real}}: user can either provide a single temperature value (a constant field the size of the grid will be created) or provide a matrix field of temperature values\ngrid::AbstractRectilinearGrid: subtype of AbstractRectilinearGrid representing the grid used within a simulation\n\nnote: Note\nThe user MUST provide u, v, and temp, although they have the option of these being Real values or Matrix{<:Real}. If the user chooses to provide Real values for any of those fields, then a grid IS required to create a constant field of the correct size. If user chooses to provide a field, they should be of size (grid.Nx + 1, grid.Ny + 1) and the user doesn't require a grid input.\n\nExamples\n\nCreating Atmos with constant u-velocity, v-velocity, and temp\n\njulia> grid = RegRectilinearGrid(; x0 = 0.0, xf = 5e5, y0 = 0.0, yf = 5e5, Nx = 20, Ny = 10);\n\njulia> Atmos(; u = 0.5, v = 0.25, temp = 0.0, grid)\nAtmos{Float64}\n  ⊢Vector fields of dimension (21, 11)\n  ⊢Tracer fields of dimension (21, 11)\n  ⊢Average u-velocity of: 0.5 m/s\n  ⊢Average v-velocity of: 0.25 m/s\n  ∟Average temperature of: 0.0 C\n\nCreating Atmos with user-defined u and v and a constant temp with Float32 data\n\njulia> import Random.Xoshiro;\n\njulia> seeded_rng = Xoshiro(200);\n\njulia> u_field = rand(seeded_rng, grid.Nx + 1, grid.Ny + 1);\n\njulia> v_field = rand(seeded_rng, grid.Nx + 1, grid.Ny + 1);\n\njulia> Atmos(Float32; u = u_field, v = v_field, temp = 0.0, grid)\nAtmos{Float32}\n  ⊢Vector fields of dimension (21, 11)\n  ⊢Tracer fields of dimension (21, 11)\n  ⊢Average u-velocity of: 0.4965465 m/s\n  ⊢Average v-velocity of: 0.5340565 m/s\n  ∟Average temperature of: 0.0 C\n\nTrying to create an Atmos with a constant field and NO grid\n\njulia> Atmos(; u = 0.2, v = 0.1, temp = 0.0)\nERROR: ArgumentError: To create a matrix from the constant value provided, you must provide a grid.\n[...]\n\n\n\n\n\n","category":"type"},{"location":"api/#Model","page":"API Reference","title":"Model","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Model","category":"page"},{"location":"api/#Subzero.Model","page":"API Reference","title":"Subzero.Model","text":"Model which holds grid, ocean, atmos structs, each with the same underlying float type (either Float32 of Float64) and size. It also holds the domain information, which includes the topography and the boundaries. It holds a  StructArray of floe structs, again each relying on the same underlying float type. Finally, it also holds the maximum floe id used thus far in the simulation. This should be the length of the floes array at the beginning of the run. \n\n\n\n\n\n","category":"type"},{"location":"api/#Developer-Used-Types","page":"API Reference","title":"Developer-Used Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"CellFloes\nCellStresses\nTopographyField","category":"page"},{"location":"api/#Subzero.CellFloes","page":"API Reference","title":"Subzero.CellFloes","text":"CellFloes{FT}\n\nA CellFloes struct represents a single grid cell and accumulates the indices of floes with area in that grid cell. This is used to accumulate the forces of floes in a grid cell on the ocean below it. Due to the prevalence of periodic boundaries, the grid cell represented by a CellFloes object are centered on grid points (translated by Δx/2 and Δy/2 in the x and y directions for a RegRectilinearGrid), rather than on the grid cells defined by the grid object itself. Floes are recorded with their index in the  list of floes. Furthermore, in a model with periodic boundaries, some floes may be in multiple grid cells on different edges of the domain if they pass through a periodic boundary. In these cases, the floe \"linked\" to with its index must be translated by a vector to get its \"ghost\" on the other side of the domain. This non-integer translation data is of float type FT. CellFloes are used with CellStresses objects, which aggregate the stress from each of the floes recorded in a given CellFloes object.\n\nFields\n\nfloeidx: see keyword arguments\nΔx: see keyword arguments\nΔy: see keyword arguments\n\nHere is how to construct a CellFloes object:\n\nCellFloes([FT = Float64]; floeidx = nothing, Δx = nothing, Δy = nothing)\n\nPositional arguments\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\nfloeidx::Vector{Int}: vector of floe indicies in the list of model floes for floes with area in the grid\nΔx::Vector{FT}: vector of x-translations for a floe at the corresponding index of the\n\nfloeidx vector to be in the cell represented with the CellFloes object.\n\nΔy::Vector{FT}: vector of y-translations for a floe at the corresponding index of the\n\nfloeidx vector to be in the cell represented with the CellFloes object.\n\nnote: Note\nIf no keyword arguments are provide by the user, an CellFloes object with empty fields will be created. This is the standard useage of these objects and they are added to during the coupling step. If keyword arguments are provided, then all three must be provided and each vector must be the same size.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.CellStresses","page":"API Reference","title":"Subzero.CellStresses","text":"CellStresses{FT}\n\nStruct to collect stress from ice floes on ocean grid cells. One CellStresses corresponds to one grid cell and is \"linked\" to a corresponding CellFloes object. The CellFloes object records which floes are in a given grid cell and the CellStresses aggregates the total stress felt on the ocean from the ice (on each of the floe's sub-floe points generated by a subtype of AbstractSubFloePointsGenerator) in a given grid cell. This is needed ONLY for two-way coupling. Due to the prevalence of periodic boundaries, the grid cell represented by a CellStresses object are centered on grid points (translated by Δx/2 and Δy/2 in the x and y directions for a RegRectilinearGrid), rather than on the grid cells defined by the grid object itself. A CellStresses object holds a list of stresses on the ocean where each element is from a single floe within grid cell. The ith element of the τx and τy fields are measures of the total stress from the ith floe in the cell and the npoints field is a measure of how many of the ith floe's sub-floe points contributed to the running total of the stress. Again, each element in the list corresponds to one floe, which is denoted in the corresponding CellFloes matrix within the grid. \n\nFields\n\nτx::Vector{FT}: list of total x-stress caused by each floe in a cell on the ocean\nτy::Vector{FT}: list of total y-stress caused by each floe in a cell on the ocean\nnpoints::Vector{Int}: list of total number of sub-floe points contributing to each individial floe's stress\n\nHere is how to construct a CellStresses object:\n\nCellStresses([FT = Float64]; τx = nothing, τy = nothing, npoints = nothing)\n\nPositional arguments\n\nFT::Type{<:AbstractFloat}: Float type used to run the simulation, either Float64 (default) or Float32.\n\nKeyword arguments\n\nτx::Vector{FT}: list of total x-stress caused by each floe in a cell on the ocean\nτy::Vector{FT}: list of total y-stress caused by each floe in a cell on the ocean\nnpoints::Vector{Int}: list of total number of sub-floe points contributing to each individial floe's stress\n\nnote: Note\nIf no keyword arguments are provide by the user, an CellStresses object with empty fields will be created. This is the standard useage of these objects and they are added to during the coupling step. If keyword arguments are provided, then all three must be provided and each vector must be the same size.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.TopographyField","page":"API Reference","title":"Subzero.TopographyField","text":"TopographyField{FT}\n\nAlias for StructArray type with TopographyElement elements with data of type FT.\n\nnote: Note\nThis is not designed to be used by users, but is useful for dispatch by developers. \n\n\n\n\n\n","category":"type"},{"location":"","page":"Introduction","title":"Introduction","text":"Subzero","category":"page"},{"location":"#Subzero","page":"Introduction","title":"Subzero","text":"(Image: Subzero.jl)\n\n(Image: Docs) (Image: CI) (Image: CodeCov) (Image: Status)\n\nFast and Flexible Sea Ice Dynamics\n\nSubzero.jl is a native Julia discrete-element model (DEM) for exploring fine-scale sea ice dynamics,  reimplementing and enhancing MATLAB model SubZero by Manucharyan and Montemuro.\n\n🚀 Runs over 35 times faster that original MATLAB model for title simulation!\n🧩 Modular simulation model makes it easy to customize simulations!\nEnable and disable physical processes such as fracturing, ridging, and welding\nChoose algorithms for key processes (or add your own!)\n\nDocumentation\n\nTo learn how to build and run simulations, check out our documentation and tutorials!\n\nInstallation\n\nSubzero is not yet a registered Julia package. So to install it,\n\nDownload Julia (version 1.9 or later).\nLaunch Julia and enter into the package manager mode by typing ] in the terminal.\nRun the following\n\npkg> add \"git@github.com:Caltech-OCTO/Subzero.jl.git\"\n\nThis will add the package to your package manager. After that you return to the REPL mode by hitting the backspace and you are ready to use Subzero! \n\njulia> using Subzero\n\nCiting\n\nIf you use Subzero.jl as part of your research, teaching, or other activities, we would be grateful if you could cite our work. We are currently working on a JOSS paper, which will be linked here. If you are ready to publish before that, please reach out to us to discuss citations.\n\nContributing\n\nIf you’re interested in contributing to the development Subzero, we would love to have you! We welcome all kinds of contributions from bug reports, to documentation, to features, and suggestions. We can't wait to talk to you.\n\nPlease check out our contributers' guide for more details.\n\nAuthors\n\nPrimary Author: Skylar Gering (@skygering)\n\nThe list of Subzero contributors:\n\n(Image: Contributers)\n\n\n\n\n\n","category":"module"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"../literate/tutorial.jl\"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is the user tutorial for Subzero.jl. It will walk you through the typical workflow of buidling a discrete-element model (DEM) with Subzero.jl as well as running and plotting your simulatuion.","category":"page"},{"location":"tutorial/#Tutorial-copy-pasteable-version","page":"Tutorial","title":"Tutorial - copy-pasteable version","text":"","category":"section"},{"location":"tutorial/#Core-ideas-behind-Subzero.jl-simulations","page":"Tutorial","title":"Core ideas behind Subzero.jl simulations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The very first step of running a Subzero simulation is to bring the package into scope.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Subzero  # bring Subzero into scope\nusing CairoMakie, GeoInterfaceMakie # bring plotting packages into scope\nimport GeoInterface as GI","category":"page"},{"location":"tutorial/#Creating-a-Grid","page":"Tutorial","title":"Creating a Grid","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Each Subzero model requires a grid object. The grid object defines the grid for the ocean and atmosphere. Ocean and atmosphere vectors (like u and v velocities) and tracers (like temperature) are recorded on these grid points and grid lines. The grid points are then used for interpolation for coupling between the ice, ocean, and atmosphere.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"All Subzero grid objects are concrete types of the abstract type AbstractRectilinearGrid. Right now, all grid objects must be Rectilinear. Currently the only implemented concrete type is a RegRectilinearGrid. If you are interested in implementing another type of grid, see the developer documentation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, we will go ahead and create an instance of RegRectilinearGrid. We need to specify the grid endpoints and either the number of grid cells in both directions, or the size of the grid cells. Here we will specity the number of grid cells in the x-direction, Nx, and in the y-direction, Ny.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"grid = RegRectilinearGrid(; x0 = -1e5, xf = 1e5, y0 = 0.0, yf = 1e5, Nx = 20, Ny = 10)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We plot a dashed box around the grid so that we can see the that the grid matches the extent given. We also place tick-marks at the desired grid cell lengths. Finally, set the plot's aspect ration to 2 as the x-extent is two-times larger than the y-extent.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fig = Figure();\nax1 = Axis(fig[1, 1];  # set up axis tick marks to match grid cells\n    title = \"Grid Setup\",\n    xticks = range(grid.x0, grid.xf, 5), xminorticks = IntervalsBetween(5),\n    xminorticksvisible = true, xminorgridvisible = true, xticklabelrotation = pi/4,\n    yticks = range(grid.y0, grid.yf, 3), yminorticks = IntervalsBetween(5),\n    yminorticksvisible = true, yminorgridvisible = true,\n)\nlines!(  # plot boundary of grid with a dashed line\n    [grid.x0, grid.x0, grid.xf, grid.xf, grid.x0],  # point x-values\n    [grid.y0, grid.yf, grid.yf, grid.y0, grid.y0];  # point y-values\n    linestyle = :dash, linewidth = 3.0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Resize grid to layout","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"colsize!(fig.layout, 1, Aspect(1, 2))\nresize_to_layout!(fig)\nfig  # display the figure","category":"page"},{"location":"tutorial/#Creating-Boundaries","page":"Tutorial","title":"Creating Boundaries","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, each Subzero.jl model needs a Domain. A Domain defines the region of the grid that the ice floes are allowed in, what happens to them when they reach the boundaries of that region, and if there is any topography in the model, along with the ice, in that region.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly to the grid above, the Domain will be rectilinear, defined by four boundaries, one for each of the cardinal direction. You will be able to pass each of the cardinal directions (North, South, East, and West), defined as types by Subzero, to the boundary constructors. Each boundary can have different behavior, allowing the user to create a wide variety of domain behavior. Right now, four types of AbstractBoundaries are implemented: OpenBoundary, PeriodicBoundary, CollisionBoundary, and MovingBoundary.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this example, we will use two CollisionBoundary walls and two PeriodicBoundary walls to create a channel that the ice can infinitly flow through, from the east back to the west. In the north and the south, the ice will collide with the boundaries, as if there was shoreline preventing it from leaving the channel.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will use the grid we made above to define the boundaries so that they exactly border the grid.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"north_bound = CollisionBoundary(North; grid)\nsouth_bound = CollisionBoundary(South; grid)\neast_bound = PeriodicBoundary(East; grid)\nwest_bound = PeriodicBoundary(West; grid)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If we plot the polygons that are created within each boundary object, we can see that they border the grid. These polygons are how we well when the ice floes are interacting with each of the boundaries. We can also see that the boundaries overlap in the corners to ensure there is a solid border around the grid. The PeriodicBoundary elements are in purple while the CollisionBoundary elements are in teal.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"poly!(   # plot each of the boundaries with a 50% transparent color so we can see the overlap\n    [north_bound.poly, south_bound.poly, east_bound.poly, west_bound.poly];\n    color = [(:purple, 0.5), (:purple, 0.5), (:teal, 0.5), (:teal, 0.5)],\n)\nax1.title = \"Grid and Boundary Setup\"\nfig  # display the figure","category":"page"},{"location":"tutorial/#Creating-Topography","page":"Tutorial","title":"Creating Topography","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We then have the option to add in a TopographyField, which is a collection of TopographyElements. If we want to add in topography field, we can create one using the initialize_topography_field function. Here we will create two islands in the channel. For simplcity, both will be triangles. I create the polygons that define the shape of each island using GeoInterface and defining the points with tuples:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"island1 = GI.Polygon([[(-6e4, 7.5e4), (-4e4, 5e4), (-2.5e4, 7e4), (-6e4, 7.5e4)]])\nisland2 = GI.Polygon([[(5e4, 2.5e4), (5e4, 5.5e4), (7.5e4, 3e4), (5e4, 2.5e4)]])\ntopo_list = [island1, island2]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then pass these to initialize_topography_field with the polys keyword. We could also have defined them just by their coordinates and passed in the coordiantes by the coords keyword.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"topo_field = initialize_topography_field(; polys = topo_list)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now plot the topography within the domain.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"topo_color = RGBf(115/255, 93/255, 55/255)  # brown color for topography\npoly!(topo_field.poly; color = topo_color) # plot the topography\nax1.title = \"Grid and Domain Setup\"\nfig  # display the figure","category":"page"},{"location":"tutorial/#Creating-a-Domian","page":"Tutorial","title":"Creating a Domian","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We now have all of the pieces needed to create a Domain. We will combine the four (4) boundaries we created, and the topography, into one Domain object. The collection of boundaries and topography define where the floes can and cannot go in the simulation and add in boundary behavior.We can do that as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"domain = Domain(; north = north_bound, south = south_bound, east = east_bound, west = west_bound, topography = topo_field)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nWe could have skipped adding the topography to the domain. That is an optional   keyword and an empty topography field will be automatically created if the user does not   provide one.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"At this point, we have already plotted all of the Domain objects, so we will move in to adding environmental forcing from the ocean and the atmosphere.","category":"page"},{"location":"tutorial/#Creating-an-Ocean","page":"Tutorial","title":"Creating an Ocean","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can provide a ocean velocity and temperature fields to drive the floes within the simulatation. By default, this is a static vector field and does not change throughout the simulation. However, if you are interested in updating the code to make it easier to update the ocean/atmosphere fields throughout the simulation please see issue #111.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can either provide a single constant value for each of the fields (and then also provide the grid as input) or provide a user-defined field. If providing a user-defined field, the field should be of size (grid.Nx + 1, grid.Ny + 1). The rows represent velocities at the x-values of the grid (from x0 to xf), while the columns represent velocities at the the y-values of the grid (from y0 to yf). This makes it easy to index into the grid for values at point (x, y). If x is the ith x-value between x0 to xf and y is the jthe jth y-value between y0 to yf then you simply retrive the field values at index [i, j]. This does mean that the fields provided don't \"look\" like the grid when output directly in the terminal and would need to be transposed instead.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we will then define a u-velocity field that will impose a shear flow on the floes so that ocean is flowing faster in the middle of the y-values (at 0.25 m/s) and then symetrically slowing to 0m/s at the edges where the CollisionBoundary elements are. We will then provide a constant temperature of -1 C and a constant v-velocity of 0m/s.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function shear_flow(Nx, Ny, min_u, max_u)\n    increasing = true\n    curr_u = min_u\n    Δu = fld(Nx, 2)  # divide Nx by 2 and round down\n    u_vals = zeros(Nx, Ny)\n    for (i, col) in enumerate(eachcol(u_vals))\n        (i == 1 || i == Ny) && continue  # edges already set to 0m/s\n        col .= curr_u\n        if increasing && curr_u == max_u  # reach max value and start decreasing velocity\n            increasing = false\n        end\n        if increasing  # update velocity for next column\n            curr_u += Δu\n        else\n            curr_u -= Δu\n        end\n    end\n    return curr_u\nend\n\nu_vals = shear_flow(grid.Nx + 1, grid.Ny + 1, 0.0, 0.25)\nocean = Ocean(; u = u_vals, v = 0.0, temp = -1.0, grid)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now plot our ocean velocity values on an axis below our grid and domain setup.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ax2 = Axis(fig[2, 1]; title = \"Ocean U-Velocities [m/s]\", xticklabelrotation = pi/4)\nxs = grid.x0:grid.Δx:grid.xf\nys = grid.y0:grid.Δy:grid.yf\nu_hm = heatmap!(ax2, xs, ys, ocean.u)\nColorbar(fig[2, end+1], u_hm)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nThe heatmap   already transposes the matrix input, assuming, as we do, that you index into the   matrix with x-values for rows and y-values for columns. If you want to see your   input as it would look on the grid, rather than manually transposing, just use the   heatmap function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Since the other ocean fields are constant values for each index, we won't plot these.","category":"page"},{"location":"tutorial/#Creating-an-Atmosphere","page":"Tutorial","title":"Creating an Atmosphere","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The atmosphere works almost iddntically to the Ocean. It also requires inputs for u-velocities, v-velocities, and temperature and these fields are considered static throughtout the simulation by default. Again, if you are interested in changing this, please see issue #111.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Just like with the Ocean constructor, you can either provide the Atmos constructor a single constant value for each of the fields (and then also provide the grid as input) or provide a user-defined field.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, we will just provide constant values of 5m/s for the u-velocities, 0.0m/s for the v-velocities and 0 C for the temperature. If you are intersted in providing non-constant fields, see the Ocean example above.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"atmos = Atmos(; grid, u = 5.0, v = 0.0, temp = 0.0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Again since all of the fields are constant, we won't plot them, but you can, using the heatmap function as shown above.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
