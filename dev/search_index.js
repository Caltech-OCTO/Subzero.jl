var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = Subzero","category":"page"},{"location":"api/#Full-Subzero-API-documentation","page":"API Reference","title":"Full Subzero API documentation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"warning: Warning\nThis page is still very much WIP!","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Documentation for Subzero's full API (only for reference!).","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#All-methods","page":"API Reference","title":"All methods","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Subzero]","category":"page"},{"location":"api/#Subzero.Subzero","page":"API Reference","title":"Subzero.Subzero","text":"Module Subzero.jl - UW's sea ice model ported from MATLAB to Julia\n\n\n\n\n\n","category":"module"},{"location":"api/#Subzero.NonPeriodicBoundary","page":"API Reference","title":"Subzero.NonPeriodicBoundary","text":"NonPeriodicBoundary\n\nUnion of all non-peridic boundary types to use as shorthand for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.AbstractBoundary","page":"API Reference","title":"Subzero.AbstractBoundary","text":"AbstractBoundary{D<:AbstractDirection, FT}<:AbstractDomainElement{FT}\n\nAn abstract type for the types of boundaries at the edges of the model domain. Boundary types will control behavior of sea ice floes at edges of domain. The direction given by type D denotes which edge of a domain this boundary could be and type FT is the simulation float type (e.g. Float64 or Float32).\n\nEach boundary type has the coordinates of the boudnary as a field. These should be shapes that completely seal the domain, and should overlap on the corners as seen in the example below:  ________________ ||____val___|| <- North coordinates include corners |  |          |  | |  |          |  | <- East and west coordinates ALSO include corners |  |          |  | Each bounday type also has a field called \"val\" that holds value that defines the line y = val or x = val (depending on boundary direction), such that if the floe crosses that line it would be partially within the boundary. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.AbstractDirection","page":"API Reference","title":"Subzero.AbstractDirection","text":"AbstractDirection\n\nAn abstract type for the boundary cardinal directions within model domain. Boundary direction will control behavior of sea ice floes at edges of domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.AbstractDomainElement","page":"API Reference","title":"Subzero.AbstractDomainElement","text":"AbstractDomainElement{FT<:AbstractFloat}\n\nAn abstract type for all of the element that create the shape of the domain: the 4 boundary walls that make up the rectangular domain and the topography within the domain. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.AbstractFractureCriteria","page":"API Reference","title":"Subzero.AbstractFractureCriteria","text":"AbstractFractureCriteria\n\nAbstract type for fracture criteria. Each struct of this type must have a vertices field representing the criteria in principal stress space. For a given polygon, the minimum and maximum eigenvalues of its stress field will be its location in principal stress space. If that stress point falls outside of the criteria-verticies defined polygon it is a stress great enough to fracture the floe. Otherwise the floe will not be fractured. Each fracture criteria type must also have an update_criteria! function defined that is used to update the criteria each timestep. If the criteria does not need to be updated, this function can be empty.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.AbstractGrid","page":"API Reference","title":"Subzero.AbstractGrid","text":"AbstractGrid\n\nAn abstract type for the grid that model will be simulated on. Affects calculation on the grid.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.AbstractOutputWriter","page":"API Reference","title":"Subzero.AbstractOutputWriter","text":"AbstractOutputWriter\n\nAn abstract type for output writers that provide data from simulation runs.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.AbstractStressCalculator","page":"API Reference","title":"Subzero.AbstractStressCalculator","text":"abstract type AbstractStressCalculator{FT <: AbstractFloat}\n\nAbstract super type for stress calculators, which calculate a floe's stress from floe interactions. The subtypes serve as dispatch types for the following three calculation methods.\n\nAPI\n\nThe following methods must be implemented for all subtypes:\n\n_update_stress_accum!(stress_calculator::AbstractStressCalculator{FT}, curr_stress::Matrix{FT} , floe::FloeType{FT})\n_scale_principal_stress!(stress_calculator::AbstractStressCalculator{FT}, σvals::Matrix{FT}, floe::FloeType{FT}, floe_settings::FloeSettings)\n\n_update_stress_accum! is called in the calc_stress! function and takes the stress calculator, the floe's instantatious stress at the current timestep, and the floe itself and updates the floe's stress_accum field, which is used when determining floe fracture based off of stress. Within the function, other floe fields can be updated as needed.\n\n_scale_principal_stress! is called within the find_σpoint function which is called within the determine_fractures function. This function takes the stress calculator, the floe's accumulated stress in prinicpal stress space (σvals = eigvals(stress_accum)), the floe itself, and the floe_settings and scales σvals by some values/ratio using physical properties within floe and floe_settings. This is done to approximate changing the polygon defining the floe's fracture criteria without having to redefine the fracture  criteria for each floe. This is almost like a proxy for damage. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.AbstractSubFloePointsGenerator","page":"API Reference","title":"Subzero.AbstractSubFloePointsGenerator","text":"AbstractSubFloePointsGenerator\n\nAbstract type for parameters determining generation of sub-floe points used for interpolation. The points generated using these parameters will be used to find stresses on each floe from the ocean and the atmosphere. There must be a generate_subfloe_points function that dispatches off of the subtype of AbstractSubFloePointsGenerator to generate the points for a given floe. Points generated must all be within a given floe.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.Atmos","page":"API Reference","title":"Subzero.Atmos","text":"Atmos velocities in the x-direction (u) and y-direction (v). u and v should match the size of the corresponding model grid so that there is one x and y velocity value for each grid cell. Atmos also needs temperature at the atmosphere/ice interface in each grid cell. Model cannot be constructed if size of atmos fields and grid do not match.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.Atmos-Tuple","page":"API Reference","title":"Subzero.Atmos","text":"Atmos(args...)\n\nIf a type isn't specified, Atmos will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.Atmos-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.Atmos","text":"Atmos{FT}(grid, u, v)\n\nConstruct model atmosphere of type FT. Inputs:     grid        <AbstractGrid> model's grid      u           <Real> Atmos x-velocity for each grid cell     v           <Real> Atmos y-velocity for each grid cell     temp        <Real> temperature at atmopshere/ice interface per grid cell Output:      Atmosphere of type FT with constant velocity and temperature over domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.Atmos-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.Atmos","text":"Atmos(::Type{FT}, args...)\n\nA float type FT can be provided as the first argument of any Atmos constructor. An Atmos of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.CellFloes","page":"API Reference","title":"Subzero.CellFloes","text":"CellFloes{FT<:AbstractFloat}\n\nStruct that tracks which floes are within given cell, as well as the translation vector needed to move floe each from current postion into cell if it is in cell due to periodic boundaries. Each index in floeidx is the index of a floe within the cell and the Δx and Δy with the same index are that floe's translation vector. Note: the floeidx is the index of grid cells centered on grid lines, not on the grid cells defined by the regular, rectilinear grid. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.CellFloes-Union{Tuple{}, Tuple{FT}} where FT","page":"API Reference","title":"Subzero.CellFloes","text":"CellFloes{FT}()\n\nConstructs an CellFloes object with empty lists for fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.CheckpointOutputWriter","page":"API Reference","title":"Subzero.CheckpointOutputWriter","text":"CheckpointOutputWriter(writer::CheckpointOutputWriter, [Δtout]; kwargs...)\n\nCreates an checkpoint writer from an existing writer, copying all fields unless new field values are explicity provided either as the optional argument Δtout or through keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.CheckpointOutputWriter-2","page":"API Reference","title":"Subzero.CheckpointOutputWriter","text":"CheckpointOutputWriter(Δtout, fn){ST<:AbstractString}<:AbstractOutputWriter\n\nCheckpoint subtype of AbstractOutputWriter that holds information for outputting checkpoint information used for restarting the simulation from a point where the writer saved data. Checkpoint data is saved every Δtout timesteps to filepath. If the given file doesn't end in \".jld2\" the extension will be appended. If overwrite is true then if there is already a file of the given name, it will be overwriten. Else it will thrown an error. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.CheckpointOutputWriter-Tuple{Any}","page":"API Reference","title":"Subzero.CheckpointOutputWriter","text":"CheckpointOutputWriter(\n    Δtout;\n    dir = \".\",\n    filename = \"checkpoint.jld2\",\n    overwrite = false,\n    jld2_kw = Dict{Symbol, Any}(),\n)\n\nCheckpointOutputWriter writer that outputs need data to restart simulation at given timesteps Δtout. Inputs:     Δtout       <Int> number of timesteps between output     dir         <String> Directory to save output to - default is \".\" (current                     working directory).     filename    <String> filename to save file to     overwrite   <Bool> if true, exit file of the same name will be deleted, else                     an error will be thrown if other file exists     jld2_kw     list of JLD2 keywords for the jldopen function Outputs: CheckpointOutputWriter that outputs floes, ocean, and atmosphere states at desired timesteps. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.CollisionBoundary","page":"API Reference","title":"Subzero.CollisionBoundary","text":"CollisionBoundary <: AbstractBoundary\n\nA sub-type of AbstractBoundary that stops a floe from exiting the domain by having the floe collide with the boundary. The boundary acts as an immovable, unbreakable ice floe in the collision. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.CollisionBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D<:Subzero.AbstractDirection, FT<:AbstractFloat}","page":"API Reference","title":"Subzero.CollisionBoundary","text":"CollisionBoundary{D, FT}(grid)\n\nCreates collision boundary on the edge of the grid, and with the direction as a type. Edge is determined by direction. Inputs:     grid        <AbstractGrid> model grid     direction   <AbstractDirection> direction of boundary wall Outputs:     Collision Boundary on edge of grid given by direction. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT<:AbstractFloat, D<:Subzero.AbstractDirection}","page":"API Reference","title":"Subzero.CollisionBoundary","text":"CollisionBoundary(::Type{FT}, ::Type{D}, args...)\n\nA float type FT can be provided as the first argument of any CollisionBoundary constructor. The second argument D is the directional type of the boundary. A CollisionBoundary of type FT and D will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D<:Subzero.AbstractDirection","page":"API Reference","title":"Subzero.CollisionBoundary","text":"CollisionBoundary(::Type{D}, args...)\n\nIf a float type isn't specified, CollisionBoundary will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.CollisionSettings","page":"API Reference","title":"Subzero.CollisionSettings","text":"CollisionSettings{FT<:AbstractFloat}\n\nSettings needed for collisions within the model.  If collisionson is true, collisions will occur, else they will not. The floefloemaxoverlap defines the percentage of overlap allowed between floes before marking them for ridging/rafting. The floedomainmaxoverlap defines the percentage of overlap allowed between floes and the domain (collision boundaries and topography) before removing the floe from the simulation.  Both floefloemaxoverlap and floedomainmaxoverlap should be between 0-1 and if a value < 0 is given or a value > 1 is given when collisionson is true they will be set to 0 and 1 respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.CollisionSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.CollisionSettings","text":"CollisionSettings(::Type{FT}, kwargs...)\n\nA float type FT can be provided as the first argument of any CollisionSettings constructor. A CollisionSettings of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.Constants-Tuple","page":"API Reference","title":"Subzero.Constants","text":"Constants(args...)\n\nIf a type isn't specified, Constants will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.Constants-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.Constants","text":"Constants(::Type{FT}, args...)\n\nA float type FT can be provided as the first argument of any Constants constructor. A Constants of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.CouplingSettings","page":"API Reference","title":"Subzero.CouplingSettings","text":"CouplingSettings\n\nSettings needed for coupling within the model. If couplingon is true, the model will be coupled with the simulation's ocean and atmosphere. The Δt determines how many simulation timesteps between calculating ocean and atmospheric forces on the floes. Δd number of buffer grid cells on each side of floe for monte carlo interpolation and mcn is the number of monte carlo points to attempt to generage for each floe. If twowaycoupling_on is true then the simulation calculates the stress the ice/atmosphere put on the ocean. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.DamageStressCalculator","page":"API Reference","title":"Subzero.DamageStressCalculator","text":"DamageStressCalculator{FT<:AbstractFloat} <: AbstractStressCalculator{FT}\n\nType of AbstractStressCalculator that calculates stress with each timestep with damage * stress_instant, as suggested by Mukund Gupta. This method could keep track of damage directly within each floe using the damage floe field, perhapes as a value between 0-1, and rather than calculating an \"accumulated stress\" to store damage, as done in DecayAreaScaledCalculator.\n\nIn this calculator, the floe's damage field keeps track of an explicit parameter.\n\nFields:\n\nNote:\n\nThis method is not implemented and thus throws an error upon creation. The infrastructure for the damage calculator is provided, but functions that depend on this calculator need to be implemented as detailed in the AbstractStressCalculator API. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.DamageStressCalculator-Tuple","page":"API Reference","title":"Subzero.DamageStressCalculator","text":"DamageStressCalculator(; kwargs...)\n\nIf type isn't specified, DamageStressCalculator(; kwargs...) will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.DamageStressCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.DamageStressCalculator","text":"DamageStressCalculator(::Type{FT}; kwargs...)\n\nA float type FT can be provided as the first argument of any DamageStressCalculator constructor. A DamageStressCalculator of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.DecayAreaScaledCalculator","page":"API Reference","title":"Subzero.DecayAreaScaledCalculator","text":"DecayAreaScaledCalculator{FT<:AbstractFloat} <: AbstractStressCalculator{FT}\n\nType of AbstractStressCalculator that implements stress calculations by accumulating each timestep of stress using a decay equation. The decay aspect increases importance placed on new damage. The decay equation is as follows:\n\n`stressaccum = stressaccum(1-λ) + stress_instant(λ)\n\nThe area-scaling part of the stress calculations comes into play when deciding if a floe will be fractured. The accumulated stress can be scaled by a ratio of (floe.area/minfloearea)^α. By changing the α value, either larger or smaller floes fracture more eassily. The scaled value will not be saved as this is equivalent to scaling the simulation fracture criteria (morh's cone or hibler's ellipse, etc.), but it is less computationally intensive. By leaving the default α = 0, this extra scaling will not take place.\n\nFields:\n\nλ::AbstractFloat: decay parameter used when calculating accumulated stress. Should be between 0 - 1.\nα::AbstractFloat: Adjusts ellipse in stress space by raising the ratio to the floe's area over the simulation minimum floe size to α.\n\nNote:\n\nλ is used in _update_stress_accum!, whereas α is used in _scale_principal_stress!.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.DecayAreaScaledCalculator-Tuple","page":"API Reference","title":"Subzero.DecayAreaScaledCalculator","text":"DecayAreaScaledCalculator(; kwargs...)\n\nIf type isn't specified as the first argument, DecayAreaScaledCalculator(; kwargs...) will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.DecayAreaScaledCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.DecayAreaScaledCalculator","text":"DecayAreaScaledCalculator(::Type{FT}; kwargs...)\n\nA float type FT can be provided as the first argument of any DecayAreaScaledCalculator constructor. A DecayAreaScaledCalculator of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.Domain","page":"API Reference","title":"Subzero.Domain","text":"Domain that holds 4 Boundary elements, forming a rectangle bounding the model during the simulation, and a list of topography elements.\n\nIn order to create a Domain, three conditions need to be met. First, if needs to be periodically compatible. This means that pairs of opposite boundaries both need to be periodic if one of them is periodic. Next, the value in the north boundary must be greater than the south boundary and the value in the east boundary must be greater than the west in order to form a valid rectangle.\n\nNote: The code depends on the boundaries forming a rectangle oriented along the cartesian grid. Other shapes/orientations are not supported at this time. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.Domain-Union{Tuple{WB}, Tuple{EB}, Tuple{SB}, Tuple{NB}, Tuple{FT}, Tuple{NB, SB, EB, WB}} where {FT<:AbstractFloat, NB<:AbstractBoundary{North, FT}, SB<:AbstractBoundary{South, FT}, EB<:AbstractBoundary{East, FT}, WB<:AbstractBoundary{West, FT}}","page":"API Reference","title":"Subzero.Domain","text":"Domain(north, south, east, west)\n\nCreates domain with empty list of topography and given boundaries. Inputs:     north   <AbstractBoundary> north boundary     south   <AbstractBoundary> south boundary     east    <AbstractBoundary> east boundary     west    <AbstractBoundary> west boundary\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.East","page":"API Reference","title":"Subzero.East","text":"East<:AbstractDirection\n\nA simple direction type representing if a boundary is the eastern boundary in a rectangular domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.Floe","page":"API Reference","title":"Subzero.Floe","text":"Singular sea ice floe with fields describing current state.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.Floe-Tuple","page":"API Reference","title":"Subzero.Floe","text":"Floe(args...)\n\nIf a type isn't specified, Floe will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.Floe-Union{Tuple{FT}, Tuple{Array{Array{Vector{T}, 1}, 1} where T<:Real, Any, Any}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.Floe","text":"Floe{FT}(\n    coords::PolyVec,\n    hmean,\n    Δh;\n    ρi = 920.0,\n    mc_n = 1000,\n    rng = Xoshiro(),\n    kwargs...,\n)\n\nFloe constructor with PolyVec coordinates Inputs:     coords              <Vector{Vector{Vector{Float64}}}> floe coordinates     hmean               <Real> mean height for floes     Δh                  <Real> variability in height for floes     floe_settings       <FloeSettings> settings needed to initialize floe     rng                 <RNG> random number generator to generate random floe                             attributes - default uses Xoshiro256++ algorithm     kwargs              Any other floe fields to set as keyword arguments Output:     <Floe> with needed fields defined - all default field values used so all     forcings start at 0 and floe's status is \"active\" as long as monte carlo     points were able to be generated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.Floe-Union{Tuple{FT}, Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T<:AbstractFloat, Any, Any}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.Floe","text":"Floe{FT}(\n    poly::Polys,\n    hmean,\n    Δh;\n    floe_settings = FloeSettings(),\n    rng = Xoshiro(),\n    kwargs...\n)\n\nConstructor for floe with a polygon Inputs:     poly                <Polygon>      hmean               <Real> mean height for floes     Δh                  <Real> variability in height for floes     floe_settings       <FloeSettings> settings needed to initialize floe             rng                 <RNG> random number generator to generate floe                             attributes - default is Xoshiro256++ algorithm     kwargs      Any other floe fields to set as keyword arguments Output:     <Floe> with needed fields defined - all default field values used so all         forcings start at 0 and floe's status is \"active\" as long as monte carlo         points were able to be generated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.Floe-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.Floe","text":"Floe(::Type{FT}, args...; kwargs...)\n\nA float type FT can be provided as the first argument of any Floe constructor. A Floe of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.FloeOutputWriter","page":"API Reference","title":"Subzero.FloeOutputWriter","text":"FloeOutputWriter(writer::FloeOutputWriter, [Δtout]; kwargs...)\n\nCreates an floe output writer from an existing writer, copying all fields unless new field values are explicity provided either as the optional argument Δtout or through keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.FloeOutputWriter-2","page":"API Reference","title":"Subzero.FloeOutputWriter","text":"FloeOutputWriter{ST<:AbstractString}<:AbstractOutputWriter\n\nFloe subtype of AbstractOutputWriter that holds information for outputting floe information from model throughout simulation. Output will be saved to the file defined by fn every Δtout timesteps. Only outputs within the outputs list will be saved. File will be saved as a JLD2 file to filepath. If the given file doesn't end in \".jld2\" the extension will be appended. If overwrite is true then if there is already a file of the given name, it will be overwriten. Else it will thrown an error. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.FloeOutputWriter-Tuple{Any}","page":"API Reference","title":"Subzero.FloeOutputWriter","text":"function FloeOutputWriter(\n    Δtout;\n    outputs = collect(fieldnames(Floe)),\n    dir = \".\",\n    filename = \"floes.jld2\",\n    overwrite = false,\n    jld2_kw = Dict{Symbol, Any}(),\n)\n\nFloeOutput writer that outputs provided Floe fields at given timesteps Δtout and saves the information in a file of the provided name. Inputs:     Δtout       <Int> number of timesteps between output     outputs     <Vector{Symbols}> list of floe fields to output     dir         <String> Directory to save output to - default is \".\" (current                     working directory)     filename    <String> filename to save file to     overwrite   <Bool> if true, exit file of the same name will be deleted, else                     an error will be thrown if other file exists     jld2_kw     list of JLD2 keywords for the jldopen function Outputs:     FloeOutputWriter that outputs provided Floe fields every Δtout timesteps to     filename Note: If floe field's are not specified using outputs, all Floe fields will be saved\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.FloeSettings","page":"API Reference","title":"Subzero.FloeSettings","text":"FloeSettings\n\nSettings needed to create floes within the model.\n\nρi is the density of all floes within the model\nminfloearea is the minimum floe area within the model before removal\nminfloeheight is the minimum floe height within the model before removal\nmaxfloeheight is the maximum floe height within the model before the height   can't increase any further\nminaspectratio is the minimum ratio between the x-length and y-length of any   floe prior to removal\nsubfloepointgenerator is the method of subfloe point generation for each   floe within the model\nstress_calculator is the method of calculating current stress of floe\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.FloeSettings-Union{Tuple{Type{FT}}, Tuple{CT}, Tuple{GT}, Tuple{FT}} where {FT<:AbstractFloat, GT<:Subzero.AbstractSubFloePointsGenerator, CT<:AbstractStressCalculator}","page":"API Reference","title":"Subzero.FloeSettings","text":"FloeSettings(::Type{FT}; subfloe_point_generator, kwargs...)\n\nA float type FT can be provided as the first argument of any FloeSettings constructor. A FloeSettings of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.FractureSettings","page":"API Reference","title":"Subzero.FractureSettings","text":"FractureSettings{CT<:AbstractFractureCriteria}\n\nSettings needed for fractures within the model.  If fractureson is true, fractures will occur, else they will not. The criteria defines which fracture criteria are used to determine which floes to fracture. The Δt determines how many simulation timesteps between fracturing floes. If deformon is true, then the floe will be deformed around floe primarily causing the fracture, identified by the largest overlap area on the most recent set of collisions. Npieces denotes how many pieces to try to split a fractured floe into - 3 is suggested value.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.GridOutputWriter","page":"API Reference","title":"Subzero.GridOutputWriter","text":"GridOutputWriter{FT<:AbstractFloat}<:AbstractOutputWriter\n\nGrid subtype of AbstractOutputWriter that holds information for outputting floe data on the grid. This output does not need to be the grid defined for the model. This grid can be coarser, or more fine, as defined by the xg and yg fields. Output on this scale will be saved to the file defined by filepath every Δtout timesteps. Data will be collected in the data field during calculation for easier writing to the NetCDF file. Only outputs within the outputs list will be saved. There is a limited number of floe outputs that can be calculated by the GridOutputWriter.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.GridOutputWriter-Tuple","page":"API Reference","title":"Subzero.GridOutputWriter","text":"GridOutputWriter(args...; kwargs...)\n\nIf a type isn't specified, GridOutputWriter will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.GridOutputWriter-Tuple{GridOutputWriter}","page":"API Reference","title":"Subzero.GridOutputWriter","text":"GridOutputWriter(writer::GridOutputWriter, [Δtout]; kwargs...)\n\nCreates an grid output writer from an existing writer, copying all fields unless new field values are explicity provided through keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Any, AbstractGrid, Any}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.GridOutputWriter","text":"GridOutputWriter{FT}(     outputs::Vector{Symbol},     Δtout,     grid::AbstractGrid,     dims;     dir = \".\",     filename = \"gridded_data.nc\",     overwrite = false,     average = false,\n\nCreate GridOutputWriter for grid of given dimensions to output floe data averaged on this re-gridded gird at given frequency of timesteps. Only outputs provided outputs. Inputs:     outputs     <Vector{Symbols}> list of grid outputs desired     Δtout       <Int> number of timesteps between output     grid        <Grid> original grid, which we are re-gridding     dims        <(Int, Int)> output new grid dimensions for these calculations -                 rows -> ny, cols -> nx     dir         <String> Directory to save output to - default is \".\" (current                     working directory)     filename    <String> filename to save file to     overwrite   <Bool> if true, exit file of the same name will be deleted, else                     an error will be thrown if other file exist     average     <Bool> if true, average gridded data over timesteps between                     outputs, else just calculate at output timestep Output:     GridOutputWriter that re-grids grid to given dimensions, and saves floe     information averaged on this new grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.GridOutputWriter","text":"GridOutputWriter(::Type{FT}, args...; kwargs...)\n\nA float type FT can be provided as the first argument of any GridOutputWriter constructor. A GridOutputWriter of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.HiblerYieldCurve","page":"API Reference","title":"Subzero.HiblerYieldCurve","text":"HiblerYieldCurve{FT<:AbstractFloat}<:AbstractFractureCriteria\n\nType of AbstractFractureCriteria that creates a yield curve that determines if a floe fractures based off if its stress in principal stress space  is inside or outside of the yield curve. Fields:     pstar       <AbstractFloat> used to tune ellipse for optimal fracturing     c           <AbstractFloat> used to tune ellipse for optimal fracturing     verticies   <PolyVec> vertices of criteria in principal stress space Note:     Hibler's paper says that: Both pstar and c relate the ice strength to the     ice thickness and compactness. c is determined to that 10% open water     reduces the strength substantially and pstar is considered a free parameter\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.HiblerYieldCurve-Tuple","page":"API Reference","title":"Subzero.HiblerYieldCurve","text":"HiblerYieldCurve(args...)\n\nIf a type isn't specified, HiblerYieldCurve will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.HiblerYieldCurve-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.HiblerYieldCurve","text":"HiblerYieldCurve(::Type{FT}, args...)\n\nA float type FT can be provided as the first argument of any HiblerYieldCurve constructor. A HiblerYieldCurve of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.HiblerYieldCurve-Union{Tuple{StructArrays.StructArray{<:Floe{FT}}}, Tuple{FT}, Tuple{StructArrays.StructArray{<:Floe{FT}}, Any}, Tuple{StructArrays.StructArray{<:Floe{FT}}, Any, Any}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.HiblerYieldCurve","text":"HiblerYieldCurve(floes, pstar = 2.25e5, c = 20.0)\n\nCalculates Hibler's Elliptical Yield curve using parameters pstar, c, and the current floe field.  Inputs:     floes   <StructArray{Floes}> model's list of floes     pstar   <AbstractFloat> used to tune ellipse for optimal fracturing     c       <AbstractFloat> used to tune ellipse for optimal fracturing Outputs:     HiblerYieldCurve struct with vertices determined using the calculatehibler     function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.IceStressCell","page":"API Reference","title":"Subzero.IceStressCell","text":"IceStressCell{FT<:AbstractFloat}\n\nStruct to collect stress from ice floes on ocean grid cells. One IceStressCell corresponds to one grid cell. It holds a list of running totals of stress on the cell, and a running list of the number of points making up those running totals. Each element in the list corresponds to one floe, which is denoted in the corresponding CellFloes matrix within the grid. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.IceStressCell-Union{Tuple{}, Tuple{FT}} where FT","page":"API Reference","title":"Subzero.IceStressCell","text":"IceStressCell{FT}()\n\nConstructs an IceStressCell object with empty lists for fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.InitialStateOutputWriter","page":"API Reference","title":"Subzero.InitialStateOutputWriter","text":"InitialStateOuputWriter<:AbstractOutputWriter\n\nBasic type of AbstractOutputWriter that records the intial state of the simulation. Writes JLD2 file with initial simulation state to the filepath specified. If overwrite is true, and there is a file of the given name at the filepath, that file will be overwritten.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.InitialStateOutputWriter-Tuple{InitialStateOutputWriter}","page":"API Reference","title":"Subzero.InitialStateOutputWriter","text":"InitialStateOutputWriter(writer::InitialStateOutputWriter; kwargs...)\n\nCreates an initial state output writer from an existing writer, copying all fields unless  new field values are explicity provided through keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.InitialStateOutputWriter-Tuple{}","page":"API Reference","title":"Subzero.InitialStateOutputWriter","text":"InitialStateOutputWriter(\n    ;\n    dir = \".\",\n    filename = \"initial_state.jld2\",\n    overwrite = false,\n    jld2_kw = Dict{Symbol, Any}(),\n)\n\nCreates an initial state output writer. Inputs:     dir         <String> path to directory     filename    <String> filename to save file to     overwrite   <Bool> if true, exit file of the same name will be deleted, else                     an error will be thrown if other file exists     jld2_kw     list of JLD2 keywords for the jldopen function Outputs:     Creates InitialStateOutputWriter that will write simulation's initial     state.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.InteractionFields","page":"API Reference","title":"Subzero.InteractionFields","text":"Enum to index into floe interactions field with more intuituve names\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.Model","page":"API Reference","title":"Subzero.Model","text":"Model which holds grid, ocean, atmos structs, each with the same underlying float type (either Float32 of Float64) and size. It also holds the domain information, which includes the topography and the boundaries. It holds a  StructArray of floe structs, again each relying on the same underlying float type. Finally, it also holds the maximum floe id used thus far in the simulation. This should be the length of the floes array at the beginning of the run. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.MohrsCone","page":"API Reference","title":"Subzero.MohrsCone","text":"MohrsCone{FT<:AbstractFloat}<:AbstractFractureCriteria\n\nType of AbstractFractureCriteria that creates a cone in principal stress space that determines if a floe fractures based off if its stress in principal stress space  is inside or outside of the cone. Fields:     verticies   <PolyVec> vertices of criteria in principal stress space Note:     Concepts from the following papter -     Weiss, Jérôme, and Erland M. Schulson. \"Coulombic faulting from the grain     scale to the geophysical scale: lessons from ice.\" Journal of Physics D:     Applied Physics 42.21 (2009): 214017.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.MohrsCone-Tuple","page":"API Reference","title":"Subzero.MohrsCone","text":"MohrsCone(args...)\n\nIf a type isn't specified, MohrsCone will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.MohrsCone-Union{Tuple, Tuple{FT}} where FT","page":"API Reference","title":"Subzero.MohrsCone","text":"MohrsCone{FT}(val::AbstractFloat, args...)\n\nCalculate Mohr's Cone vertices given calculatemohrs arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.MohrsCone-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.MohrsCone","text":"MohrsCone(::Type{FT}, args...)\n\nA float type FT can be provided as the first argument of any MohrsCone constructor. A MohrsCone of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.MonteCarloPointsGenerator","page":"API Reference","title":"Subzero.MonteCarloPointsGenerator","text":"MonteCarloPointsGenerator\n\nSubtype of AbstractSubFloePointsGenerator that defines parameters needed to generate a set of random monte carlo points within a given floe. npoints is the number of monte carlo points to generate within the floe's bounding box - the floe will not end up with this many points as all points outside of the floe will be removed. ntries is the number of tries to generate a set of points within the floe that have a smaller error than err.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.MonteCarloPointsGenerator-Tuple","page":"API Reference","title":"Subzero.MonteCarloPointsGenerator","text":"MonteCarloPointsGenerator(; kwargs...)\n\nIf type isn't specified, MonteCarloPointsGenerator(; kwargs...) will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.MonteCarloPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.MonteCarloPointsGenerator","text":"MonteCarloPointsGenerator(::Type{FT}; kwargs...)\n\nA float type FT can be provided as the first argument of any MonteCarloPointsGenerator constructor. A MonteCarloPointsGenerato of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.MovingBoundary","page":"API Reference","title":"Subzero.MovingBoundary","text":"MovingBoundary <: AbstractBoundary\n\nA sub-type of AbstractBoundary that creates a floe along the boundary that moves towards the center of the domain at the given velocity, compressing the ice within the domain. This subtype is a mutable struct so that the coordinates and val can be changed as the boundary moves. The u and v velocities are in [m/s].\n\nNote that with a u-velocity, east and west walls move towards the center of the domain, providing compressive stress, and with a v-velocity, the bounday creates a shear stress by incorporating the velocity into friction calculations but doesn't actually move. This means that the boundaries cannot move at an angle, distorting the shape of the domain regardless the the combination of u and v velocities. The same, but opposite is true for the north and south walls.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.MovingBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT<:AbstractFloat, D<:Subzero.AbstractDirection}","page":"API Reference","title":"Subzero.MovingBoundary","text":"MovingBoundary(::Type{FT}, ::Type{D}, args...)\n\nA float type FT can be provided as the first argument of any MovingBoundary constructor. The second argument D is the directional type of the boundary. A MovingBoundary of type FT and D will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.MovingBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D<:Subzero.AbstractDirection","page":"API Reference","title":"Subzero.MovingBoundary","text":"MovingBoundary(::Type{D}, args...)\n\nIf a float type isn't specified, MovingBoundary will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.MovingBoundary-Union{Tuple{FT}, Tuple{D}, Tuple{Any, Any, Any}} where {D<:Subzero.AbstractDirection, FT<:AbstractFloat}","page":"API Reference","title":"Subzero.MovingBoundary","text":"MovingBoundary{D, FT}(grid, velocity)\n\nCreates compression boundary on the edge of the grid, and with the direction as a type. Edge is determined by direction. Inputs:         grid        <AbstractGrid> model grid         u    <AbstractFloat> u velocity of boundary         v    <AbstractFloat> v velocity of boundary Outputs:     MovingBoundary on edge of grid given by direction. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.NoFracture","page":"API Reference","title":"Subzero.NoFracture","text":"NoFracture<:AbstractFractureCriteria\n\nSimple AbstractFractureCriteria type representing when fracturing functionality is turned off. If this is the type provided to the simulation's FractureSettings then fractures will not occur.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.North","page":"API Reference","title":"Subzero.North","text":"North<:AbstractDirection\n\nA simple direction type representing if a boundary is the northern boundary in a rectangular domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.Ocean","page":"API Reference","title":"Subzero.Ocean","text":"Ocean{FT<:AbstractFloat}\n\nSimulation ocean holding ocean values on the grid-scale with matricies of the same size as the model's grid. The struct has the following fields:\n\nu is the ocean velocities in the x-direction for each grid cell\nv is the ocean velocities in the y-direction for each grid cell\ntemp is the ocean temperature for each grid cell\nhflx_factor is a factor to calculate the ocean-atmosphere heat flux for a  cell in that grid cell by multiplying by its height\nsi_frac is the fraction of area in each grid cell that is covered in sea-ice\n\nOcean fields must all be matricies with dimensions equal to the number of grid lines in the model's grid.  Note: If a periodic boundary is used in the domain, the last grid cell in that direction will not be used as it is equivalent to the first grid cell. Thus, for all of these fields, the first and last value in the x and/or y direction should be equal if the east-west or north-south boundary pair are periodic respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.Ocean-Tuple","page":"API Reference","title":"Subzero.Ocean","text":"Ocean(args...)\n\nIf a type isn't specified, Ocean will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.Ocean-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.Ocean","text":"Ocean{FT}(grid, u, v, temp)\n\nConstruct model's ocean. Inputs:     grid    <AbstractGrid> model grid     u       <Real> ocean x-velocity for each grid line     v       <Real> ocean y-velocity for each grid line     temp    <Real> temperature at ocean/ice interface per grid cell Output:          Ocean with constant velocity and temperature on each grid line.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.Ocean-Union{Tuple{FT}, Tuple{Any, Any, Any}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.Ocean","text":"Ocean{FT}(u, v, temp)\n\nConstruct model ocean. Inputs:     u       <Matrix> ocean x-velocity matrix with u for each grid line     v       <Matrix> ocean y-velocity matrix with u for each grid line     temp    <Matrix> temperature matrix with ocean/ice interface temperature for                 each grid line Output:      Model ocean with given velocity and temperature fields on each grid line.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.Ocean-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.Ocean","text":"Ocean(::Type{FT}, args...)\n\nA float type FT can be provided as the first argument of any Ocean constructor. An Ocean of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.OpenBoundary","page":"API Reference","title":"Subzero.OpenBoundary","text":"OpenBoundary <: AbstractBoundary\n\nA sub-type of AbstractBoundary that allows a floe to pass out of the domain edge without any effects on the floe.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.OpenBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D<:Subzero.AbstractDirection, FT<:AbstractFloat}","page":"API Reference","title":"Subzero.OpenBoundary","text":"OpenBoundary{D, FT}(grid)\n\nCreates open boundary on the edge of the grid, and with the direction as a type. Edge is determined by direction. Inputs:     grid        <AbstractGrid> model grid Outputs:     Open Boundary on edge of grid given by direction and type. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.OpenBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT<:AbstractFloat, D<:Subzero.AbstractDirection}","page":"API Reference","title":"Subzero.OpenBoundary","text":"OpenBoundary(::Type{FT}, ::Type{D}, args...)\n\nA float type FT can be provided as the first argument of any OpenBoundary constructor. The second argument D is the directional type of the boundary. An OpenBoundary of type FT and D will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.OpenBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D<:Subzero.AbstractDirection","page":"API Reference","title":"Subzero.OpenBoundary","text":"OpenBoundary(::Type{D}, args...)\n\nIf a float type isn't specified, OpenBoundary will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.OutputWriters","page":"API Reference","title":"Subzero.OutputWriters","text":"OutputWriters{FT<:AbstractFloat}\n\nStructure to hold all types of output writers a user might want. All fields are vectors so that more than one of each type of output writer can be defined, and so that a default OutputWriter object doesn't create default output writer fields, which would create files, but rather empty lists of output writers. If any of the fields is not provided, the default is just an empty list. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.PeriodicBoundary","page":"API Reference","title":"Subzero.PeriodicBoundary","text":"PeriodicBoundary <: AbstractBoundary\n\nA sub-type of AbstractBoundary that moves a floe from one side of the domain to the opposite side of the domain when it crosses the boundary, bringing the floe back into the domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.PeriodicBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D<:Subzero.AbstractDirection, FT<:AbstractFloat}","page":"API Reference","title":"Subzero.PeriodicBoundary","text":"PeriodicBoundary{D, FT}(grid)\n\nCreates periodic boundary on the edge of the grid, and with the direction as a type. Edge is determined by direction. Inputs:     grid        <AbstractGrid> model grid Outputs:     Periodic Boundary on edge of grid given by direction and type. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT<:AbstractFloat, D<:Subzero.AbstractDirection}","page":"API Reference","title":"Subzero.PeriodicBoundary","text":"PeriodicBoundary(::Type{FT}, ::Type{D}, args...)\n\nA float type FT can be provided as the first argument of any PeriodicBoundary constructor. The second argument D is the directional type of the boundary. A PeriodicBoundary of type FT and D will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D<:Subzero.AbstractDirection","page":"API Reference","title":"Subzero.PeriodicBoundary","text":"PeriodicBoundary(::Type{D}, args...)\n\nIf a float type isn't specified, PeriodicBoundary will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.PolyVec","page":"API Reference","title":"Subzero.PolyVec","text":"Coordinates are vector of vector of vector of points of the form: [[[x1, y1], [x2, y2], ..., [xn, yn], [x1, y1]],   [[w1, z1], [w2, z2], ..., [wn, zn], [w1, z1]], ...] where the xy coordinates  are the exterior border of the floe and the wz coordinates, or any other  following sets of coordinates, describe holes within the floe.  This form is for easy conversion to polygons.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.RegRectilinearGrid","page":"API Reference","title":"Subzero.RegRectilinearGrid","text":"RegRectilinearGrid{FT<:AbstractFloat}<:AbstractGrid\n\nTessellation of 2-dimensional Euclidean space into n-by-m congruent rectangles.\n\nNx: number of grid cells in the x-direction\nNy: number of grid cells in the y-direction\nx0: value of first x grid line\nxf: value of final x grid line\ny0: value of first y grid line\nyf: value of final y grid line\nΔx: grid cell width\nΔy: grid cell height\nfloe_locations: matrix of CellFloes, which keep track of which floes are in   each cell\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.RegRectilinearGrid-Tuple","page":"API Reference","title":"Subzero.RegRectilinearGrid","text":"RegRectilinearGrid(args...)\n\nIf a type isn't specified, RegRectilinearGrid will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Int64, Int64, Tuple, Tuple}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.RegRectilinearGrid","text":"RegRectilinearGrid{FT}(\n    Nx,\n    Ny,\n    xbounds::Tuple{Real, Real},\n    ybounds::Tuple{Real, Real},\n) where {FT <: AbstractFloat}\n\nConstruct a RegRectilinearGrid for model given bounds for grid x and y and the number of grid cells in both the x and y direction. Inputs:     Nx       <Int> number of grid cells in the x-direction     Ny       <Int> number of grid cells in the y-direction     xbounds  <Tuple{Real, Real}> bound of grid x-direction in form (left, right)     ybounds  <Tuple{Real, Real}> bound of grid y-direction in form (bottom, top) Output:      RegRectilinearGrid with width and height determined by xbound and ybounds     and the number of grid cells in the x-direction and y-direction determined     by dims.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Tuple, Tuple, Any, Any}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.RegRectilinearGrid","text":"RegRectilinearGrid{FT}(\n    xbounds::Tuple,\n    ybounds::Tuple,\n    Δx,\n    Δy,\n)\n\nConstruct a RegRectilinearGrid for model given bounds for grid x and y and grid cell dimensions in meters. Inputs:     xbounds  <Tuple{Real, Real}> bound of grid x-direction in form (left, right)     ybounds  <Tuple{Real, Real}> bound of grid y-direction in form (bottom, top)     Δx       <Real> length/height of grid cells in x-direction     Δy       <Real> length/height of grid cells in y-direction Output:      RegRectilinearGrid from lx to ux and height from ly to uy with grid squares     of size Δx by Δy Warning:     If Δx doesn't evenly divide x length (lu-lx) or Δy doesn't evenly divide y     length (uy-ly) you won't get full size grid. The grid will be \"trimmed\" to     the nearest full grid square in both directions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.RegRectilinearGrid","text":"RegRectilinearGrid(::Type{FT}, args...)\n\nA float type FT can be provided as the first argument of any RegRectilinearGrid constructor. A RegRectilinearGrid of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.RidgeRaftSettings","page":"API Reference","title":"Subzero.RidgeRaftSettings","text":"RidgeRaftSettings{FT <: AbstractFloat}\n\nSettings needed for ridging and rafting within the model. The fields have the following meanings:\n\nridgerafton: a boolean flag for if ridging and rafting should be turned on   in the simulation\nΔt: multiple of timesteps during which ridging and rafting code will run\nridge_probability: the probability a floe ridges with another floe/domain if   it meets all other criteria\nraft_probability: the probability a floe rafts with another floe/domain if it   meets all other criteria\nminoverlapfrac: the minimum overlap area fraction between a floe and another   floe/domain for that floe to ridge or raft\nminridgeheight: the minimum floe height to ridge with a floe/domain\nmaxfloeridge_height: the maximum floe height to ridge with another   floe\nmaxdomainrdige_height: maximum floe height to ridge with a domain element\nmaxfloeraft_height: maximum floe height to raft with another floe\nmaxdomainraft_height: maximum floe height to raft with a domain element\ndomaingainprobability: the probalility that a floe that rafts with a domain   element keeps all of its mass (0) or if that mass is removed and lost to the   domain element (1).\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.RidgeRaftSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.RidgeRaftSettings","text":"RidgeRaftSettings(::Type{FT}, kwargs...)\n\nA float type FT can be provided as the first argument of any RidgeRaftSettings constructor. A RidgeRaftSettings of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.RingVec","page":"API Reference","title":"Subzero.RingVec","text":"Coordinates are vector of vector of points of the form: [[x1, y1], [x2, y2], ..., [xn, yn], [x1, y1]] where the xy coordinates form a closed ring. PolyVec objects can be made out RingVec objects. This form is for each conversion to LinearRings, which can also be made into Polygons.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.SimplificationSettings","page":"API Reference","title":"Subzero.SimplificationSettings","text":"struct SimplificationSettings{FT<:AbstractFloat}\n\nIf smoothverticeson is true then floe's with more vertices than maxvertices will be simplified every Δtsmooth timesteps. The tolerance is the Douglas–Peucker algorithm tolerance in (m).\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.SimplificationSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.SimplificationSettings","text":"SimplificationSettings(::Type{FT}, kwargs...)\n\nA float type FT can be provided as the first argument of any SimplificationSettings constructor. A SimplificationSettings of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.Simulation","page":"API Reference","title":"Subzero.Simulation","text":"Simulation{FT<:AbstractFloat, DT<:Domain{FT}}\n\nSimulation which holds a model and parameters needed for running the simulation. This includes physical constants (consts), a random number generator (rng), the number of seconds in a timestep (Δt), and the number of timesteps to run (nΔt). We also have a flag for verbose, which will print out the number of timesteps every 50 timesteps and a simulation name, which can be used when saving files. The user can also define settings for each physical process.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.South","page":"API Reference","title":"Subzero.South","text":"South<:AbstractDirection\n\nA simple direction type representing if a boundary is the southern boundary in a rectangular domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.StatusTag","page":"API Reference","title":"Subzero.StatusTag","text":"Enum for differnt floe status\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.SubGridPointsGenerator","page":"API Reference","title":"Subzero.SubGridPointsGenerator","text":"SubGridPointsGenerator\n\nSubtype of AbstractSubFloePointsGenerator that defines parameters needed to generate a set of points on a \"subgrid\" within the floe where the subgrid is a regular rectilinar grid with cells of size Δg in both width and height. If two-way coupling, Δg should be smaller than the grid's Δx and Δy so that there is at least one point in each grid cell that the floe occupies.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.SubGridPointsGenerator-Tuple","page":"API Reference","title":"Subzero.SubGridPointsGenerator","text":"SubGridPointsGenerator(; kwargs...)\n\nIf type isn't specified, SubGridPointsGenerator(; kwargs...) will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{RegRectilinearGrid, Int64}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.SubGridPointsGenerator","text":"SubGridPointsGenerator{FT}(grid, npoint_per_cell)\n\nSubGridPointsGenerator constructor that uses the simulation grid and the desired number of sub-floe points per simulation grid cell to determine the correct value of Δg Inputs:     grid                <RegRectilinearGrid> simulation's grid     npointpercell     <Int> number of points per grid cell, where the grid                             is redefined to have width and height equal to the                             minimum of Δx and Δy Output:     SubGridPointsGenerator with Δg defined to be the minimum of Δx and Δy over     the number of desired points per grid cell\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.SubGridPointsGenerator","text":"SubGridPointsGenerator(::Type{FT}; kwargs...)\n\nA float type FT can be provided as the first argument of any SubGridPointsGenerator constructor. A SubGridPointsGenerator of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.SubzeroLogger","page":"API Reference","title":"Subzero.SubzeroLogger","text":"SubzeroLogger(sim; messages_per_tstep = 1)\n\nCreated Subzero logger and writes log events to log file in current directory to file with the same name as the simulation's name field. Inputs:     sim                 <Simulation>     messagespertstep  <Int> maximum number of times a given message should be                         written per timestep Outputs:     Subzero logger that saves log to file with the same name as the simulation's     name field and optional keyword arguments set. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.SubzeroLogger-2","page":"API Reference","title":"Subzero.SubzeroLogger","text":"SubzeroLogger(sim, messages_per_tstep = 1)\n\nConstructor from Subzero logger. Inputs:     filename            <String> file path to file to write log events into     messagespertstep  <Int> maximum number of times a given message should be                             written per timestep Outputs:     Subzero logger that saves log to file with the same name as the simulation's     name field and optional keyword arguments set. \n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.SubzeroLogger-3","page":"API Reference","title":"Subzero.SubzeroLogger","text":"SubzeroLogger\n\nLogger for Subzero. Logs unique messages messages_per_tstep times per timestep to prevent overwhelming number of messages timesteps from multiple floes triggering the same log event. Fields:\n\nstream: ogs are written to this IO\nmin_level: minimum log event level to write\nmessage_limits: dictionary with message IDs for key whose values are the   number of times that message can still be written in current timestep -    current timestep is stored in same dictionary under key 'tstep'\nmessagespertstep: maximum number of times a given message should be written   per timestep\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.TopographyElement","page":"API Reference","title":"Subzero.TopographyElement","text":"TopographyElement{FT}<:AbstractDomainElement{FT}\n\nSingular topographic element with coordinates field storing where the element is within the grid. These are used to create the desired topography within the simulation and will be treated as islands or coastline within the model in that they will not move or break due to floe interactions, but they will affect floes.\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.TopographyElement-Tuple","page":"API Reference","title":"Subzero.TopographyElement","text":"TopographyElement(args...)\n\nIf a type isn't specified, TopographyElement will be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.TopographyElement-Union{Tuple{Array{Array{Vector{T}, 1}, 1} where T<:Real}, Tuple{FT}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.TopographyElement","text":"TopographyElement{FT}(coords)\n\nConstructor for topographic element with PolyVec coordinates Inputs:     coords      <PolyVec> Output:     Topographic element of abstract float type FT\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.TopographyElement-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.TopographyElement","text":"TopographyElement(::Type{FT}, args...)\n\nA float type FT can be provided as the first argument of any TopographyElement constructor. A TopographyElement of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.TopographyElement-Union{Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T<:AbstractFloat}, Tuple{FT}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.TopographyElement","text":"TopographyElement{FT}(poly)\n\nConstructor for topographic element with Polygon Inputs:     poly    <Polygon> Output:     Topographic element of abstract float type FT\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.WeldSettings","page":"API Reference","title":"Subzero.WeldSettings","text":"WeldSettings{FT<:AbstractFloat}\n\nSettings needed for welding within the model. The fields have the following meanings:\n\nweld_on: a boolean flag for if welding should be turned on in the simulation\nΔts: a list of multiples of timesteps during which welding code will run,   welding will be run at multiples of all elements, each with domain split   into corresponding Nx and Ny values\nNxs: a list of number of x-directional bins to split the domain into at   corresponding timesteps\nNys: a list of number of x-directional bins to split the domain into at   corresponding timesteps\nminweldarea: minimum area a weld can create for two floes to weld\nmaxweldarea: maximum area a weld can create for two floes to weld\nweldingcoeff: non-dimensional parameter, multiplied by ratio of overlap   between two floes to original floe area to determin probability that a floe   will merge. The larger this is, the more likely floes are to weld.   Probability with 5% overlap is `weldingcoeff * (0.05) > rand()`\n\n\n\n\n\n","category":"type"},{"location":"api/#Subzero.WeldSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.WeldSettings","text":"WeldSettings(::Type{FT}, kwargs...)\n\nA float type FT can be provided as the first argument of any WeldSettings constructor. A WeldSettings of type FT will be created by passing all other arguments to the correct constructor. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.West","page":"API Reference","title":"Subzero.West","text":"West<:AbstractDirection\n\nA simple direction type representing if a boundary is the western boundary in a rectangular domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.::-Tuple{InteractionFields, InteractionFields}","page":"API Reference","title":"Base.::","text":"Create a range of interactions field columns with InteractionFields enum objects\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.empty!-Tuple{CellFloes}","page":"API Reference","title":"Base.empty!","text":"empty!(cell::CellFloes)\n\nEmpties the vectors within a CellFloes object\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.empty!-Tuple{IceStressCell}","page":"API Reference","title":"Base.empty!","text":"empty!(cell::IceStressCell)\n\nEmpties the vectors within an IceStressCell\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.to_index-Tuple{InteractionFields}","page":"API Reference","title":"Base.to_index","text":"Index into interactions field with InteractionFields enum objects\n\n\n\n\n\n","category":"method"},{"location":"api/#Logging.handle_message-Tuple{Subzero.SubzeroLogger, Vararg{Any, 7}}","page":"API Reference","title":"Logging.handle_message","text":"handle_message(\n    logger::SubzeroLogger,\n    level,\n    message,\n    _module,\n    group,\n    id,\n    filepath,\n    line;\n    tstep = nothing,\n    kwargs...,\n)\n\nFunction that determines if log event should be written to file depending on how many times that event has been written to file in current timestep.\n\nNote:     This is called when a log macro is called (e.g. @warn), not explicitly by     the user. Additionally, it is not threadsafe so a message may be written     more times than messages_per_tstep, but it should be in the ballpark.     Putting a lock would slow down logging and isn't worth it given that this     problem only records a few extra log events. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero._calculate_hibler-Union{Tuple{FT}, Tuple{Type{FT}, Any, Any, Any}} where FT","page":"API Reference","title":"Subzero._calculate_hibler","text":"_calculate_hibler(FT, floes, pstar, c)\n\nCalculate Hibler's Elliptical Yield Curve as described in his 1979 paper \"A Dynamic Thermodynamic Sea Ice Model\". Inputs:     floes   <StructArray{Floes}> model's list of floes     pstar   <AbstractFloat> used to tune ellipse for optimal fracturing     c       <AbstractFloat> used to tune ellipse for optimal fracturing Outputs:     vertices <PolyVec{AbstractFloat}> vertices of elliptical yield curve Note:     Hibler's paper says that: Both pstar and c relate the ice strength to the     ice thickness and compactness. c is determined to that 10% open water     reduces the strength substantially and pstar is considered a free parameter. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero._calculate_mohrs-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 4}}} where FT","page":"API Reference","title":"Subzero._calculate_mohrs","text":"_calculate_mohrs(FT, σ1, σ2, σ11, σ22)\n\nCreates PolyVec from vertex values for Mohr's Cone (triangle in 2D) Inputs:     σ1  <AbstractFloat> x-coordiante of first point in cone     σ2  <AbstractFloat> y-coordiante of first point in cone     σ11 <AbstractFloat> x-coordinate of one vertex of cone and negative of the             y-coordinate of adjacend vertex in principal stress space     σ22 <AbstractFloat> y-coordinate of one vertex of cone and negative of the     x-coordinate of adjacend vertex in principal stress space Output:     Mohr's Cone vertices (triangle since we are in 2D) in principal stress space\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero._calculate_mohrs-Union{Tuple{Type{FT}}, Tuple{FT}, Tuple{Type{FT}, Any}, Tuple{Type{FT}, Any, Any}, Tuple{Type{FT}, Any, Any, Any}} where FT","page":"API Reference","title":"Subzero._calculate_mohrs","text":"_calculate_mohrs(\n    FT,\n    q,\n    σc,\n    σ11;\n    σ1 = nothing,\n    σ2 = nothing,\n    σ22 = nothing,\n)\n\nCalculate Mohr's Cone coordinates in principal stress space. Inputs:     q   <AbstractFloat> based on the coefficient of internal friction (µi) by             ((μi^2 + 1)^(1/2) + μi^2     σc  <AbstractFloat> uniaxial compressive strength     σ11 <AbstractFloat> negative of the x-coordinate of one vertex of cone             (triangle in 2D) and negative of the y-coordinate of adjacend vertex             in principal stress space Outputs:     Mohr's Cone vertices (triangle since we are in 2D) in principal stress space Note:     Concepts from the following papter -     Weiss, Jérôme, and Erland M. Schulson. \"Coulombic faulting from the grain     scale to the geophysical scale: lessons from ice.\" Journal of Physics D:     Applied Physics 42.21 (2009): 214017.     Equations taken from original version of Subzero written in MATLAB\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero._initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Vararg{Any, 4}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero._initialize_floe_field","text":"_initialize_floe_field(\n    ::Type{FT},\n    nfloes,\n    concentrations,\n    domain,\n    hmean,\n    Δh;\n    floe_settings,\n    rng,\n)\n\nCreate a field of floes using Voronoi Tesselation. Inputs:     Type{FT}        <AbstractFloat> Type for grid's numberical fields -                         determines simulation run type     nfloes          <Int> number of floes to try to create - note you                         might not end up with this number of floes -                         topography in domain and multiple concentrations can                         decrease number of floes created     concentrations  <Matrix> matrix of concentrations to fill domain. If                         size(concentrations) = N, M then split the domain                         into NxM cells, each to be filled with the                         corresponding concentration. If concentration is                         below 0, it will default to 0. If it is above 1, it                         will default to 1     domain          <Domain> model domain      hmean           <Float> average floe height     Δh              <Float> height range - floes will range in height from                         hmean - Δh to hmean + Δh     floebounds     <PolyVec> coordinates of boundary within which to populate floes. This                         can be smaller that the domain, but will be limited to open space                         within the domain     floesettings   <FloeSettings> settings needed to initialize floes     rng             <RNG> random number generator to generate random floe                         attributes - default uses Xoshiro256++ Output:     floe_arr <StructArray> list of floes created using Voronoi Tesselation         of the domain with given concentrations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero._initialize_floe_field-Union{Tuple{V}, Tuple{FT}, Tuple{Type{FT}, V, Any, Any, Any}} where {FT<:AbstractFloat, V<:(AbstractVector)}","page":"API Reference","title":"Subzero._initialize_floe_field","text":"_initialize_floe_field(\n    ::Type{FT},\n    coords,\n    domain,\n    hmean,\n    Δh;\n    floe_settings,\n    rng,\n)\n\nCreate a field of floes from a list of polygon coordiantes. User is wanrned if floe's do not meet minimum size requirment.  Inputs:     Type{FT}            <AbstractFloat> Type for grid's numberical fields -                             determines simulation run type     coords              <Vector{PolyVec}> list of polygon coords to make into floes     domain              <Domain> model domain      hmean               <Float> average floe height     Δh                  <Float> height range - floes will range in height from                             hmean ± Δh     floesettings       <FloeSettings> settings needed to initialize floes     rng                 <RNG> random number generator to generate random floe                             attributes - default uses Xoshiro256++ algorithm Output:     floearr <StructArray{Floe}> list of floes created from given polygon     coordinates\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.add_floe_ghosts!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT<:AbstractFloat, FLT<:(StructArrays.StructArray{<:Floe{FT}})}","page":"API Reference","title":"Subzero.add_floe_ghosts!","text":"add_floe_ghosts!(floes, max_boundary, min_boundary)\n\nAdd ghosts of all of the given floes passing through the two given boundaries to the list of floes. Inputs:     floes           <StructArray{Floe{FT}}> list of floes to find ghosts for     maxboundary    <PeriodicBoundary> northern or eastern boundary of domain     minboundary    <PeriodicBoundary> southern or western boundary of domain Outputs:     None. Ghosts of floes are added to floe list. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.add_floe_volume!-NTuple{4, Any}","page":"API Reference","title":"Subzero.add_floe_volume!","text":"add_floe_volume!(\n    floes,\n    idx,\n    vol,\n    floe_settings,\n)\n\nAdd volume to existing floe and update fields that depend on the volume. Inputs:     floes           <StructArray{Frloe}> list of floes     idx             <Int> index of floe to add volume to      vol             <AbstractFloat> volume to add to floe     floe_settings   <FloeSettings> simulation's settings for making floes Outputs:     Nothing. Floe's fields are updated to reflect increase in volume.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var\"#s87\", var\"#s86\", var\"#s85\", var\"#s84\", TT} where {var\"#s87\"<:PeriodicBoundary, var\"#s86\"<:PeriodicBoundary, var\"#s85\"<:PeriodicBoundary, var\"#s84\"<:PeriodicBoundary, TT<:(StructArrays.StructArray{<:TopographyElement{FT}})}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.add_ghosts!","text":"add_ghosts!(\n    elems,\n    domain,\n)\n\nAdd ghosts for elements that pass through any of the boundaries.  Inputs:     elems   <StructArray{Floe} or StructArray{TopographyElement}> list of                 elements to add ghosts to     domain  <Domain{                 AbstractFloat,                 PeriodicBoundary,                 PeriodicBoundary,                 PeriodicBoundary,                 PeriodicBoundary,             }> domain with all boundaries Outputs:         None. Ghosts are added to list of elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var\"#s87\", var\"#s86\", var\"#s85\", var\"#s84\", TT} where {var\"#s87\"<:PeriodicBoundary, var\"#s86\"<:PeriodicBoundary, var\"#s85\"<:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var\"#s84\"<:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT<:(StructArrays.StructArray{<:TopographyElement{FT}})}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.add_ghosts!","text":"add_ghosts!(\n    elems,\n    domain,\n)\n\nAdd ghosts for elements that pass through the northern or southern boundaries. Inputs:         elems   <StructArray{Floe} or StructArray{TopographyElement}> list of                     elements to add ghosts to         domain  <Domain{                     Float,                     PeriodicBoundary,                     PeriodicBoundary,                     NonPeriodicBoundary,                     NonPeriodicBoundary,                 }> domain with northern and southern periodic boundaries Outputs:         None. Ghosts are added to list of elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var\"#s87\", var\"#s86\", var\"#s85\", var\"#s84\", TT} where {var\"#s87\"<:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var\"#s86\"<:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var\"#s85\"<:PeriodicBoundary, var\"#s84\"<:PeriodicBoundary, TT<:(StructArrays.StructArray{<:TopographyElement{FT}})}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.add_ghosts!","text":"add_ghosts!(\n    elems,\n    domain,\n)\n\nAdd ghosts for elements that pass through the eastern or western boundaries.  Inputs:     elems   <StructArray{Floe} or StructArray{TopographyElement}> list of                 elements to add ghosts to     domain  <Domain{                 Float,                 NonPeriodicBoundary,                 NonPeriodicBoundary,                 PeriodicBoundary,                 PeriodicBoundary,             }> domain with eastern and western periodic boundaries  Outputs:     None. Ghosts are added to list of elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var\"#s87\", var\"#s86\", var\"#s85\", var\"#s84\", TT} where {var\"#s87\"<:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var\"#s86\"<:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var\"#s85\"<:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var\"#s84\"<:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT<:(StructArrays.StructArray{<:TopographyElement{FT}})}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.add_ghosts!","text":"add_ghosts!(\n    elems,\n    domain,\n)\n\nWhen there are no periodic boundaries, no ghosts should be added. Inputs:         None are used.  Outputs:         None. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.add_point!-Tuple{CellFloes, Any, Any, Any}","page":"API Reference","title":"Subzero.add_point!","text":"add_point!(\n    cfloes::CellFloes,\n    floeidx,\n    Δx,\n    Δy,\n)\n\nAdd floe to CellFloes list of floes within that grid cell and aggragate the stress caused by monte carlo point in floe into IceStressCell object. Inputs:     cfloes  <CellFloes> CellFloes object representing one grid cell (centered on                 model's grid lines)     floeidx <Int> floe index within model's list of floes     Δx      <AbstractFloat> x-translation to move floe from current position into                 given grid cell if shifted due to periodic boundaries     Δy      <AbstractFloat> y-translation to move floe from current position into                 given grid cell if shifted due to periodic boundaries Outputs:     None. Add information to both cfloes to record where floe is on model grid. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.add_point!-Tuple{CellFloes, IceStressCell, Vararg{Any, 5}}","page":"API Reference","title":"Subzero.add_point!","text":"add_point!(\n    cfloes::CellFloes,\n    scell::IceStressCell,\n    floeidx,\n    τx,\n    τy,\n    Δx,\n    Δy,\n)\n\nAdd floe to CellFloes list of floes within that grid cell and aggragate the stress caused by monte carlo point in floe into IceStressCell object. Inputs:     cfloes  <CellFloes> CellFloes object representing one grid cell (centered on                 model's grid lines)     scell   <IceStressCell> IceStressCell aggragating stresses from floes within                 grid cell from each floes' monte carlo points     floeidx <Int> floe index within model's list of floes     τx      <AbstractFloat> x-directional stress from monte carlo point on ocean     τy      <AbstractFloat> y-directional stress from monte carlo point on ocean     Δx      <AbstractFloat> x-translation to move floe from current position into                 given grid cell if shifted due to periodic boundaries     Δy      <AbstractFloat> y-translation to move floe from current position into                 given grid cell if shifted due to periodic boundaries Outputs:     None. Add information to both cfloes and scell to aggregate stress on ocean     grid cell and record where floe is on model grid. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.auto_extension-Tuple{Any, Any}","page":"API Reference","title":"Subzero.auto_extension","text":"auto_extension(filename, ext)\n\nIf filename ends in ext, return filename. Otherwise return filename * ext.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.bin_floe_centroids-NTuple{5, Any}","page":"API Reference","title":"Subzero.bin_floe_centroids","text":"bin_floe_centroids(floes, grid, domain, Nx, Ny)\n\nSplit floe locations into a grid of Nx by Ny by floe centroid location Inputs:     floes       <StructArray{Floe}> simulation's list of floes     grid        <RegRectilinearGrid> simulation's grid     domain      <Domain> simulation's domain     Nx          <Int> number of grid cells in the x-direction to split domain                     into for welding groups     Ny          <Int> number of grid cells in the y-direction to split domain                     into for welding groups Outputs:     floebins   <Matrix{Vector{Int}}> Nx by Ny matrix where each element is a                     list of floe indices whose centroids are in the                     corresponding section of the grid. May also have elements of                     value 0 if there are less than average number of floes in                      the section.     nfloes      <Maxtrix{Int}> Nx by Ny matrix where each element is the total                     number of indices within floebins[Nx, Ny] that are                     non-zeros and represent a floe within the grid section.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.boundary_coords-Tuple{Any, Type{East}}","page":"API Reference","title":"Subzero.boundary_coords","text":"boundary_coords(grid, ::Type{East})\n\nDetermine coordinates of eastern-most boundary of domain if around the edge of the grid. Inputs:     grid    <AbstractGrid> model grid             <Type{East}> boundary direction type Output:     PolyVec of boundary coordinates. See documentation of North method of this     function for more details. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.boundary_coords-Tuple{Any, Type{North}}","page":"API Reference","title":"Subzero.boundary_coords","text":"boundary_coords(grid, ::Type{North})\n\nDetermine coordinates of northen-most boundary of domain if around the edge of the grid. Inputs:     grid    <AbstractGrid> model grid             <Type{North}> boundary direction type Output:     PolyVec of boundary coordinates. These coordinates describe a rectangle that     has a length 2-times the length of the grid in the x-direction, centered on     the grid so that there is a buffer of half of the grid on either side. The     height is half of the grid in the y-direction. This buffer prevents pieces     of floes from passing outside the boundary before the next timestep -     possibly too cautious. If boundary_coords methods are used for each     direction, corners will be shared between adjacent boundaries. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.boundary_coords-Tuple{Any, Type{South}}","page":"API Reference","title":"Subzero.boundary_coords","text":"boundary_coords(grid, ::Type{South})\n\nDetermine coordinates of southern-most boundary of domain if around the edge of the grid. Inputs:     grid    <AbstractGrid> model grid             <Type{South}> boundary direction type Output:     PolyVec of boundary coordinates. See documentation of North method of this     function for more details. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.boundary_coords-Tuple{Any, Type{West}}","page":"API Reference","title":"Subzero.boundary_coords","text":"boundary_coords(grid, ::Type{West})\n\nDetermine coordinates of western-most boundary of domain if around the edge of the grid. Inputs:     grid    <AbstractGrid> model grid             <Type{West}> boundary direction Output:     PolyVec of boundary coordinates. See documentation of North method of this     function for more details. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_angular_momentum-NTuple{7, Any}","page":"API Reference","title":"Subzero.calc_angular_momentum","text":"calc_angular_momentum(u, v, mass, ξ, moment, x, y)\n\nCalculates angular momentum for one timestep given the floe's velocities, mass, moment of intertia, and centroid position. Inputs:     u       <Vector{Real}> list of floes' u velocities     v       <Vector{Real}> list of floes' v velocities     mass    <Vector{Real}> list of floes' masses     ξ       <Vector{Real}> list of floes' angular velocities     moment  <Vector{Real}> list of floes' moments of intertia     x       <Vector{Real}> list of floes' centroid x-value     y       <Vector{Real}> list of floes' centroid y-value Outputs:     <Real> total spin angular momentum from the floes     <Real> total orbital angular momentum from the floes\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_atmosphere_forcing-NTuple{7, Any}","page":"API Reference","title":"Subzero.calc_atmosphere_forcing","text":"calc_atmosphere_forcing(\n    mc_xr, \n    mc_yr,\n    upoint,\n    vpoint,\n    uatm_interp,\n    vatm_interp,\n    c,\n)\n\nCalculates the stresses on a floe from the atmosphere above at given monte carlo point. Inputs:     mcxr       <AbstractFloat> monte carlo point x-coordinate     mcyr       <AbstractFloat> monte carlo point y-coordinate     upoint      <AbstractFloat> u velocity of floe at monte carlo point     vpoint      <AbstractFloat> v velocity of floe at monte carlo point     uatminterp <Interplations object> linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the atompshere u velocity onto point     vatminterp <Interplations object> linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the atompshere v velocity onto point     c           <Constants> simulation's constants Outputs:     τxatm  <AbstractFloat> stress from atmosphere on floe in                 x-direction at given monte carlo point     τyatm  <AbstractFloat> stress from atmosphere on floe in                 y-direction at given monte carlo point\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_elastic_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, FT}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.calc_elastic_forces","text":"calc_elastic_forces(\n    p1,\n    p2,\n    regions,\n    region_areas,\n    force_factor,\n    consts,\n)\n\nCalculate normal forces, the point the force is applied, and the overlap area of regions created from floe collisions  Inputs:     p1              <Polygon> first floe's polygon in collision     p2              <Polygon> second floe's polygon in collision     regions         <Vector{Polygon}> polygon regions of overlap during                         collision     regionareas    <Vector{Float}> area of each polygon in regions     forcefactor    <Float> Spring constant equivalent for collisions Outputs:     force   <Array{Float, n, 2}> normal forces on each of the n regions greater                 than a minimum area     fpoint  <Array{Float, n, 2}> point force is applied on each of the n regions                 greater than a minimum area     overlap <Array{Float, n, 2}> area of each of the n regions greater than a                 minimum area     Δl      <Float> mean length of distance between intersection points\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_eulerian_data!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT<:AbstractFloat, FLT<:(StructArrays.StructArray{<:Floe{FT}})}","page":"API Reference","title":"Subzero.calc_eulerian_data!","text":"calc_eulerian_data!(floes, topography, writer, istep)\n\nCalculate floe data averaged on grid defined by GridOutputWriter for current timestep (istep). Inputs:     floes       <StructArray{Floe}> array of model's floes     topography  <StructArray{Topography} array of  model's topography     writer      <GridOutputWriter>      istep       <Int> current simulation timestep Output:     Floe data averaged on eularian grid provided and saved in writer.data field \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_friction_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Matrix{FT}, Any, Any, Any}} where FT","page":"API Reference","title":"Subzero.calc_friction_forces","text":"calc_friction_forces(\n    ifloe,\n    jfloe,\n    fpoints,\n    normal::Matrix{FT},\n    Δl,\n    consts,\n    Δt,\n)\n\nCalculate frictional force for collision between two floes or a floe and a domain element. Input:     ifloe   <Floe> first floe in collsion     jfloe   <Union{Floe, DomainElement}> either second floe or topography                 element/boundary element     fpoints <Array{Float, N, 2}> x,y-coordinates of the point the force is                 applied on floe overlap region     normal  <Array{Float, N, 2}> x,y normal force applied on fpoint on floe                 overlap region     Δl      <Vector> mean length of distance between intersection points     consts  <Constants> model constants needed for calculations     Δt      <AbstractFloat> simulation's timestep Outputs:     force   <Array{Float, N, 2}> frictional/tangential force of the collision in                 x and y (each row) for each collision (each column)\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_kinetic_energy-NTuple{5, Any}","page":"API Reference","title":"Subzero.calc_kinetic_energy","text":"calc_total_energy(u, v, mass, ξ, moment)\n\nCalculates linear and rotational energy for one timestep given the floe's velocities, mass, and moment of intertia. Inputs:     u       <Vector{Real}> list of floes' u velocities     v       <Vector{Real}> list of floes' v velocities     mass    <Vector{Real}> list of floes' masses     ξ       <Vector{Real}> list of floes' angular velocities     moment  <Vector{Real}> list of floes' moments of intertia Outputs:     linear      <Real> total linear kinetic energy generated by the floes     rotational  <Real> total rotational kinetic energy generated by the floes\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_linear_momentum-Tuple{Any, Any, Any}","page":"API Reference","title":"Subzero.calc_linear_momentum","text":"calc_linear_momentum(u, v, mass)\n\nCalculates linear momentum for one timestep given the floe's velocities and mass. Inputs:     u       <Vector{Real}> list of floes' u velocities     v       <Vector{Real}> list of floes' v velocities     mass    <Vector{Real}> list of floes' masses Outputs:     <Real> total linear momentum in the x-direction from floes     <Real> total linear momentum in the y-direction from floes\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_normal_force-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.calc_normal_force","text":"calc_normal_force(\n    c1,\n    c2,\n    region,\n    area,\n    ipoints,\n    force_factor,\n)\n\nCalculate normal force for collision between polygons p1 and p2 given an overlapping region, the area of that region, their intersection points in the region, and a force factor.  Inputs:     p1           <Polys> first polygon     p2           <Polys> second polygon     region       <PolyVec{Float64}> coordiantes for one region of intersection                     between the polygons     area         <Float> area of region     ipoints      <Vector{Tuple{Float, Float} or Vector{Vector{Float}}}> Points                     of intersection between polygon 1 and 2     force_factor <Float> Spring constant equivalent for collisions Outputs:         <Float> normal force of collision         Δl <Float> mean length of distance between intersection points\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_ocean_forcing!-NTuple{9, Any}","page":"API Reference","title":"Subzero.calc_ocean_forcing!","text":"calc_ocean_forcing!(\n    mc_xr,\n    mc_yr,\n    upoint,\n    vpoint,\n    uocn_interp,\n    vocn_interp,\n    hflx_interp,\n    ma_ratio,\n    c,\n)\n\nCalculates the stresses on a floe from the ocean above at given monte carlo point. Inputs:     mcxr       <AbstractFloat> monte carlo point x-coordinate     mcyr       <AbstractFloat> monte carlo point y-coordinate     upoint      <AbstractFloat> u velocity of floe at monte carlo point     vpoint      <AbstractFloat> v velocity of floe at monte carlo point     uocninterp <Interplations object> linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the ocean u velocity onto point     vocninterp <Interplations object> linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the ocean v velocity onto point     hflxinterp <Interplations object> linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the ocean heatflux factor velocity onto point     maratio    <AbstractFloat> floe's mass to area ratio     c           <Constants> simulation's constants Outputs:     τxocn          <AbstractFloat> stress from ocean velocity on floe in                         x-direction at given monte carlo point     τyocn          <AbstractFloat> stress from ocean velocity on floe in                         y-direction at given monte carlo point     τxpressure∇    <AbstractFloat> stress from ocean pressure gradient on floe                         in x-direction at given monte carlo point     τypressure∇    <AbstractFloat> stress from ocean pressure gradient on floe                         in y-direction at given monte carlo point     hflx_factor     <AbstractFloat> heatflux factor at given monte carlo point                         from the heatflux factors of ocean below floe\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_one_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT","page":"API Reference","title":"Subzero.calc_one_way_coupling!","text":"calc_one_way_coupling!(\n    floes::StructArray{Floe{FT}},\n    grid,\n    atmos,\n    ocean,\n    domain,\n    coupling_settings,\n    consts,\n)\n\nPreforms calculations needed for one way coupling by calculating floe's forcings from ocean and atmosphere as well as the heatflux below a given floe.\n\nFloe location on grid is also recorded. If two-way coupling is on, total stress on each grid cell per-floe in grid cell is also recorded for use in calctwowaycoupling! Inputs:     floes               <StructArray{Floe{FT}}> model's floe list     grid                <AbstractGrid> model's grid     atmos               <Ocean> model's atmosphere     ocean               <Ocean> model's ocean     domain              <Domain> model's domain     couplingsettings   <CouplingSettings> simulation coupling settings     consts              <Constants> simulation's constants Ouputs:     None. Update each floe's forces, torque, and heatflux factor from     ocean/atmosphere. Determine location of floe within grid and if two-way     coupling in enabled, save floe stress on grid. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_strain!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}}, Tuple{FT}} where FT","page":"API Reference","title":"Subzero.calc_strain!","text":"calc_strain!(coords, centroid, u, v, ξ, area)\n\nCalculates the strain on a floe given the velocity at each vertex Inputs:     floe        <Floe{AbstractFloat}> a floe Outputs:     strain      <Matrix{AbstractFloat}> 2x2 matrix for floe strain \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_stress!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Any, Any}} where FT","page":"API Reference","title":"Subzero.calc_stress!","text":"calc_stress!(floe)\n\nCalculates the stress on a floe for current collisions given interactions and floe properties. Inputs:     floe          <Union{LazyRow{Floe{AbstractFloat}}, Floe{AbstractFloat}> properties of floe     floesettings <FloeSettings{AbstractFloat}> Settings to create floes within model     Δt            <AbstractFloat> Simulation timestep in seconds Outputs:     Does not return anything, but updates floe.stressaccum and floe.stress_instant\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_subfloe_values!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.calc_subfloe_values!","text":"calc_subfloe_values!(\n    floe::Union{Floe{FT}, LazyRow{Floe{FT}}},\n    grid,\n    domain,\n    mc_cart,\n    mc_grid_idx,\n)\n\nCalculates subfloe point's cartesian coordiantes, polar coordiantes, velocity and index within the grid.  Inputs:     floe        <Union{Floe{AbstractFloat}, LazyRow{Floe{AbstractFloat}}}> floe     grid        <AbstractGrid> model's grid     domain      <Domain> model's domain     mccart     <Matrix{AbstractFloat}> pre-allocated nx2 matrix for floe's                     monte carlo point's cartesian coordinates where the first                     column is x and second is y     mcgrididx <Matrix{AbstractFloat}> pre-allocated nx2 matrix for floe's                     monte carlo point's grid indices where the first column is                     the column and the second is the row that the point is in on                     the grid split into cells centered on grid lines. Outputs:     j   <Int> last element in mccart and mcgrididx that holds monte carlo             point information for given floe.     mccart and mcgrid_idx filled with data for given floe's monte carlo points     up to row j.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_torque!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{<:Floe{FT}}}}, Tuple{FT}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.calc_torque!","text":"calc_torque!(floe)\n\nCalculate a floe's torque based on the interactions. Inputs:         floe  <Floe> floe in model Outputs:         None. Floe's interactions field is updated with calculated torque.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.calc_two_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, RegRectilinearGrid, Vararg{Any, 6}}} where FT","page":"API Reference","title":"Subzero.calc_two_way_coupling!","text":"calc_two_way_coupling!(\n    floes::StructArray{Floe{FT}},\n    grid::RegRectilinearGrid,\n    atmos,\n    ocean,\n    domain,\n    floe_settings,\n    consts,\n    Δt,\n)\n\nCalculate effects of ice and atmosphere on the ocean and update ocean stress fields and sea ice fraction. Inputs:     floes           <StructArray{Floe}> model's floes     grid            <AbstractGrid> model's grid     atmos           <Atmos> model's atmosphere     ocean           <Ocean> model's ocean     domain          <Domain> model's domain     floe_settings   <FloeSettings> simulation's floe settings     consts          <Constants> model's constants     Δt              <Int> simulation's timestep in seconds Output:     None. Update's ocean's stress fields and heatflux factor field. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.center_cell_coords-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Int64, RegRectilinearGrid, Any, Any}} where FT","page":"API Reference","title":"Subzero.center_cell_coords","text":"center_cell_coords(\n    xidx::Int,\n    yidx::Int,\n    grid::RegRectilinearGrid,\n    ns_bound,\n    ew_bound,\n)\n\nFind the coordinates of a given grid cell, centered on a grid line with row yidx and column xidx. This is offset from the cells within the regular rectilinear grid by half of a grid cell.  Inputs:     xidx        <Int> x index of grid line within list of gridlines (cell column)     yidx        <Int> y index of grid line within list of gridlines (cell row)     grid        <RegRectilinearGrid> model's grid      nsbound    <AbstractBoundary> type of either north or south boundary - for                     checking if periodic     ewbound    <AbstractBoundary> type of either east or west boundary - for                     checking if perioidic Output:     <PolyVec> coordinates for cell centered on grid line with given indices.     Note that cell bounds will be adjusted depending on if the bounds are     periodic. Cells cannot extend outside of non-periodic boundaries and thus     will be trimmed at boundaries. Therefore, if indices place cell completely     outside of grid, could return a line at the edge of the boundary. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, PeriodicBoundary}","page":"API Reference","title":"Subzero.check_cell_bounds","text":"check_cell_bounds(\n    xmin,\n    xmax,\n    ymin,\n    ymax,\n    grid,\n    ::PeriodicBoundary,\n    ::PeriodicBoundary,\n)\n\nReturn cell bounding values as is given the domain is doubley periodic and thus the cell can extend beyond the grid as it will simply wrap back around into grid through opposite periodic boundary. Inputs:     xmin    <Float> center cell minimum x value     xmax    <Float> center cell maxumum x value     ymin    <Float> center cell minimum y value     ymax    <Float> center cell maximum y value     grid    <AbstractGrid> model's grid             <PeriodicBoundary> type of north or south boundary - periodic pair             <PeriodicBoundary> type of east or west boundary - periodic pair Output:     x and y minimums and maximums as given since they can extend past the grid     due to periodic boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}","page":"API Reference","title":"Subzero.check_cell_bounds","text":"check_cell_bounds(\n    xmin,\n    xmax,\n    ymin,\n    ymax,\n    grid,\n    ::PeriodicBoundary,\n    ::NonPeriodicBoundary,\n)\n\nTrim cell bound in the east-west direction if it exends past grid due to non-periodic boundary pair. Inputs:     xmin    <Float> center cell minimum x value     xmax    <Float> center cell maxumum x value     ymin    <Float> center cell minimum y value     ymax    <Float> center cell maximum y value     grid    <AbstractGrid>             <PeriodicBoundary> type of either north or south boundary - periodic                 pair             <NonPeriodicBoundary> type of either east or west boundary - not a                 periodic pair Output:     Potentially trimmed x min and max if these values extend beyond grid values.     Else returned unchanged. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}","page":"API Reference","title":"Subzero.check_cell_bounds","text":"check_cell_bounds(\n    xmin,\n    xmax,\n    ymin,\n    ymax,\n    grid,\n    ::NonPeriodicBoundary,\n    ::PeriodicBoundary,\n)\n\nTrim cell bound in the north-south direction if it exends past grid due to non-periodic boundary pair. Inputs:     xmin    <Float> center cell minimum x value     xmax    <Float> center cell maxumum x value     ymin    <Float> center cell minimum y value     ymax    <Float> center cell maximum y value     grid    <AbstractGrid>             <NonPeriodicBoundary> type of either north or south boundary - not a                 periodic pair             <PeriodicBoundary> type of either east or west boundary - periodic                 pair Output:         Potentially trimmed y min and y max if these values extend beyond grid         values. Else returned unchanged. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}","page":"API Reference","title":"Subzero.check_cell_bounds","text":"check_cell_bounds(\n    xmin,\n    xmax,\n    ymin,\n    ymax,\n    grid,\n    ::NonPeriodicBoundary,\n    ::NonPeriodicBoundary,\n)\n\nTrim cell bounds in the east-west and north-south direction if they exend past grid due to non-periodic boundary pairs. Inputs:     xmin    <Float> center cell minimum x value     xmax    <Float> center cell maxumum x value     ymin    <Float> center cell minimum y value     ymax    <Float> center cell maximum y value     grid    <AbstractGrid>             <NonPeriodicBoundary> type of either north or south boundary - not a                 periodic pair             <NonPeriodicBoundary> type of either east or west boundary - not a                 periodic pair Output:     Potentially trimmed x and y minimums and maximums if these values extend     beyond grid values. Else returned unchanged. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.check_energy_momentum_conservation_julia","page":"API Reference","title":"Subzero.check_energy_momentum_conservation_julia","text":"check_energy_momentum_conservation_julia(filename, dir, verbose)\n\nCalculates total kinetic energy and momentum at each timestep and plots the output to check for conservation from floe outputwriter file. Also gives percent change in energy and momentum from first to last timestep in terminal. Inputs:     filename    <String> floe outputwriter filename + path     dir         <String> directory to save total energy and momentum                     conservation plots     plot        <Bool> plots energy and momentum over time if true Outputs:     Δenergy    <Float> percentage change in energy from first to last timestep     Δxmomentum       <Float> % change in x momentum from first to last timestep     Δymomentum       <Float> % change in y momentum from first to last timestep     Δangularmomentum <Float> % change in angular momentum from first to last                         timestep     Also saves energy and momentum plots over time to given directory if plots     is true\n\n\n\n\n\n","category":"function"},{"location":"api/#Subzero.check_energy_momentum_conservation_matlab","page":"API Reference","title":"Subzero.check_energy_momentum_conservation_matlab","text":"check_energy_momentum_conservation_matlab(mat_path, dir, plot)\n\nCalculates total kinetic energy and momentum at each timestep and plots the output to check for conservation from MATLAB verion of model output. The matpath should lead to the Floes file within the MATLAB version of the model. Also givesnpercent change in energy and momentum from first to last timestep in terminal. Inputs:     matpath    <String> path to MATLAB version's Floe folder      dir         <String> directory to save total energy and momentum                     conservation plots     plot        <Bool> plots energy and momentum over time if true Outputs:     Δenergy    <Float> percentage change in energy from first to last timestep     Δxmomentum       <Float> % change in x momentum from first to last timestep     Δymomentum       <Float> % change in y momentum from first to last timestep     Δangularmomentum <Float> % change in angular momentum from first to last                         timestep     Also saves energy and momentum plots over time to given directory if plots     is true\n\n\n\n\n\n","category":"function"},{"location":"api/#Subzero.check_for_edge_mid-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT","page":"API Reference","title":"Subzero.check_for_edge_mid","text":"check_for_edge_mid(c, start, stop, shared_idx, shared_dist, running_dist)\n\nCheck if indices from start to stop index of given coords includes midpoint given the shared distance and return midpoint if it exists in given range. Inputs:     c               <PolyVec> floe coordinates     start           <Int> index of sharedindex list to start search from     stop            <Int> index of sharedindex list to stop search at     sharedidx      <Vector{Int}> list of indices of c used to calculate midpoint     shareddist     <Float> total length of edges considered from sharedidx     runningdist    <Float> total length of edges traveled along in midpoint                         search so far Outputs:     midx           <Float> x-coordinate of midpoint, Inf if midpoint not in                         given range     midy           <Float> y-coordinate of midpoint, Inf if midpoint not in                         given range     running_dist    <Float> sum of distances travelled along shared edges\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.compare_floe_data-Tuple{Any, Any}","page":"API Reference","title":"Subzero.compare_floe_data","text":"compare_floe_data(filename1, filename2)\n\nCompare two files output by the floe output writer. Prints out first instances of not matching per timestep and field.  Inputs:     filename1   <String> filename and path of first file     filename2   <String> filename and path of second file Outputs:     If there are instances of differences, function will print time and index of     floes that don't match\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.compare_grid_data-Tuple{Any, Any}","page":"API Reference","title":"Subzero.compare_grid_data","text":"compare_grid_data(filename1, filename2)\n\nCompare two files output by the grid output writer. Prints out first instances of not matching per field. All timesteps are compared at once.  Inputs:     filename1   <String> filename and path of first file     filename2   <String> filename and path of second file Outputs:     If there are instances of differences, function will print the field that     has discrepancies. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.compare_oa_checkpointer_data-Tuple{Any, Any}","page":"API Reference","title":"Subzero.compare_oa_checkpointer_data","text":"compare_checkpointer_data(filename1, filename2)\n\nCompare two files output by the checkpointer output writer. Compares ocean and atmosphere. If there are discrepancies between the files, it will timesteps and field.  Inputs:     filename1   <String> filename and path of first file     filename2   <String> filename and path of second file Outputs:     If there are instances of differences, function will print the field and     timesteps that have discrepancies. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.conserve_momentum_change_floe_shape!","page":"API Reference","title":"Subzero.conserve_momentum_change_floe_shape!","text":"conserve_momentum_change_floe_shape!(\n    mass_tmp,\n    moment_tmp,\n    x_tmp,\n    y_tmp,\n    Δt,\n    keep_floe,\n    combine_floe = nothing,\n)\n\nUpdate current and previous velocity/acceleration fields to conserve momentum of a floe whose shape has been changed, given the previous mass, momentum, and centroid. Inputs:     masstmp    <AbstractFloat> original mass of floe before shape change     momenttmp  <AbstractFloat> original moment of intertia of floe before shape                     change     xtmp       <AbstractFloat> original x-coordinate of centroid of floe before                     shape change     ytmp       <AbstractFloat> original y-coordinate of centroid of floe before                     shape change     Δt          <Int> timestep of simulation in seconds     keepfloe   <Union{Floe, LazyRow{Floe}}> floe whose shape has been changed     combinefloe <Union{Floe, LazyRow{Floe}}> if keepfloe's shape has been                     changed due to an interaction with another floe, combinefloe                     is that floe - optional parameter Output:     None. keepfloe's u, v, ξ, pdxdt, pdydt, pdαdt, pdudt, pdvdt, and     p_dξdt fields all updated to preserve momentum.  Note:     Function does not depend on conservation of mass\n\n\n\n\n\n","category":"function"},{"location":"api/#Subzero.conserve_momentum_fracture_floe!-Union{Tuple{FT}, Tuple{Any, StructArrays.StructArray{<:Floe{FT}}, Any}} where FT","page":"API Reference","title":"Subzero.conserve_momentum_fracture_floe!","text":"conserve_momentum_fracture_floe!(\n    init_floe,\n    new_floes,\n    Δt,\n)\n\nUpdate newfloes's current and previous velocity/acceleration fields to conserve momentum when a floe has been fractured into several new floes, given the previous mass, momentum, and centroid. The assumption is made that each new floe has the same velocities/accelerations Inputs:     initfloe   <Union{Floe, LazyRow{Floe}}> original floe     newfloes   <StructArray{Floe}> fractured pieces of original floe     Δt          <Int> simulation's timestep in seconds Output:     None. newfloes velocities and accelerations are updated for current and     previous timestep to conserve momentum. Note: Depends on conservation of mass.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.conserve_momentum_transfer_mass!","page":"API Reference","title":"Subzero.conserve_momentum_transfer_mass!","text":"conserve_momentum_transfer_mass!(\n    floes,\n    idx1, idx2,\n    m1, m2,\n    I1, I2,\n    x1, x2,\n    y1, y2,\n    Δt,\n    pieces_list = nothing,\n    pieces_idx = 0,\n)\n\nConserve linear momentum when mass is transfered from one floe to another floe. Inputs:     floes       <StructArray{Floes}> list of floes     idx1        <Int> index of first floe in floes list     idx2        <Int> index of second floe in floes list     m1          <Float> initial mass of first floe before mass transfer     m2          <Float> initial mass of second floe before mass transfer     Δt          <Int> timestep of simulation in seconds     pieceslist <Union{nothing, Vector{Floe}}> list of floes created from floes                     breaking during ridging and rafting     piecesidx  <Int> start index of pieces included in conservation                     calculations within the pieces_list Outputs:     Nothing. Update floes' velocities and accelerations to conserve linear     momentum.\n\n\n\n\n\n","category":"function"},{"location":"api/#Subzero.deepcopy_floe-Union{Tuple{StructArrays.LazyRow{Floe{FT}}}, Tuple{FT}} where FT","page":"API Reference","title":"Subzero.deepcopy_floe","text":"deepcopy_floe(floe::LazyRow{Floe{FT}})\n\nDeepcopy of a floe by creating a new floe and copying all fields. Inputs:     floe    <Floe> Outputs:     New floe with floes that are equal in value. Any vector fields are copies so     they share values, but not referance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.deform_floe!-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Vararg{Any, 4}}} where FT","page":"API Reference","title":"Subzero.deform_floe!","text":"deform_floe!(\n    floe,\n    deformer_poly,\n    deforming_forces,\n)\n\nDeform a floe around the area of its collision with largest area overlap within the last timestep. Inputs:         floe                <Floe> floe to deform         deformercoords     <PolyVec> coords of floe that is deforming floe                                 argument         deformingforces    <Vector{AbstractFloat}> 1x2 matrix of forces between                                 floe and the deforming floe from floe's                                 interactions - of the form: [xforce yforce]  Outputs:         None. The input floe's centroid, coordinates, and area are updated to         reflect a deformation due to the collision with the deforming floe. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.determine_fractures-Tuple{Any, Subzero.AbstractFractureCriteria, Any}","page":"API Reference","title":"Subzero.determine_fractures","text":"determine_fractures(\n    floes,\n    criteria,\n    min_floe_area,\n)\n\nDetermines which floes will fracture depending on the principal stress criteria. Inputs:     floes           <StructArray{Floe}> model's list of floes     criteria        <AbstractFractureCriteria> fracture criteria     floe_settings   <FloeSettings> Floe settings. Contains Floe properties and stress                      calculator. Outputs:     <Vector{Int}> list of indices of floes to fracture \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.dissolve_floe!-Tuple{Any, RegRectilinearGrid, Any, Any}","page":"API Reference","title":"Subzero.dissolve_floe!","text":"dissolve_floe(floe, grid, dissolved)\n\nDissolve given floe into dissolved ocean matrix. Inputs:     floe        <Union{Floe, LazyRow{Floe}}> single floe     grid        <RegRectilinearGrid> model's grid     domain      <Domain> model's domain     dissolved    <Matrix{AbstractFloat}> ocean's dissolved field Outputs:     None. Update dissolved matrix with given floe's mass and mark floe for     removal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.domain_in_grid-Tuple{Domain, AbstractGrid}","page":"API Reference","title":"Subzero.domain_in_grid","text":"domain_in_grid(domain, grid)\n\nChecks if given rectangular domain is within given grid and gives user a warning if domain is not of maximum possible size given grid dimensions. Inputs:     domain      <RectangularDomain>     grid        <AbstractGrid> Outputs:     <Boolean> true if domain is within grid bounds, else false\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.euclidian_dist-Tuple{Any, Any, Any}","page":"API Reference","title":"Subzero.euclidian_dist","text":"euclidian_dist(c, idx2, idx1)\n\nCalculate euclidean distance between two points within given coordinates\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.find_center_cell_index-Tuple{Any, Any, RegRectilinearGrid}","page":"API Reference","title":"Subzero.find_center_cell_index","text":"find_center_cell_index(xp, yp, grid::RegRectilinearGrid)\n\nFind index of the cell centered on grid lines of the given RegRectilinearGrid that the given x-coordinate and y-coordinate falls within. This cell is centered around the grid lines, so it is a shifted grid cell by half a cell. Method depends on grid being a regular rectilinear grid. Inputs:     xp      <AbstractFloat> x-coordinates of point     yp      <AbstractFloat> y-coordinate of point     grid    <RegRectilinearGrid> simulation grid Outputs:     xidx    <AbstractFloat> x-index of grid cell (cented on grid lines) x-point                 is within - this is the column     yidx    <AbstractFloat> y-index of grid cell (cented on grid lines) y-point                 is within - this is the row Note:     Points can be outside of the grid, so index can be less than 1 or greater     than the number of grid lines in a given direction.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{East, FT}, PeriodicBoundary{West, FT}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.find_ghosts!","text":"find_ghosts!(\n    floes,\n    elem_idx,\n    ebound::PeriodicBoundary,\n    wbound::PeriodicBoundary,\n)\n\nFind ghosts of given element and its known ghosts through an eastern or western periodic boundary. If element's centroid isn't within the domain in the east/west direction, swap it with its ghost since the ghost's centroid must then be within the domain.  Inputs:     floes       <StructArray{Floe}> model's list of floes     elem_idx    <Int> floe of interest's index within the floe list     eboundary   <PeriodicBoundary{East, Float}> domain's eastern boundary     wboundary   <PeriodicBoundary{West, Float}> domain's western boundary Outputs:     None. Ghosts added to the floe list. Primary floe always has centroid within     the domain, else it is swapped with one of its ghost's which has a centroid     within the domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{North, FT}, PeriodicBoundary{South, FT}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.find_ghosts!","text":"find_ghosts!(\n    floes,\n    elem_idx,\n    nbound::PeriodicBoundary{North, <:AbstractFloat},\n    sbound::PeriodicBoundary{South, <:AbstractFloat},\n)\n\nFind ghosts of given element and its known ghosts through an northern or southern periodic boundary. If element's centroid isn't within the domain in the north/south direction, swap it with its ghost since the ghost's centroid must then be within the domain.  Inputs:     floes       <StructArray{Floe}> model's list of floes     elem_idx    <Int> floe of interest's index within the floe list     nboundary        <PeriodicBoundary{North, Float}> domain's northern boundary     sboundary        <PeriodicBoundary{South, Float}> domain's southern boundary Outputs:     None. Ghosts added to the floe list. Primary floe always has centroid within     the domain, else it is swapped with one of its ghost's which has a centroid     within the domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.find_grid_cell_index-Tuple{Any, Any, RegRectilinearGrid}","page":"API Reference","title":"Subzero.find_grid_cell_index","text":"find_grid_cell_index(xp, yp, grid::RegRectilinearGrid)\n\nFind index of the grid cell of the given RegRectilinearGrid that the given x-coordinate and y-coordinate falls within. Method depends on grid being a regular rectilinear grid. Inputs:     xp      <AbstractFloat> x-coordinates of point     yp      <AbstractFloat> y-coordinate of point     grid    <RegRectilinearGrid> simulation grid Outputs:     xidx    <AbstractFloat> x-index of grid cell x-point is within - this is the                 column     yidx    <AbstractFloat> y-index of grid cell y-point is within - this is the                 row Note:     Points can be outside of the grid, so index can be less than 1 or greater     than the number of grid cells\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, PeriodicBoundary}","page":"API Reference","title":"Subzero.find_interp_knots","text":"find_interp_knots(\n    point_idx,\n    ncells,\n    L,\n    Δd::Int,\n    ::PeriodicBoundary,\n)\n\nFind indicies in list of grid lines that surround points with indicies 'pointidx', with a buffer of Δd indices on each side of the points. In this case, the points are being considered near a periodic boundary, which means that they can loop around to the other side of the grid. If these points exist, we extend the grid lines to cover the points and buffer.  Inputs:     pointidx   <Vector{Int}> vector of point indices representing the grid line                     they are nearest     ncells      <Int> number of grid cells in given dimension     glines      <Vector or Range> grid line values     L           <AbstractFloat> length of grid in given dimension     Δd          <Int> number of buffer grid cells to include on either side of                     the provided indicies                  <PeriodicBoundary> dispatching on periodic boundary Outputs:     knots       <Vector{AbstractFloat}> interpolation knots - grid line values     knot_idx    <Vector{Int}> - indices of grid line values within grid list of                     grid lines. Note:     The grid values are extended if points expand past gridlines, however, the     indices are within the grid. For example, consider a grid where the maximum     grid value is 1e5, with grid cells of length 1e4. One of the knot values     might be 1.1e5, however, its index would be 2 since the grid line at 1e5 is     equivalent to the first grid line since it is periodic, and 1.1e5 is one     grid cell length past that value.\n\nThis function depends on the ocean being periodic in the given direction.\nWe assume that first grid line and the last grid line are the same, and have\nthe same values within the ocean/atmosphere. These are not repeated in the\nknots, but rather only one is used. So if there are 10 grid lines, grid line\n1 and 10 are the equivalent and we use grid line 1 exclusively.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}","page":"API Reference","title":"Subzero.find_interp_knots","text":"find_interp_knots(\n    point_idx,\n    ncells,\n    L,\n    Δd::Int,\n    ::NonPeriodicBoundary,\n)\n\nFind indicies in list of grid lines that surround points with indicies 'pointidx' with a buffer of Δd indices on each side of the points. In this case, the points are being considered near a NON-periodic boundary, so we cut off the possible indices past the edge of the grid.  Inputs:     pointidx   <Vector{Int}> vector of indices representing the grid line they                     are nearest     ncells      <Int> number of grid cells in given dimension     glines      <Vector or Range> grid line values     L           <AbstractFloat> length of grid in given dimension     Δd          <Int> number of buffer grid cells to include on either side of                     the provided indicies                  <PeriodicBoundary> dispatching on periodic boundary Outputs:     knots       <Vector{AbstractFloat}> interpolation knots - grid line values     knot_idx    <Vector{Int}> - indices of grid line values within grid list of                     grid lines. Note:     Only knots within the grid will be returned since this is a non-periodic     boundary.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.find_poly_coords-Tuple{Any}","page":"API Reference","title":"Subzero.find_poly_coords","text":"find_poly_coords(poly)\n\nSyntactic sugar for to find a polygon's coordinates Input:     poly    <Polygon> Output:     <PolyVec> representing the floe's coordinates xy plane\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.find_shared_edges_midpoint-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any}} where FT","page":"API Reference","title":"Subzero.find_shared_edges_midpoint","text":"find_shared_edges_midpoint(c1, c2)\n\nFind \"midpoint\" of shared polygon edges by distance Inputs:     c1      <PolVec> polygon coordinates for floe 1     c2      <PolVec> polygon coordinates for floe 2 Outputs:     midx   <Float> x-coordinate of midpoint     midy   <Float> y-coordinate of midpoint\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.floe_domain_element_interaction!-Tuple{Any, PeriodicBoundary, Vararg{Any, 4}}","page":"API Reference","title":"Subzero.floe_domain_element_interaction!","text":"floe_domain_element_interaction!(\n    floe,\n    ::PeriodicBoundary,\n    element_idx,\n    consts,\n    Δt,\n)\n\nIf a given floe intersects with a periodic boundary, nothing happens at this point. Periodic floes pass through boundaries using ghost floes. Inputs:         None are used.  Output:         None. This function does not do anyting. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Any, Union{CollisionBoundary, MovingBoundary, TopographyElement}, Any, Any, Any, FT}} where FT","page":"API Reference","title":"Subzero.floe_domain_element_interaction!","text":"floe_domain_element_interaction!(\n    floe,\n    element,\n    element_idx,\n    consts,\n    Δt,\n)\n\nIf floe intersects with given element (either collision boundary or topography element), floe interactions field and overarea field are updated. Inputs:     floe            <Floe> floe interacting with element     element         <Union{CollisionBoundary, TopographyElement}> coordinates of                         element     consts          <Constants> model constants needed for calculations     Δt              <Int> current simulation timestep     max_overlap     <Float> Percent a floe can overlap with a collision wall                             or topography before being killed/removed Outputs:     None. If floe interacts, the floe's interactions field is updated with the     details of each region of overlap. The interactions field will have the     following form for each region of overlap with the element:     [Inf, xforce, yforce, xfpoints, yfpoints, overlaps] where the xforce and     yforce are the forces, xfpoints and yfpoints are the location of the force     and overlaps is the overlap between the floe and element. The overlaps field     is also added to the floe's overarea field that describes the total     overlapping area at any timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, OpenBoundary, Vararg{Any, 4}}} where FT","page":"API Reference","title":"Subzero.floe_domain_element_interaction!","text":"floe_domain_element_interaction!(floe, boundary, _, _,)\n\nIf given floe insersects with an open boundary, the floe is set to be removed from the simulation. Inputs:     floe            <Floe> floe interacting with boundary     boundary        <OpenBoundary> coordinates of boundary     _               <Constants> model constants needed in other methods of this                         function - not needed here     _               <Int> current simulation timestep - not needed here     -               <Float> maximum overlap between floe and domain elements -                         not needed here Output:     None. If floe is interacting with the boundary, floe's status is set to     remove. Else, nothing is changed. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.floe_domain_interaction!-Union{Tuple{FT}, Tuple{Any, Domain, Any, Any, FT}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.floe_domain_interaction!","text":"floe_domain_interaction!(\n    floe,\n    domain::DT,\n    consts,\n    max_overlap,\n)\n\nIf the floe interacts with the domain, update the floe accordingly. Dispatches on different boundary types within the domain. Inputs:     floe        <Floe> floe interacting with boundary     domain      <Domain> model domain     consts      <Constants> model constants needed for calculations     Δt          <Int> current simulation timestep     max_overlap <Float> Percent a floe can overlap with a collision wall                         or topography before being killed/removed Outputs:     None. Floe is updated according to which boundaries it interacts with and     the types of those boundaries. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.floe_domain_raft!-Tuple{Any, Any, Union{StructArrays.LazyRow{<:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}","page":"API Reference","title":"Subzero.floe_domain_raft!","text":"floe_domain_raft!(\n    floes,\n    idx1,\n    domain_element,\n    pieces_buffer,\n    max_floe_id,\n    broken,\n    ridgeraft_settings,\n    floe_settings,\n    simp_settings,\n    Δt\n    rng,\n)\n\nRaft a floe against a boundary or a topography element and return any excess floes created by the rafting. This is equivalent to ridging. Inputs:     floes               <StructArray{Floe}> floe list     idx1                <Int> index of first floe     domainelement      <AbstractDomainElement> boundary or topography element     piecesbuffer       <StructArray{Floe}> list of new floe pieces caused by                             breakage of floes     maxfloeid         <Int> maximum floe ID before this ridging/rafting     broken              <Vector{Bool}> floe index is true if that floe has                             broken in a previous ridge/raft interaction     ridgeraftsettings  <RidgeRaftSettings> ridge/raft settings     floesettings       <FloeSettings> simulation's settings for making floes     simp_settings       <SimplificationSettings> simplification settings     Δt                  <Int> simulation timestep in seconds     rng                 <RandomNumberGenerator> simulation's random number                             generator Outputs:     floe1 is updated with new shape. If any new floes are created by rafting     they are returned, else nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.floe_domain_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{<:Floe{FT}}, Any, Union{StructArrays.LazyRow{<:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}} where FT","page":"API Reference","title":"Subzero.floe_domain_ridge!","text":"floe_domain_ridge!(\n    floes,\n    idx,\n    domain_element,\n    pieces_buffer,\n    max_floe_id,\n    broken,\n    ridgeraft_settings,\n    floe_settings,\n    simp_settings,\n    Δt,\n    rng,\n)\n\nRidge a floe against a boundary or a topography element and return any excess floes created by the ridging. Inputs:     floes               <StructArray{Floe}> floe list     idx1                <Int> index of first floe     domainelement      <AbstractDomainElement> boundary or topography element     piecesbuffer       <StructArray{Floe}> list of new floe pieces caused by                             breakage of floes     maxfloeid         <Int> maximum floe ID before this ridging/rafting     broken              <Vector{Bool}> floe index is true if that floe has                             broken in a previous ridge/raft interaction     ridgeraftsettings  <RidgeRaftSettings> simulation's settings for ridge/raft     floesettings       <FloeSettings> simulation's settings for making floes     simp_settings       <SimplificationSettings> simulation's settings for                             simplification     Δt                  <Int> simulation timestep in seconds     rng                 <RandomNumberGenerator> simulation's random number                             generator Outputs:     floe1 is updated with new shape. Return maximum floe id of floes created\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.floe_floe_interaction!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, Any, FT}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.floe_floe_interaction!","text":"floe_floe_interaction!(\n    ifloe,\n    i,\n    jfloe,\n    j,\n    nfloes,\n    consts,\n    Δt,\n)\n\nIf the two floes interact, update floe i's interactions accordingly. Floe j is not update here so that the function can be parallelized. Inputs:     ifloe       <Floe> first floe in potential interaction     i           <Int> index of ifloe in model's list of floes      jfloe       <Floe> second floe in potential interaction     j           <Int> index of jfloe in model's list of floes      nfloes      <Int> number of non-ghost floes in the simulation this timestep     consts      <Constants> model constants needed for calculations     Δt          <Int> Simulation's current timestep     maxoverlap <Float> Percent two floes can overlap before marking them                         for fusion Outputs:     None. Updates floes interactions fields. If floes overlap by more than     the maxoverlap fraction, they will be marked for fusion. Note:     If ifloe interacts with jfloe, only ifloe's interactions field is updated     with the details of each region of overlap. The interactions field will have     the following form for each region of overlap with the boundary:     [Inf, xforce, yforce, xfpoints, yfpoints, overlaps] where the xforce and     yforce are the forces, xfpoints and yfpoints are the location of the force     and overlaps is the overlap between the floe and boundary. The overlaps     field is also added to the floe's overarea field that describes the total     overlapping area at any timestep. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.floe_floe_raft!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{<:Floe{FT}}, Vararg{Any, 10}}} where FT","page":"API Reference","title":"Subzero.floe_floe_raft!","text":"floe_floe_raft!(\n    floes,\n    idx1,\n    idx2,\n    pieces_buffer,\n    max_floe_id,\n    broken,\n    ridgeraft_settings,\n    floe_settings,\n    simp_settings,\n    Δt,\n    rng,\n)\n\nRaft two floes, updating both in-place and returning any new floes that resulting from the rafting event. Inputs:     floes               <StructArray{Floe}> floe list     idx1                <Int> index of first floe     idx2                <Int> index of second floe     piecesbuffer       <StructArray{Floe}> list of new floe pieces caused by                             breakage of floes     maxfloeid         <Int> maximum floe ID before this ridging/rafting     broken              <Vector{Bool}> floe index is true if that floe has                             broken in a previous ridge/raft interaction     ridgeraftsettings  <RidgeRaftSettings> simulation's ridge/raft settings     floesettings       <FloeSettings> simultion's settings for making floes     simpsettings       <SimplificationSettings> simulation's simplification                             settings     Δt                  <Int> simulation timestep in seconds     rng                 <RandomNumberGenerator> simulation's random number                             generator Outputs:     Updates floe1 and floe2 and returns any new floes created by rafting\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.floe_floe_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{<:Floe{FT}}, Vararg{Any, 10}}} where FT","page":"API Reference","title":"Subzero.floe_floe_ridge!","text":"floe_floe_ridge!(\n    floes,\n    idx1,\n    idx2,\n    floe2,\n    overlap_area,\n    ridgeraft_settings,\n    simp_settings,\n    Δt,\n    rng\n)\n\nRidge two floes, updating both in-place and returning any new floes that resulting from the ridging event. Inputs:     floes               <StructArray{Floe}> floe list     idx1                <Int> index of first floe     idx2                <Int> index of second floe     piecesbuffer       <StructArray{Floe}> list of new floe pieces caused by                             breakage of floes     maxfloeid         <Int> maximum floe ID before this ridging/rafting     broken              <Vector{Bool}> floe index is true if that floe has                             broken in a previous ridge/raft interaction     ridgeraftsettings  <RidgeRaftSettings> simulation's settings for ridging                             and rafting     floesettings       <FloeSettings> simulation's settings for making floes     simpsettings       <SimplificationSettings> simulation's simplification                             settings     Δt                  <Int> simulation timestep in seconds     rng                 <RandomNumberGenerator> simulation's random number                             generator Outputs:     Updates floe1 and floe2 and returns any new floes created by ridging\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.floe_to_grid_info!-Union{Tuple{FT}, Tuple{Any, Any, Any, FT, FT, Vararg{Any, 5}}} where FT","page":"API Reference","title":"Subzero.floe_to_grid_info!","text":"floe_to_grid_info!(\n    floeidx,\n    xidx,\n    yidx,\n    τx_ocn::FT,\n    τy_ocn::FT,\n    grid,\n    domain,\n    scells,\n)\n\nAdd force from the ice on ocean to ocean force fields (fx & fy) for each grid cell and update ocean sea ice area fraction (siarea), representing total area of sea ice in a given cell. Function is called for each monte carlo point. Inputs:     floeidx             <Int> index of floe within model's floe array     xidx                <Int> grid x index that floe's point is within for grid                             centered on grid lines     yidx                <Int> grid column that floe's point is within for grid                             centered on grid lines     τxocn              <AbstractFloat> x-stress caused by ocean on point     τyocn              <AbstractFloat> y-stress caused by ocean on point     grid                <AbstractGrid> model's grid     domain              <Domain> model's domain     cellfloes          <Matrix{CellFloes}> matrix of CellFloes, one for each                             grid cell     scells              <Matrix{IceStressCell}> matrix of IceStressCells, one                             for each grid cell     coupling_settings   <CouplingSettings> simulation's coupling settings\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.fracture_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{<:Floe{FT}}, Vararg{Any, 5}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.fracture_floes!","text":"fracture_floes!(\n    floes,\n    max_floe_id,\n    rng,\n    fracture_settings,\n    floe_settings,\n    Δt,\n)\n\nFractures floes that meet the criteria defined in the fracture settings. Inputs:     floes       <StructArray{Floe}> model's list of floes     maxfloeid <Int> maximum ID of any floe created so far in simulation     rng         <RNG> random number generator     fracturesettings   <FractureSettings> sim's fracture settings     floesettings       <FloeSettings> sim's settings to make floes     Δtout               <Int> length of simulation timestep in seconds Outputs:     maxfloeid <Int> new highest floe ID after adding new floes to floe array.     Floe pieces added to floe array and original fractured floes removed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.fuse_floes!-NTuple{5, Any}","page":"API Reference","title":"Subzero.fuse_floes!","text":"fuse_floes!(\n    floes,\n    max_floe_id,\n    floe_settings,\n    Δt,\n    rng,\n)\n\nFuse all floes marked for fusion. Inputs:     floes               <StructArray{Floe}> model's floes     maxfloeid         <Int> maximum floe ID created yet     floe_settings       <FloeSettings>  simulation's settings for making floes     Δt                  <Int> simulation timestep in seconds     rng                 <RNG> random number generator Outputs:     None. Fuses floes marked for fusion. Marks floes fused into another floe     for removal. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.fuse_two_floes!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 5}}} where FT","page":"API Reference","title":"Subzero.fuse_two_floes!","text":"fuse_two_floes!(\n    keep_floe,\n    remove_floe,\n    Δt,\n    floe_settings,\n    max_floe_id,\n    rng,\n)\n\nFuses two floes together if they intersect and replaces the larger of the two floes with their union. Mass and momentum are conserved. Inputs:     keepfloe           <Union{Floe, LazyRow{Floe}}> first floe     removefloe         <Union{Floe, LazyRow{Floe}}> second floe     floesettings       <FloeSettings> simulation's settings to make new floes     prefusemaxfloeid <Int> maximum floe ID used yet in simulation     rng                 <RNG> random number generator Outputs:     If floes are not intersecting, no changes. If intersecing, the fused floe     replaces the larger of the two floes and the smaller floe is marked for     removal.     Note that the smaller floe's ID is NOT updated!\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{MonteCarloPointsGenerator{FT}, Vararg{Any, 5}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.generate_subfloe_points","text":"generate_subfloe_points(\n    point_generator\n    poly,\n    centroid,\n    area,\n    status,\n    rng\n)\n\nGenerate monte carlo points centered on the origin within the floe according to parameters defined in the pointgenerator argument. Inputs:     pointgenerator     <MonteCarloPointsGenerator> monte carlo point generator     poly                <Polygon> Polygon representing floe shape     centroid            <Matrix> floe's centroid     area                <AbstractFloat> floe's area     status              <Status> floe status (i.e. active, fuse in simulation)     rng                 <AbstractRNG> random number generator to generate monte                             carlo points Ouputs:     xsubfloe  <Vector{FT}> vector of sub-floe grid points x-coords within floe     ysubfloe  <Vector{FT}> vector of sub-floe grid points y-coords within floe     status      <Status> floe's status post generation, changed to remove if                      generation is unsuccessful\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{SubGridPointsGenerator{FT}, Vararg{Any, 5}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.generate_subfloe_points","text":"generate_subfloe_points(\n    point_generator,\n    poly,\n    centroid,\n    area,\n    status,\n    rng\n)\n\nGenerate evenly spaced points within given floe coordinates to be used for coupling. If only one point falls within the floe, return the floe's centroid. Inputs:     pointgenerator     <SubGridPointsGenerator> sub-grid point generator     poly                <Polygon> Polygon representing floe shape     centroid            <Matrix> floe's centroid     area                <AbstractFloat> floe's area     status              <Status> floe status (i.e. active, fuse in simulation)     rng                 <AbstractRNG> random number generator is not used in                             this generation method Ouputs:     xsubfloe  <Vector{FT}> vector of sub-floe grid points x-coords within floe     ysub_floe  <Vector{FT}> vector of sub-floe grid points y-coords within floe     status      <Status> tag isn't changed with this generation method\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.generate_voronoi_coords-Union{Tuple{FT}, Tuple{Int64, Any, Any, Vector{<:Array{Array{Vector{var\"#s81\"}, 1}, 1} where var\"#s81\"<:FT}, Any, Int64}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.generate_voronoi_coords","text":"generate_voronoi_coords(\n    desired_points,\n    scale_fac,\n    trans_vec,\n    domain_coords,\n    rng;\n    max_tries = 10,\n)\n\nGenerate voronoi coords within a bounding box defined by its lower left corner and its height and width. Attempt to generate npieces cells within the box. Inputs:     desiredpoints  <Int> desired number of voronoi cells     scalefac       <Vector{AbstractFloat}> width and height of bounding box -                         formatted as [w, h]      transvec       <Vector{AbstractFloat}> lower left corner of bounding box -                         formatted as [x, y]      domaincoords   <Vector{PolyVec{AbstractFloat}}> multipolygon that will                         eventually be filled with/intersected with the voronoi                         cells - such as topography     rng             <RNG> random number generator to generate voronoi cells     mintowarn     <Int> minimum number of points to warn if not generated to                         seed voronoi     maxtries       <Int> number of tires to generate desired number of points                         within domaincoords to seed voronoi cell creation Outputs:     coords  <Vector{PolyVec{Float}}> vector of polygon coordinates generated by         voronoi tesselation. These polygons all fall within the space defined by         the domaincoords. If less polygons than minto_warn are generated, the         user will be warned. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.get_known_grid_outputs-Tuple{}","page":"API Reference","title":"Subzero.get_known_grid_outputs","text":"get_known_grid_outputs()\n\nReturns list of symbols that represent calculations available in calceulariangrid to average floe data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.get_velocity-Union{Tuple{FT}, Tuple{Subzero.AbstractDomainElement{FT}, Any, Any}} where FT","page":"API Reference","title":"Subzero.get_velocity","text":"get_velocity(\n    element::AbstractDomainElement{FT},\n    x,\n    y,\n)\n\nGet velocity, which is 0m/s by default, of a point on topography element or boundary. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.get_velocity-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, FT, FT}} where FT","page":"API Reference","title":"Subzero.get_velocity","text":"get_velocity(\n    floe,\n    x,\n    y,\n)\n\nGet velocity of a point, assumed to be on given floe. Inputs:     floe <Union{LazyRow{Floe}, Floe}> floe     x    <AbstractFloat> x-coordinate of point to find velocity at     y    <AbstractFloat> y-coordinate of point to find velocity at Outputs:     u   <AbstractFloat> u velocity at point (x, y) assuming it is on given floe     v   <AbstractFloat> v velocity at point (x, y) assuming it is on given floe\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.getattrs-Tuple{Symbol}","page":"API Reference","title":"Subzero.getattrs","text":"getattrs(output::FloeOutput)\n\nReturns unit and comment attributes for each output type to be saved within output NetCDF file Input:     output<FloeOutput> Output:     <Tuple(String, String)> tuple of string units and comments to be saved to     output NetCDF file\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.ghosts_on_bounds!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any, Any}} where {FT<:AbstractFloat, FLT<:(StructArrays.StructArray{<:Floe{FT}})}","page":"API Reference","title":"Subzero.ghosts_on_bounds!","text":"ghosts_on_bounds(element, ghosts, boundary, trans_vec)\n\nIf the given element intersects with the boundary, add ghosts of the element and  any of its existing ghosts.  Inputs:     floes       <StructArray{Floe}> model's list of floes     elemidx    <Int> floe of interest's index within the floe list     boundary    <PeriodicBoundary> boundary to translate element through     transvec   <Matrix{Float}> 1x2 matrix of form [x y] to translate element                     through the boundary Outputs:     Nothing. New ghosts created by the given element, or its current ghosts,     are added to the floe list\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.grid_cell_index-Tuple{Any, Any, Any}","page":"API Reference","title":"Subzero.grid_cell_index","text":"grid_cell_index(p, Δg, g0)\n\nFind the index of given point's cartesian value (in either the x or y direction) within the simulation grid.  Inputs:     p       <Real> point's cartesian value in either x or y direction     Δg      <Real> simulation grid's cell width or height     g0      <Real> simulation grid's first grid line value in either x or y                         direction Output:     Point's grid cell index within the simulation grid, as specified by the grid     cell dimension and grid line starting value, in either the x or y direction\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.grid_line_index-Tuple{Any, Any, Any}","page":"API Reference","title":"Subzero.grid_line_index","text":"grid_line_index(p, Δg, g0)\n\nFind the index of given point's cartesian value (in either the x or y direction) within grid with cells centered on simulation grid's grid lines. Thus these cells are shifted from simulation's grid cells by half of a grid cell to the left.   Inputs:     p       <Real> point's cartesian value in either x or y direction     Δg      <Real> grid's cell width or height     g0      <Real> grid's first grid line value in either x or y direction Output:     Point's grid cell index within the shifted simulation grid, as specified by     the grid cell dimension and grid line starting value, in either the x or y     direction\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.grid_xc_index-Tuple{Any, Any, RegRectilinearGrid}","page":"API Reference","title":"Subzero.grid_xc_index","text":"grid_xc_index(xp, yp, grid::RegRectilinearGrid)\n\nFind indices of given cartesian point within simulation's xc-grid. Inputs:     xp      <Real> point's x-cartesian value     yp      <Real> point's y-cartesian value     grid    <RegRectilinearGrid> simulation's grid Outputs:     x index and y indices within xc-grid Note:      This is equivalent fo the yc-grid\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.grid_xg_index-Tuple{Any, Any, RegRectilinearGrid}","page":"API Reference","title":"Subzero.grid_xg_index","text":"grid_xg_index(xp, yp, grid::RegRectilinearGrid)\n\nFind indices of given cartesian point within simulation's xg-grid. Inputs:     xp      <Real> point's x-cartesian value     yp      <Real> point's y-cartesian value     grid    <RegRectilinearGrid> simulation's grid Outputs:     x index and y indices within xg-grid\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.grid_yc_index-Tuple{Any, Any, RegRectilinearGrid}","page":"API Reference","title":"Subzero.grid_yc_index","text":"grid_yc_index(xp, yp, grid::RegRectilinearGrid)\n\nFind indices of given cartesian point within simulation's yc-grid. Inputs:     xp      <Real> point's x-cartesian value     yp      <Real> point's y-cartesian value     grid    <RegRectilinearGrid> simulation's grid Outputs:     x index and y indices within yc-grid Note:      This is equivalent fo the xc-grid\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.grid_yg_index-Tuple{Any, Any, RegRectilinearGrid}","page":"API Reference","title":"Subzero.grid_yg_index","text":"grid_yg_index(xp, yp, grid::RegRectilinearGrid)\n\nFind indices of given cartesian point within simulation's yg-grid. Inputs:     xp      <Real> point's x-cartesian value     yp      <Real> point's y-cartesian value     grid    <RegRectilinearGrid> simulation's grid Outputs:     x index and y indices within yg-grid\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.grids_from_lines-Tuple{Any, Any}","page":"API Reference","title":"Subzero.grids_from_lines","text":"gridsfromlines(xlines, ylines)\n\nCreates x-grid and y-grid. Assume xlines has length n and ylines has length m. xgrid is the grid's xline vector repeated m times as rows in a mxn array and ygrid is the yline vector repeated n times as columns in a mxn vector. xlines and ylines are typically either xg and yg or xc and yc.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.hashole-Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T<:AbstractFloat}","page":"API Reference","title":"Subzero.hashole","text":"hashole(poly::Polys)\n\nDetermine if polygon has one or more holes Inputs:     poly <Polygon> polygon Outputs:     <Bool> true if there is a hole in the polygons, else false\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.hashole-Union{Tuple{Array{Array{Vector{FT}, 1}, 1}}, Tuple{FT}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.hashole","text":"hashole(coords::PolyVec{FT})\n\nDetermine if polygon coordinates have one or more holes Inputs:     coords <PolyVec{Float}> Outputs:     <Bool>\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, PeriodicBoundary}","page":"API Reference","title":"Subzero.in_bounds","text":"function in_bounds(\n    xr,\n    yr,\n    grid,\n    ::PeriodicBoundary,\n    ::PeriodicBoundary,\n)\n\nWith all periodic boundaries, all points are considered to be in-bounds. Inputs:     xr  <AbstractFloat> point x-coordinate     yr  <AbstractFloat> point y-coordinate         <::PeriodicBoundary> type of either north or south boundary -             checking if periodic pair         <::PeriodicBoundary> type of either east or west boundary -             checking if periodic pair Output:     Boolean that is true regardless of point values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}","page":"API Reference","title":"Subzero.in_bounds","text":"function in_bounds(\n    xr,\n    yr,\n    grid,\n    ::PeriodicBoundary,\n    ::NonPeriodicBoundary,\n)\n\nWith the east/west non-periodic boundaries, points outside of the grid in the x-direction are defined to be out of bounds since these points can't be interpolated as we don't have any information on the ocean outside of the grid. Inputs:     xr  <AbstractFloat> point x-coordinate     yr  <AbstractFloat> point y-coordinate         <::PeriodicBoundary> type of either north or south boundary -             checking if periodic pair         <::NonPeriodicBoundary> type of either east or west boundary -             checking if periodic pair Output:     Boolean that is true if xr is within domain boundaries, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}","page":"API Reference","title":"Subzero.in_bounds","text":"function in_bounds(\n    xr,\n    yr,\n    grid,\n    ::NonPeriodicBoundary,\n    ::PeriodicBoundary,\n)\n\nWith the north/south non-periodic boundaries, points outside of the grid in the y-direction are defined to be out of bounds since these points can't be interpolated as we don't have any information on the ocean outside of the grid. Inputs:     xr  <AbstractFloat> point x-coordinate     yr  <AbstractFloat> point y-coordinate         <::NonPeriodicBoundary> type of either north or south boundary -             checking if periodic pair         <::PeriodicBoundary> type of either east or west boundary -             checking if periodic pair Output:     Boolean that is true if yr is within domain boundaries, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}","page":"API Reference","title":"Subzero.in_bounds","text":"in_bounds(\n    xr,\n    yr,\n    grid,\n    ::NonPeriodicBoundary,\n    ::NonPeriodicBoundary,\n)\n\nWith all non-periodic boundaries, points outside of the grid in both the x and y are defined to be out of bounds since these points can't be interpolated as we don't have any information on the ocean outside of the grid. Inputs:     xr  <AbstractFloat> point x-coordinate     yr  <AbstractFloat> point y-coordinate         <::NonPeriodicBoundary> type of either north or south boundary -             checking if periodic pair         <::NonPeriodicBoundary> type of either east or west boundary -             checking if periodic pair Output:     Boolean that is true if both xr and yr are within domain boundaries, and     false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.initialize_floe_field-Tuple","page":"API Reference","title":"Subzero.initialize_floe_field","text":"initialize_floe_field(args...)\n\nA float type FT can be provided as the first argument of the initializefloefield constructor. A field of floes of type FT will be created by passing all other arguments to the correct method. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT","page":"API Reference","title":"Subzero.initialize_floe_field","text":"initialize_floe_field(args...)\n\nIf a type isn't specified, the field of Floes will each be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.initialize_jld2_file!-NTuple{5, Any}","page":"API Reference","title":"Subzero.initialize_jld2_file!","text":"initialize_jld2_file!(dir, filename, overwrite, outputs, jld2_kw)\n\nInitializes a JLD2 file in the given directory with the given filename. Setup file to write given outputs. Inputs:     dir         <String> path to directory     filename    <String> filename to save file to     overwrite   <Bool> if true, exit file of the same name will be deleted, else                     an error will be thrown if other file exists     outputs     <Vector{Symbol}> list of symbols to save as a group within the                     file     jld2_kw     list of JLD2 keywords for the jldopen function Outputs:     Create JLD2 file dir/filename where each output is a group within the file\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.initialize_netcdf_file!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 6}}} where FT","page":"API Reference","title":"Subzero.initialize_netcdf_file!","text":"function initialize_netcdf_file!(\n    ::Type{FT},\n    dir,\n    filename,\n    overwrite,\n    outputs,\n    xg,\n    yg,\n)\n\nInitializes a NetCDF file in the given directory with the given filename. Setup file to write given outputs. Inputs:     Type{FT}    <Type{AbstractFloat}> type of float to run simulation                     calculations using     dir         <String> path to directory     filename    <String> filename to save file to     overwrite   <Bool> if true, exit file of the same name will be deleted, else                     an error will be thrown if other file exists     outputs     <Vector{Symbol}> list of symbols to save as a group within the                     file     xg          <Vector{AbstractFloat}> list of x grid lines     yg          <Vector{AbstractFloat}> list of y grid lines Outputs:     Create NetCDF file dir/filename with each output added as a variable and     with the dimensions time, x, and y. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.initialize_topography_field-Tuple","page":"API Reference","title":"Subzero.initialize_topography_field","text":"initialize_topography_field(args...)\n\nIf a type isn't specified, the list of TopographyElements will each be of type Float64 and the correct constructor will be called with all other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.initialize_topography_field-Union{Tuple{FT}, Tuple{Type{FT}, Any}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.initialize_topography_field","text":"initialize_topography_field(\n    ::Type{FT},\n    coords,\n)\n\nCreate a field of topography from a list of polygon coordiantes. Inputs:     Type{FT}        <AbstractFloat> Type for grid's numberical fields -                         determines simulation run type     coords          <Vector{PolyVec}> list of polygon coords to make into floes Outputs:     topo_arr <StructArray{TopographyElement}> list of topography elements     created from given polygon coordinates\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.intersect_polys-Union{Tuple{FT}, Tuple{Any, Any}, Tuple{Any, Any, Type{FT}}} where FT","page":"API Reference","title":"Subzero.intersect_polys","text":"intersect_polys(p1, p2)\n\nIntersect two geometries and return a list of polygons resulting. Inputs:     p1  <AbstractGeometry>     p2  <AbstractGeometry> Output:     Vector of Polygons\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.level_to_string-Tuple{Any}","page":"API Reference","title":"Subzero.level_to_string","text":"level_to_string(level)\n\nReturns string with log event name given log event level\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.mc_interpolation-NTuple{7, Any}","page":"API Reference","title":"Subzero.mc_interpolation","text":"mc_interpolation(\n    mc_cart,\n    mc_grid_idx,\n    grid,\n    domain,\n    atmos,\n    ocean,\n    coupling_settings,\n)\n\nCreate and returns interpolation objects for atmosphere u and v velocities, and ocean u and v velocities, in addition to ocean's heatflux factor. Inputs:     npoints             <Int> number of monte carlo points to consider - the                             number of rows to use in mccart and mcgrididx     mccart             <Matrix{AbstractFloat}> cartesian coordinates for model                             coordinates - nx2 matrix of monte carlo coordinates                             where first column is the x-coords and the second                             column is the y-coords     mcgrididx         <Matrix{Int}> index of monte carlo points within the                             grid - nx2 matrix of indices where the first column                             is the grid column index and the second column is                             the grid row index for cells centered on grid lines     grid                <AbstractGrid> model grid     domain              <Domain> model domain     atmos               <Atmos> model atmosphere     ocean               <Ocean> model ocean     couplingsettings   <CouplingSettings> simulation's coupling settings Outputs:     uatminterp <Interplations object> linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the atompshere u velocity onto point     vatminterp <Interplations object> linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the atompshere v velocity onto point     uocninterp <Interplations object> linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the ocean u velocity onto point     vocninterp <Interplations object> linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the ocean v velocity onto point     hflxinterp <Interplations object> linear interpolation function from                     Interpolations.jl that takes in two arguments (x, y) and                     interpolates the ocean heatflux factor velocity onto point\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.normal_direction_correct!-Tuple{Any, Any, TopographyElement}","page":"API Reference","title":"Subzero.normal_direction_correct!","text":"normal_direction_correct!(\n    forces,\n    fpoints,\n    ::TopographyElement,\n)\n\nNo forces should be zero-ed out in collidions with topography elements.  Inputs:         None used. Outputs:         None.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{East, <:AbstractFloat}}} where FT","page":"API Reference","title":"Subzero.normal_direction_correct!","text":"normal_direction_correct!(\n    forces,\n    fpoints,\n    boundary::AbstractBoundary{East, <:AbstractFloat},\n)\n\nZero-out forces that point in direction not perpendicular to East boundary wall. See normaldirectioncorrect! on northern wall for more information\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{North, <:AbstractFloat}}} where FT","page":"API Reference","title":"Subzero.normal_direction_correct!","text":"normal_direction_correct!(\n    forces,\n    fpoints,\n    boundary::AbstractBoundary{North, <:AbstractFloat},\n)\n\nZero-out forces that point in direction not perpendicular to North boundary wall. Inputs:     force       <Array{Float, n, 2}> normal forces on each of the n regions                     greater than a minimum area     fpoint      <Array{Float, n, 2}> point force is applied on each of the n                     regions greater than a minimum area     boundary    <AbstractBoundary{North, <:AbstractFloat}> domain's northern                     boundary Outputs:     None. All forces in the x direction set to 0 if the point the force is     applied to is in the northern boundary.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{South, <:AbstractFloat}}} where FT","page":"API Reference","title":"Subzero.normal_direction_correct!","text":"normal_direction_correct!(\n    forces,\n    fpoints,\n    boundary::AbstractBoundary{South, <:AbstractFloat},\n)\n\nZero-out forces that point in direction not perpendicular to South boundary wall. See normaldirectioncorrect! on northern wall for more information\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{West, <:AbstractFloat}}} where FT","page":"API Reference","title":"Subzero.normal_direction_correct!","text":"normal_direction_correct!(\n    forces,\n    fpoints,\n    boundary::AbstractBoundary{<:AbstractFloat, West},\n)\n\nZero-out forces that point in direction not perpendicular to West boundary wall. See normaldirectioncorrect! on northern wall for more information\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.periodic_compat-Tuple{PeriodicBoundary, PeriodicBoundary}","page":"API Reference","title":"Subzero.periodic_compat","text":"periodic_compat(b1, b2)\n\nChecks if two boundaries are compatible as a periodic pair. This is true if they are both periodic, or if neither are periodic. Otherwise, it is false. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.plot_conservation-NTuple{7, Any}","page":"API Reference","title":"Subzero.plot_conservation","text":"plot_conservation(\n    linear_energy,\n    rotational_energy,\n    linear_x_momentum,\n    linear_y_momentum,\n    angular_spin_momentum,\n    angular_orbital_momentum,\n    dir,\n)\n\nTakes in vectors of energy and momentum at each simulation timestep and plots conservation over time. Plots are saved to given directory. Also prints total change in both kinetic energy and momentum from beginning to end of simulation to terminal.  Inputs:     linearenergy               <Vector{Real}> list of total energy from x and y                                     motion per timestep     rotationalenergy           <Vector{Real}> list of total energy from                                     rotational motion per timestep     linearxmomentum           <Vector{Real}> list of total momentum from x                                     motion per timestep     linearymomentum           <Vector{Real}> list of total momentum from y                                     motion per timestep     angularspinmomentum       <Vector{Real}> list of total momentum from floes                                     spinning around their own center of masses                                     per timestep     angularorbitalmomentum    <Vector{Real}> list of total momentum from floes                                     spinning around origin per timestep     dir                         <String> directory to save images to Outputs:     Δenergy          <Float> % change in energy from first to last timestep     Δxmomentum       <Float> % change in x momentum from first to last timestep     Δymomentum       <Float> % change in y momentum from first to last timestep     Δangularmomentum <Float> % change in angular momentum from first to last                         timestep     Also saves energy and momentum plots over time to given directory\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.poly_to_floes!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 5}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.poly_to_floes!","text":"poly_to_floes!(\n    ::Type{FT},\n    floes,\n    poly,\n    hmean,\n    Δh,\n    rmax;\n    floe_settings,\n    rng = Xoshiro(),\n    kwargs...\n)\n\nSplit a given polygon around any holes before turning each region with an area greater than the minimum floe area into a floe. Inputs:     Type{FT}            <AbstractFloat> Type for grid's numberical fields -                         determines simulation run type     floes               <StructArray{Floe}> vector of floes to add new floes to     poly                <Polygon> polygons to turn into floes     hmean               <AbstratFloat> average floe height     Δh                  <AbstratFloat> height range - floes will range in height                         from hmean - Δh to hmean + Δh     rmax                <AbstractFloat> maximum radius of floe (could be larger given context)     floe_settings       <FloeSettings> settings needed to initialize floe                             settings     rng                 <RNG> random number generator to generate random floe                             attributes - default uses Xoshiro256++ algorithm     kwargs...           Any additional keywords to pass to floe constructor\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.potential_interaction-NTuple{4, Any}","page":"API Reference","title":"Subzero.potential_interaction","text":"potential_interaction(\n    centroid1,\n    centroid2,\n    rmax1,\n    rmax2,\n)\n\nDetermine if two floes could potentially interact using the two centroid and two radii to form a bounding circle. Inputs:     centroid1   <Vector> first floe's centroid [x, y]     centroid2   <Vector> second floe's centroid [x, y]     rmax1       <Float> first floe's maximum radius     rmax2       <Float> second floe's maximum radius Outputs:     <Bool> true if floes could potentially interact, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.prettytime-Tuple{Any}","page":"API Reference","title":"Subzero.prettytime","text":"prettytime(t)\n\nTurn time in seconds into units of minutes, hours, days, or years as appropriate\n\nAguments:\n\nt::Real: number of seconds\n\nReturns:\n\n::String: number of seconds converted to a string value in minutes, hours, days, or years with units\n\nNote:\n\nThis code was modified from the this [source code](https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/src/trials.jl).\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.remove_floe_overlap!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{<:Floe{FT}}, Vararg{Any, 10}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.remove_floe_overlap!","text":"remove_floe_overlap!(\n    floes,\n    shrink_idx,\n    grow_floe_poly,\n    pieces_buffer,\n    max_floe_id,\n    broken,\n    ridgeraft_settings,\n    floe_settings,\n    rng,  \n)\n\nRemoves area/volume of overlap from floe that loses area during ridging/rafting Inputs:     floes               <StructArray{Floe}> list of floes     shrinkidx       <Int> index of floe that loses area     growfloepoly   <Polys> polygon of floe/domain that subsumes area     piecesbuffer       <StructArray{Floe}> list of new floe pieces caused by                             breakage of floes     maxfloeid         <Int> maximum floe ID before this ridging/rafting     broken              <Vector{Bool}> floe index is true if that floe has                             broken in a previous ridge/raft interaction     ridgeraftsettings  <RidgeRaftSettings> simulation's ridge/raft settings     floesettings       <FloeSettings> simulation's settings for making floes     simpsettings       <SimplificationSettings> simulation's simplification                             settings     rng                 <AbstractRNG> random number generator Outputs:     transfervol    <Float> total volume to transfer away from floe     maxfloeid     <Int> maximum floe id of floe created during overlap removal     floe_num        <Int> total number of floes created from origianl floe ->                         one if floe doesn't break, more otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.remove_floes!-NTuple{5, Any}","page":"API Reference","title":"Subzero.remove_floes!","text":"remove_floes!(\n    floes,\n    grid,\n    domain,\n    dissolved,\n    floe_settings\n)\n\nRemove floes marked for removal and dissolve floes smaller than minimum floe area if the dissolve setting is on. Inputs:     floes           <StructArray{Floe}> model's floes     grid            <AbstractGrid> model's grid     domain          <Domain> model's domain     dissolved       <Matrix{AbstractFloat}> ocean's dissolved field     floe_settings   <FloeSettings> simulation's settings for making floes Outputs:     None. Removes floes that do not continue to the next timestep and reset all     continuing floes status to active.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.replace_floe!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT","page":"API Reference","title":"Subzero.replace_floe!","text":"replace_floe!(\n    floe::Union{Floe{FT}, LazyRow{Floe{FT}}},\n    new_poly,\n    new_mass,\n    floe_settings,\n    rng,\n)\n\nUpdates existing floe shape and related physical properties based of the polygon defining the floe. Inputs:     floe        <Union{Floe, LazyRow{Floe}}> floe to update     newpoly    <Polygon> polygon representing new outline of floe     newmass    <AbstractFloat> mass of floe     floe_settings   <FloeSettings> simulation's settings for making floes     rng         <RNG> random number generator Ouputs:     Updates a given floe's physical properties given new shape and total mass.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.restart!-NTuple{4, Any}","page":"API Reference","title":"Subzero.restart!","text":"restart!(initial_state_fn, checkpointer_fn, new_nΔt, new_output_writers; start_tstep = 0)\n\nContinue the simulation run started with the given initial state and floe file for an additional new_nΔt timesteps and with the new outputwriters provided. The simulation will restart with a recorded timestep of `starttstep`.\n\nNote that this restart! function may not fit your needs and you may need to write your own. This function is meant to act as a simplest case and as a template for users to write their own restart functions. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.rotate_radians!-Tuple{Array{Array{Vector{T}, 1}, 1} where T<:Real, Any}","page":"API Reference","title":"Subzero.rotate_radians!","text":"rotate_radians!(coords::PolyVec, α)\n\nRotate a polygon's coordinates by α radians around the origin. Inputs:     coords  <PolyVec{AbstractFloat}> polygon coordinates     α       <Real> radians to rotate the coordinates Outputs:     Updates coordinates in place\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.run!-Tuple{Any}","page":"API Reference","title":"Subzero.run!","text":"run!(sim; logger = nothing, messages_per_tstep = 1, start_tstep = 0)\n\nRun given simulation and generate output for given writers. Simulation calculations will be done with Floats of type T (Float64 of Float32).\n\nInputs:     sim                 <Simulation> simulation to Run     logger              <AbstractLogger> logger for simulation - default is                             Subzero logger     messagespertstep  <Int> number of messages to print per timestep if using                             default SubzeroLogger, else not needed     start_tstep         <Int> which timestep to start the simulation on Outputs:     None. The simulation will be run and outputs will be saved in the output     folder. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.shift_cell_idx-Tuple{Any, Any, PeriodicBoundary}","page":"API Reference","title":"Subzero.shift_cell_idx","text":"shift_cell_idx(idx, nlines, ::PeriodicBoundary)\n\nIf index is greater than or equal to the grid lines, shift index to equivalent grid line on opposite side of grid due to periodic boundary. Similarly if given index is less than 1, shift index to equivalent grid line on opposite side of grid due to periodic boundary. Inputs:     idx     <Int> grid line index in either x or y     nlines  <Int> number of grid lines in model grid in either x or y direction             <PeriodicBoundary> boundary pair is periodic Output:     <Int> if given index is greater than or equal to number of grid lines, shift     index. If given index is less than 1, shift grid index. For example, the     last grid index, nlines, is equivalent to the 1st grid line. The nlines+1     grid line is equivalent to the 2nd grid line.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.shift_cell_idx-Tuple{Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}","page":"API Reference","title":"Subzero.shift_cell_idx","text":"shift_cell_idx(idx, nlines, ::NonPeriodicBoundary)\n\nReturn index as is given non-periodic boundary pair in either x or y direction. Inputs:     idx     <Int> grid line index in either x or y     nlines  <Int> number of grid lines in model grid in either x or y direction             <NonPeriodicBoundary> boundary pair is non-periodic Ouput:     idx <Int> as given. Can include the index nlines, unlike with the periodic         case, which will use the first index instead. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.simplify_floes!-NTuple{7, Any}","page":"API Reference","title":"Subzero.simplify_floes!","text":"simplify_floes!(\n    model,\n    simp_settings,\n    collision_settings,\n    floe_settings,\n    Δt,\n    rng,\n)\n\nSimplify the floe list be smoothing vertices, fusing floes, dissolving floes, and removing floes as needed.  Inputs:     model               <Model> model     maxfloeid         <Int> maximum floe id in simulation     simpsettings       <SimplificationSettings> simulation's simplification                             settings     collisionsettings  <CollisionSettings> simulation's collision settings     floe_settings       <FloeSettings>  simulation's settings for making floes     Δt                  <Int> simulation timestep in seconds     rng                 <RNG> random number generator Outputs:     Updates floe list and removes floe that won't continue to the next timestep\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.smooth_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.smooth_floes!","text":"smooth_floes!(\n    floes,\n    topography,\n    simp_settings,\n    collision_settings,\n    Δt,\n    rng,\n)\n\nSmooths floe coordinates for floes with more vertices than the maximum allowed number. Uses Ramer–Douglas–Peucker algorithm with a user-defined tolerance. If new shape causes overlap greater with another floe greater than the maximum percentage allowed, mark the two floes for fusion. Inputs:     floes               <StructArray{Floe}> model's floes     topography          <StructArray{TopographyElement}> domain's topography     simpsettings       <SimplificationSettings> simulation's simplification                             settings     collisionsettings  <CollisionSettings> simulation's collision settings     Δt                  <Int> length of simulation timestep in seconds     rng                 <RNG> random number generator for new monte carlo points\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.split_floe-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT","page":"API Reference","title":"Subzero.split_floe","text":"split_floe(\n    floe,\n    rng,\n    fracture_settings,\n    floe_settings,\n    Δt,\n)\n\nSplits a given floe into pieces using voronoi tesselation. User will recieve a warning if floe isn't split. Inputs:     floe              <Floe> floe in simulation     rng               <RNG> random number generator used for voronoi tesselation     fracturesettings <FractureSettings> simulation's fracture settings     floesettings     <FloeSettings> simulation's settings for making floes     Δt                <Int> length of simulation timesteps in seconds Outputs:     new_floes   <StructArray{Floes}> list of pieces floe is split into, each of                     which is a new floe\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.startup_sim","page":"API Reference","title":"Subzero.startup_sim","text":"startup_sim(sim)\n\nRequired actions to setup simulation. For example, setting up the simulation logger. Inputs:     sim                 <Simulation>     logger              <AbstractLogger> logger for simulation - default is                             Subzero logger     messagespertstep  <Int> number of messages to print per timestep if using                             default SubzeroLogger, else not needed Outputs:     None.\n\n\n\n\n\n","category":"function"},{"location":"api/#Subzero.teardown_sim-Tuple{Any}","page":"API Reference","title":"Subzero.teardown_sim","text":"teardown_sim(sim)\n\nRequired actions to tear down simulation. For example, flushing the simulation's logger and closing the stream. Inputs:     sim <Simulation> Outputs:     None.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.timestep_collisions!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{<:Floe{FT}}, Vararg{Any, 6}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.timestep_collisions!","text":"timestep_collisions!(\n    floes,\n    n_init_floes,\n    domain,\n    consts,\n    Δt,\n    collision_settings,\n    spinlock,\n)\n\nResolves collisions between pairs of floes and calculates the forces and torques caused by those collisions. Inputs:     floes               <StructArray{Floe}> model's list of floes     ninitfloes        <Int> number of floes without ghost floes     domain              <Domain> model's domain     consts              <Constants> simulation constants     Δt                  <Int> length of simulation timestep in seconds     collision_settings  <CollisionSettings> simulation collision settings     spinlock            <Thread.SpinLock>\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.timestep_coupling!-NTuple{5, Any}","page":"API Reference","title":"Subzero.timestep_coupling!","text":"timestep_coupling!(\n    model,\n    Δt,\n    consts,\n    coupling_settings,\n    floe_settings,\n)\n\nCalculates the effects of the ocean and atmosphere on the ice and the effects of the ice and atmosphere on the ocean if the coupling is two-way. Inputs:     model               <Model> model     Δt                  <Int> length of timestep in seconds     consts              <Constants> constants used in simulation     couplingsettings   <CouplingSettings> settings for coupling     floesettings       <FloeSettings> settings for basic floe properties Outputs:     None. Updates each floe's ocean/atmosphere forcings (fxOA, fyOA, torqueOA)     and calculates stresses on each ocean grid cell from ice and atmosphere if     two-way coupling is enabled in coupling_settings       \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.timestep_floe_properties!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{<:Floe{FT}}, Any, Any, Any}} where FT","page":"API Reference","title":"Subzero.timestep_floe_properties!","text":"timestep_floe(floe)\n\nUpdate floe position and velocities using second-order time stepping with tendencies calculated at previous timesteps. Height, mass, stress, and strain also updated based on previous timestep thermodynamics and interactions with other floes.  Input:         floe            <Floe>         Δt              <Int> simulation timestep in second         floe_settings   <FloeSettings> simulation floe settings Output:         None. Floe's fields are updated with values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.timestep_ridging_rafting!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Vararg{Any, 4}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.timestep_ridging_rafting!","text":"timestep_ridging_rafting!(\n    floes,\n    pieces_buffer,\n    domain,\n    max_floe_id,\n    ridgeraft_settings::RidgeRaftSettings{FT},\n    floe_settings\n    simp_settings,\n    Δt,\n    rng,\n)\n\nRidge and raft floes that meet probability and height criteria. Inputs:     floes               <StructArray{Floe}> simulation's list of floes     piecesbuffer       <StructArray{Floe}> list of new floe pieces caused by                             breakage of floes     domain              <Domain> simulation's domain     maxfloeid         <Int> maximum floe ID before this ridging/rafting     ridgeraftsettings  <RidgeRaftSettings> ridge/raft settings     floesettings       <FloeSettings> simulation's settings for making floes     simpsettings       <SimplificationSettings> simplification settings     Δt                  <Int> length of timestep in seconds     rng                 <RandomNumberGenerator> simulation's rng Outputs:     Updates floes post ridging and rafting and adds any new pieces to the pieces     buffer to be made into new floes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.timestep_sim!","page":"API Reference","title":"Subzero.timestep_sim!","text":"timestepsim!(sim, tstep, starttstep)\n\nRun one step of the simulation and write output.  Inputs:     sim          <Simulation> simulation to advance     tstep        <Int> current timestep     start_tstep  <Int> timestep simulation started on Outputs:     None. Simulation advances by one timestep. \n\n\n\n\n\n","category":"function"},{"location":"api/#Subzero.timestep_welding!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Vararg{Any, 4}}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.timestep_welding!","text":"timestep_welding!(\n    floes,\n    max_floe_id,\n    grid,\n    domain,\n    Nx,\n    Ny,\n    weld_settings::WeldSettings{FT},\n    floe_settings\n    Δt,\n    rng,\n)\n\nWeld floes within sections of the domain that meet overlap and size criteria together, ensuring resulting floe doesn't surpass maximum floe area.  Inputs:     floes               <StructArray{Floe}> simulation's list of floes     maxfloeid         <Int> maximum floe ID before this welding     grid                <RegRectilinearGrid> simulation's grid     domain              <Domain> simulation's domain     Nx                  <Int> number of grid cells in the x-direction to split                             domain into for welding groups     Ny                  <Int> number of grid cells in the y-direction to split                             domain into for welding groups     weldsettings       <WeldSettings> welding settings     floesettings       <FloeSettings> sim's settings for making new floes     consts              <Consts> simulation's constants     Δt                  <Int> length of timestep in seconds     rng                 <RandomNumberGenerator> simulation's rng Outputs:     Returns nothing. Welds groups of floes together that meet requirments. Floes     that are fused into other floes are marked for removal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.translate!-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.translate!","text":"translate!(coords, Δx, Δy)\n\nTranslate each of the given coodinates by given deltas in place Inputs:     coords PolyVec{Float}     vec <Vector{Real}> Output:     Updates given coords\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.translate-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT<:AbstractFloat","page":"API Reference","title":"Subzero.translate","text":"translate!(coords, Δx, Δy)\n\nMake a copy of given coordinates and translate by given deltas.  Inputs:     coords PolyVec{Float}     vec <Vector{Real}> Output:     Updates given coords\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.update_boundaries!-Tuple{Any, Any}","page":"API Reference","title":"Subzero.update_boundaries!","text":"update_boundaries!(domain)\n\nUpdate each boundary in the domain. For now, this simply means moving compression boundaries by their velocities. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.update_boundary!-Tuple{Union{CollisionBoundary, OpenBoundary, PeriodicBoundary}, Any}","page":"API Reference","title":"Subzero.update_boundary!","text":"update_boundary!(args...)\n\nNo updates to boundaries that aren't compression boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D<:Union{East, West}, FT<:AbstractFloat}","page":"API Reference","title":"Subzero.update_boundary!","text":"update_boundary!(boundary, Δt)\n\nMove East/West compression boundaries by given velocity. Update coords and val fields to reflect new position. Inputs:     boundary    <MovingBoundary{Union{East, West}, AbstractFloat}>                      domain compression boundary     Δt          <Int> number of seconds in a timestep Outputs:     None. Move boundary East/West depending on velocity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D<:Union{North, South}, FT<:AbstractFloat}","page":"API Reference","title":"Subzero.update_boundary!","text":"update_boundary!(boundary, Δt)\n\nMove North/South compression boundaries by given velocity. Update coords and val fields to reflect new position. Inputs:     boundary    <MovingBoundary{Union{North, South}, AbstractFloat}>                      domain compression boundary     Δt          <Int> number of seconds in a timestep Outputs:     None. Move boundary North or South depending on velocity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.update_criteria!-Tuple{MohrsCone, Any}","page":"API Reference","title":"Subzero.update_criteria!","text":"update_criteria!(::MohrsCone, floes)\n\nMohr's cone is not time or floe dependent so it doesn't need to be updates.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.update_criteria!-Union{Tuple{FT}, Tuple{HiblerYieldCurve{FT}, Any}} where FT","page":"API Reference","title":"Subzero.update_criteria!","text":"update_criteria!(criteria::HiblerYieldCurve, floes)\n\nUpdate the Hibler Yield Curve vertices based on the current set of floes. The criteria changes based off of the average height of the floes. Inputs:     criteria    <HiblerYieldCurve> simulation's fracture criteria     floes       <StructArray{Floe}> model's list of floes Outputs:     None. Updates the criteria's vertices field to update new criteria. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.update_ghost_timestep_vals!-Tuple{Any, Any, Any}","page":"API Reference","title":"Subzero.update_ghost_timestep_vals!","text":"update_ghost_timestep_vals!(floes, idx, parent_idx)\n\nUpdate a parent floes and its ghosts to match velocities and accelerations at given index. Inputs:     floes       <StructArray{Floe}> list of floes in the simulation     idx         <Int> index of floe within floes list to copy to floe and ghosts     parent_idx  <Int> index of parent floe to update, along with its ghosts Outputs:     Nothing. Update floe values. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.update_new_rotation_conserve!-NTuple{9, Any}","page":"API Reference","title":"Subzero.update_new_rotation_conserve!","text":"update_new_rotation_conserve!(\n    x, y,\n    floe1, floe2,\n    init_rot_momentum, init_p_rot_momentum,\n    diff_orbital, diff_p_orbital,\n    Δt,\n)\n\nUpdate rotational velocities of two floes whose shapes may have changed to maintain conservation of momentum given the floes' intial roational momentums and the change in orbital momentum between their original shape and new shapes. Additionally, both floes will have the same velocity at a given (x,y) point. Inputs:     x                   <Float> x-coordinate of point where floes share same                             rotational velocity     y                   <Float> y-coordinate of point where floes share same                             rotational velocity     floe1               <Union{Floe, LazyRow{Floe}}> first floe in pair     floe2               <Union{Floe, LazyRow{Floe}}> second floe in pair     initrotmomentum   <Float> initial rotational momentum of floe 1 before                             shape change     initprotmomentum <Float> initial rotational momentum of floe 2 before                             shape change     difforbital        <Float> change in floe 1's orbital velocity after shape                             change     diffporbital      <Float> change in floe 1's orbital velocity after shape                             change     Δt                  <Int> length of timestep in seconds Output:     Nothing. Update both floes' rotational velocity, previous rotational     velocity, and rotational acceleration to conserve angular momentum.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.valid_polyvec!-Tuple{Any}","page":"API Reference","title":"Subzero.valid_polyvec!","text":"valid_polyvec(coords::PolyVec{FT})\n\nTakes a PolyVec object and make sure that the last element of each \"ring\" (vector of vector of floats) has the same first element as last element and has not duplicate adjacent elements. Also asserts that each \"ring\" as at least three distinct elements or else it is not a valid ring, but rather a line segment. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.valid_ringvec!-Tuple{Any}","page":"API Reference","title":"Subzero.valid_ringvec!","text":"valid_ringvec(coords::RingVec{FT})\n\nTakes a RingVec object and make sure that the last element has the same first element as last element and that other than these two elements there are no duplicate, adjacent vertices. Also asserts that the ring as at least three elements or else it cannot be made into a valid ring as it is a line segment. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.which_points_on_edges-Tuple{Any, Any}","page":"API Reference","title":"Subzero.which_points_on_edges","text":"which_points_on_edges(points, coords; atol = 1e-1)\n\nFind which points are on the coordinates of the given polygon. Inputs:     points <Vector{Tuple{Float, Float} or Vector{Vector{Float}}}> points to         match to edges within polygon     coords  <PolVec> polygon coordinates     atol    <Float> distance target point can be from an edge before being                 classified as not on the edge\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.which_vertices_match_points-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Any}} where FT","page":"API Reference","title":"Subzero.which_vertices_match_points","text":"which_vertices_match_points(ipoints, coords, atol)\n\nFind which vertices in coords match given points Inputs:     points <Vector{Tuple{Float, Float} or Vector{Vector{Float}}}> points to                 match to vertices within polygon     region  <Polygon> polygon      atol    <Float> distance vertex can be away from target point before being                 classified as different points Output:     Vector{Int} indices of points in polygon that match the intersection points Note:      If last coordinate is a repeat of first coordinate, last coordinate index is     NOT recorded.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.write_checkpoint_data!-Tuple{Any, Any}","page":"API Reference","title":"Subzero.write_checkpoint_data!","text":"write_checkpoint_data!(sim, tstep)\n\nWrites model's floe, ocean, and atmosphere data to JLD2 file. Data can be used to restart simulation run. Inputs:     sim     <Simulation> simulation to run     tstep       <Int> simulation timestep Output:     Writes floes, ocean, and atmosphere to JLD2 file with name writer.fn for     current timestep, which will be the group in the JLD2 file. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.write_data!-Tuple{Any, Any, Any}","page":"API Reference","title":"Subzero.write_data!","text":"write_data!(sim, tstep, start_tstep)\n\nWrites data for the simulation's writers that are due to write at given tstep. Inputs:     sim         <Simulation> simulation to run     tstep       <Int> simulation timestep     start_tstep <Int> starting timestep of the simulation Output:     Saves writer requested data to files specified in each writer. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.write_floe_data!-Tuple{Any, Any, Any}","page":"API Reference","title":"Subzero.write_floe_data!","text":"write_floe_data!(sim, tstep)\n\nWrites desired FloeOutputWriter data to JLD2 file.\n\nInputs:     writers     <StructArray{FloeWriter}> list of floe writers      floes       <StructArray{Floe}> list of floes     tstep       <Int> simulation timestep Output:     Writes desired fields writer.outputs to JLD2 file with name writer.fn for     current timestep, which will be the group in the JLD2 file. \n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.write_grid_data!-NTuple{4, Any}","page":"API Reference","title":"Subzero.write_grid_data!","text":"write_grid_data!(sim, tstep)\n\nWrites desired GridOutputWriter data to NetCDF file. Inputs:     writers     <StructArray{GridWriter}> list of grid writers     floes       <StructArray{Floe}> list of floes     topography  <StructArray{TopographyElement}> list of topography elements     tstep       <Int> simulation timestep Output:     Writes desired fields writer.outputs to file with name writer.fn for current     timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subzero.write_init_state_data!-Tuple{Any}","page":"API Reference","title":"Subzero.write_init_state_data!","text":"write_init_state_data!(sim, tstep)\n\nSave initial simulation state. Inputs:     sim     <Simulation> simulation to run     tstep   <Int> timestep - not used Outputs:     Saves simulation state to file. \n\n\n\n\n\n","category":"method"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/#Main-concepts","page":"Introduction","title":"Main concepts","text":"","category":"section"},{"location":"#Subzero.jl","page":"Home","title":"Subzero.jl","text":"","category":"section"}]
}
