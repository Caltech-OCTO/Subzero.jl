<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Full Subzero API documentation | Subzero.jl</title>
    <meta name="description" content="Documentation for Subzero.jl">
    <meta name="generator" content="VitePress v1.3.2">
    <link rel="preload stylesheet" href="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/assets/style.BlROQb3n.css" as="style">
    
    <script type="module" src="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/assets/app.z-HNHBWo.js"></script>
    <link rel="preload" href="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/assets/chunks/theme.w69O86Y5.js">
    <link rel="modulepreload" href="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/assets/chunks/framework.D6zxVQCE.js">
    <link rel="modulepreload" href="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/assets/api.md.CWneu1_y.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-a9a9e638><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c3508ec8></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c3508ec8> Skip to content </a><!--]--><!----><header class="VPNav" data-v-a9a9e638 data-v-f1e365da><div class="VPNavBar has-sidebar top" data-v-f1e365da data-v-822684d1><div class="wrapper" data-v-822684d1><div class="container" data-v-822684d1><div class="title" data-v-822684d1><div class="VPNavBarTitle has-sidebar" data-v-822684d1 data-v-28a961f9><a class="title" href="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/" data-v-28a961f9><!--[--><!--]--><!----><span data-v-28a961f9>Subzero.jl</span><!--[--><!--]--></a></div></div><div class="content" data-v-822684d1><div class="content-body" data-v-822684d1><!--[--><!--]--><div class="VPNavBarSearch search" data-v-822684d1><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-822684d1 data-v-e6d46098><span id="main-nav-aria-label" class="visually-hidden" data-v-e6d46098> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/index" tabindex="0" data-v-e6d46098 data-v-ed5ac1f6><!--[--><span data-v-ed5ac1f6>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/introduction" tabindex="0" data-v-e6d46098 data-v-ed5ac1f6><!--[--><span data-v-ed5ac1f6>Introduction</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/api" tabindex="0" data-v-e6d46098 data-v-ed5ac1f6><!--[--><span data-v-ed5ac1f6>API Reference</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-822684d1 data-v-af096f4a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-af096f4a data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-822684d1 data-v-164c457f data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Caltech-OCTO/Subzero.jl" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-717b8b75><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-822684d1 data-v-925effce data-v-e5380155><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-e5380155><span class="vpi-more-horizontal icon" data-v-e5380155></span></button><div class="menu" data-v-e5380155><div class="VPMenu" data-v-e5380155 data-v-7dd3104a><!----><!--[--><!--[--><!----><div class="group" data-v-925effce><div class="item appearance" data-v-925effce><p class="label" data-v-925effce>Appearance</p><div class="appearance-action" data-v-925effce><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-925effce data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div></div></div><div class="group" data-v-925effce><div class="item social-links" data-v-925effce><div class="VPSocialLinks social-links-list" data-v-925effce data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Caltech-OCTO/Subzero.jl" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-717b8b75><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-822684d1 data-v-5dea55bf><span class="container" data-v-5dea55bf><span class="top" data-v-5dea55bf></span><span class="middle" data-v-5dea55bf></span><span class="bottom" data-v-5dea55bf></span></span></button></div></div></div></div><div class="divider" data-v-822684d1><div class="divider-line" data-v-822684d1></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-a9a9e638 data-v-070ab83d><div class="container" data-v-070ab83d><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-070ab83d><span class="vpi-align-left menu-icon" data-v-070ab83d></span><span class="menu-text" data-v-070ab83d>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-070ab83d data-v-bc9dc845><button data-v-bc9dc845>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-a9a9e638 data-v-18756405><div class="curtain" data-v-18756405></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-18756405><span class="visually-hidden" id="sidebar-aria-label" data-v-18756405> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0 has-active" data-v-9e426adc data-v-196b2e5f><!----><div class="items" data-v-196b2e5f><!--[--><div class="VPSidebarItem level-1 is-link" data-v-196b2e5f data-v-196b2e5f><div class="item" data-v-196b2e5f><div class="indicator" data-v-196b2e5f></div><a class="VPLink link link" href="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/index" data-v-196b2e5f><!--[--><p class="text" data-v-196b2e5f>Home</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-196b2e5f data-v-196b2e5f><div class="item" data-v-196b2e5f><div class="indicator" data-v-196b2e5f></div><a class="VPLink link link" href="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/introduction" data-v-196b2e5f><!--[--><p class="text" data-v-196b2e5f>Introduction</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-196b2e5f data-v-196b2e5f><div class="item" data-v-196b2e5f><div class="indicator" data-v-196b2e5f></div><a class="VPLink link link" href="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/api" data-v-196b2e5f><!--[--><p class="text" data-v-196b2e5f>API Reference</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-a9a9e638 data-v-91765379><div class="VPDoc has-sidebar has-aside" data-v-91765379 data-v-83890dd9><!--[--><!--]--><div class="container" data-v-83890dd9><div class="aside" data-v-83890dd9><div class="aside-curtain" data-v-83890dd9></div><div class="aside-container" data-v-83890dd9><div class="aside-content" data-v-83890dd9><div class="VPDocAside" data-v-83890dd9 data-v-6d7b3c46><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-6d7b3c46 data-v-b38bf2ff><div class="content" data-v-b38bf2ff><div class="outline-marker" data-v-b38bf2ff></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-b38bf2ff>On this page</div><ul class="VPDocOutlineItem root" data-v-b38bf2ff data-v-3f927ebe><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-6d7b3c46></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-83890dd9><div class="content-container" data-v-83890dd9><!--[--><!--]--><main class="main" data-v-83890dd9><div style="position:relative;" class="vp-doc _Caltech-OCTO_github_io_Subzero_jl_previews_PR102_api" data-v-83890dd9><div><h1 id="Full-Subzero-API-documentation" tabindex="-1">Full Subzero API documentation <a class="header-anchor" href="#Full-Subzero-API-documentation" aria-label="Permalink to &quot;Full Subzero API documentation {#Full-Subzero-API-documentation}&quot;">​</a></h1><div class="warning custom-block"><p class="custom-block-title">Warning</p><p>This page is still very much WIP!</p></div><p>Documentation for <a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">Subzero</a>&#39;s full API (only for reference!).</p><ul><li><a href="#Subzero.Subzero"><code>Subzero.Subzero</code></a></li><li><a href="#Subzero.AbstractBoundary"><code>Subzero.AbstractBoundary</code></a></li><li><a href="#Subzero.AbstractDirection"><code>Subzero.AbstractDirection</code></a></li><li><a href="#Subzero.AbstractDomainElement"><code>Subzero.AbstractDomainElement</code></a></li><li><a href="#Subzero.AbstractFractureCriteria"><code>Subzero.AbstractFractureCriteria</code></a></li><li><a href="#Subzero.AbstractGrid"><code>Subzero.AbstractGrid</code></a></li><li><a href="#Subzero.AbstractOutputWriter"><code>Subzero.AbstractOutputWriter</code></a></li><li><a href="#Subzero.AbstractStressCalculator"><code>Subzero.AbstractStressCalculator</code></a></li><li><a href="#Subzero.AbstractSubFloePointsGenerator"><code>Subzero.AbstractSubFloePointsGenerator</code></a></li><li><a href="#Subzero.Atmos-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.Atmos</code></a></li><li><a href="#Subzero.Atmos"><code>Subzero.Atmos</code></a></li><li><a href="#Subzero.Atmos-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Atmos</code></a></li><li><a href="#Subzero.Atmos-Tuple"><code>Subzero.Atmos</code></a></li><li><a href="#Subzero.CellFloes"><code>Subzero.CellFloes</code></a></li><li><a href="#Subzero.CellFloes-Union{Tuple{}, Tuple{FT}} where FT"><code>Subzero.CellFloes</code></a></li><li><a href="#Subzero.CheckpointOutputWriter-Tuple{Any}"><code>Subzero.CheckpointOutputWriter</code></a></li><li><a href="#Subzero.CheckpointOutputWriter"><code>Subzero.CheckpointOutputWriter</code></a></li><li><a href="#Subzero.CheckpointOutputWriter"><code>Subzero.CheckpointOutputWriter</code></a></li><li><a href="#Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}"><code>Subzero.CollisionBoundary</code></a></li><li><a href="#Subzero.CollisionBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}"><code>Subzero.CollisionBoundary</code></a></li><li><a href="#Subzero.CollisionBoundary"><code>Subzero.CollisionBoundary</code></a></li><li><a href="#Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection"><code>Subzero.CollisionBoundary</code></a></li><li><a href="#Subzero.CollisionSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.CollisionSettings</code></a></li><li><a href="#Subzero.CollisionSettings"><code>Subzero.CollisionSettings</code></a></li><li><a href="#Subzero.Constants-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.Constants</code></a></li><li><a href="#Subzero.Constants-Tuple"><code>Subzero.Constants</code></a></li><li><a href="#Subzero.CouplingSettings"><code>Subzero.CouplingSettings</code></a></li><li><a href="#Subzero.DamageStressCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.DamageStressCalculator</code></a></li><li><a href="#Subzero.DamageStressCalculator-Tuple"><code>Subzero.DamageStressCalculator</code></a></li><li><a href="#Subzero.DamageStressCalculator"><code>Subzero.DamageStressCalculator</code></a></li><li><a href="#Subzero.DecayAreaScaledCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.DecayAreaScaledCalculator</code></a></li><li><a href="#Subzero.DecayAreaScaledCalculator"><code>Subzero.DecayAreaScaledCalculator</code></a></li><li><a href="#Subzero.DecayAreaScaledCalculator-Tuple"><code>Subzero.DecayAreaScaledCalculator</code></a></li><li><a href="#Subzero.Domain-Union{Tuple{WB}, Tuple{EB}, Tuple{SB}, Tuple{NB}, Tuple{FT}, Tuple{NB, SB, EB, WB}} where {FT&lt;:AbstractFloat, NB&lt;:AbstractBoundary{North, FT}, SB&lt;:AbstractBoundary{South, FT}, EB&lt;:AbstractBoundary{East, FT}, WB&lt;:AbstractBoundary{West, FT}}"><code>Subzero.Domain</code></a></li><li><a href="#Subzero.Domain"><code>Subzero.Domain</code></a></li><li><a href="#Subzero.East"><code>Subzero.East</code></a></li><li><a href="#Subzero.Floe-Union{Tuple{FT}, Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Floe</code></a></li><li><a href="#Subzero.Floe-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.Floe</code></a></li><li><a href="#Subzero.Floe-Tuple"><code>Subzero.Floe</code></a></li><li><a href="#Subzero.Floe-Union{Tuple{FT}, Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Floe</code></a></li><li><a href="#Subzero.Floe"><code>Subzero.Floe</code></a></li><li><a href="#Subzero.FloeOutputWriter-Tuple{Any}"><code>Subzero.FloeOutputWriter</code></a></li><li><a href="#Subzero.FloeOutputWriter"><code>Subzero.FloeOutputWriter</code></a></li><li><a href="#Subzero.FloeOutputWriter"><code>Subzero.FloeOutputWriter</code></a></li><li><a href="#Subzero.FloeSettings"><code>Subzero.FloeSettings</code></a></li><li><a href="#Subzero.FloeSettings-Union{Tuple{Type{FT}}, Tuple{CT}, Tuple{GT}, Tuple{FT}} where {FT&lt;:AbstractFloat, GT&lt;:Subzero.AbstractSubFloePointsGenerator, CT&lt;:AbstractStressCalculator}"><code>Subzero.FloeSettings</code></a></li><li><a href="#Subzero.FractureSettings"><code>Subzero.FractureSettings</code></a></li><li><a href="#Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Any, AbstractGrid, Any}} where FT&lt;:AbstractFloat"><code>Subzero.GridOutputWriter</code></a></li><li><a href="#Subzero.GridOutputWriter"><code>Subzero.GridOutputWriter</code></a></li><li><a href="#Subzero.GridOutputWriter-Tuple{GridOutputWriter}"><code>Subzero.GridOutputWriter</code></a></li><li><a href="#Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.GridOutputWriter</code></a></li><li><a href="#Subzero.GridOutputWriter-Tuple"><code>Subzero.GridOutputWriter</code></a></li><li><a href="#Subzero.HiblerYieldCurve-Union{Tuple{StructArrays.StructArray{&lt;:Floe{FT}}}, Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.HiblerYieldCurve</code></a></li><li><a href="#Subzero.HiblerYieldCurve-Tuple"><code>Subzero.HiblerYieldCurve</code></a></li><li><a href="#Subzero.HiblerYieldCurve"><code>Subzero.HiblerYieldCurve</code></a></li><li><a href="#Subzero.HiblerYieldCurve-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.HiblerYieldCurve</code></a></li><li><a href="#Subzero.IceStressCell"><code>Subzero.IceStressCell</code></a></li><li><a href="#Subzero.IceStressCell-Union{Tuple{}, Tuple{FT}} where FT"><code>Subzero.IceStressCell</code></a></li><li><a href="#Subzero.InitialStateOutputWriter"><code>Subzero.InitialStateOutputWriter</code></a></li><li><a href="#Subzero.InitialStateOutputWriter-Tuple{InitialStateOutputWriter}"><code>Subzero.InitialStateOutputWriter</code></a></li><li><a href="#Subzero.InitialStateOutputWriter-Tuple{}"><code>Subzero.InitialStateOutputWriter</code></a></li><li><a href="#Subzero.InteractionFields"><code>Subzero.InteractionFields</code></a></li><li><a href="#Subzero.Model"><code>Subzero.Model</code></a></li><li><a href="#Subzero.MohrsCone-Union{Tuple, Tuple{FT}} where FT"><code>Subzero.MohrsCone</code></a></li><li><a href="#Subzero.MohrsCone-Tuple"><code>Subzero.MohrsCone</code></a></li><li><a href="#Subzero.MohrsCone-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.MohrsCone</code></a></li><li><a href="#Subzero.MohrsCone"><code>Subzero.MohrsCone</code></a></li><li><a href="#Subzero.MonteCarloPointsGenerator"><code>Subzero.MonteCarloPointsGenerator</code></a></li><li><a href="#Subzero.MonteCarloPointsGenerator-Tuple"><code>Subzero.MonteCarloPointsGenerator</code></a></li><li><a href="#Subzero.MonteCarloPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.MonteCarloPointsGenerator</code></a></li><li><a href="#Subzero.MovingBoundary"><code>Subzero.MovingBoundary</code></a></li><li><a href="#Subzero.MovingBoundary-Union{Tuple{FT}, Tuple{D}, Tuple{Any, Any, Any}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}"><code>Subzero.MovingBoundary</code></a></li><li><a href="#Subzero.MovingBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}"><code>Subzero.MovingBoundary</code></a></li><li><a href="#Subzero.MovingBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection"><code>Subzero.MovingBoundary</code></a></li><li><a href="#Subzero.NoFracture"><code>Subzero.NoFracture</code></a></li><li><a href="#Subzero.NonPeriodicBoundary"><code>Subzero.NonPeriodicBoundary</code></a></li><li><a href="#Subzero.North"><code>Subzero.North</code></a></li><li><a href="#Subzero.Ocean-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.Ocean</code></a></li><li><a href="#Subzero.Ocean-Tuple"><code>Subzero.Ocean</code></a></li><li><a href="#Subzero.Ocean-Union{Tuple{FT}, Tuple{Any, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Ocean</code></a></li><li><a href="#Subzero.Ocean"><code>Subzero.Ocean</code></a></li><li><a href="#Subzero.Ocean-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.Ocean</code></a></li><li><a href="#Subzero.OpenBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection"><code>Subzero.OpenBoundary</code></a></li><li><a href="#Subzero.OpenBoundary"><code>Subzero.OpenBoundary</code></a></li><li><a href="#Subzero.OpenBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}"><code>Subzero.OpenBoundary</code></a></li><li><a href="#Subzero.OpenBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}"><code>Subzero.OpenBoundary</code></a></li><li><a href="#Subzero.OutputWriters"><code>Subzero.OutputWriters</code></a></li><li><a href="#Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection"><code>Subzero.PeriodicBoundary</code></a></li><li><a href="#Subzero.PeriodicBoundary"><code>Subzero.PeriodicBoundary</code></a></li><li><a href="#Subzero.PeriodicBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}"><code>Subzero.PeriodicBoundary</code></a></li><li><a href="#Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}"><code>Subzero.PeriodicBoundary</code></a></li><li><a href="#Subzero.PolyVec"><code>Subzero.PolyVec</code></a></li><li><a href="#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Int64, Int64, Tuple, Tuple}} where FT&lt;:AbstractFloat"><code>Subzero.RegRectilinearGrid</code></a></li><li><a href="#Subzero.RegRectilinearGrid-Tuple"><code>Subzero.RegRectilinearGrid</code></a></li><li><a href="#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Tuple, Tuple, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.RegRectilinearGrid</code></a></li><li><a href="#Subzero.RegRectilinearGrid"><code>Subzero.RegRectilinearGrid</code></a></li><li><a href="#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.RegRectilinearGrid</code></a></li><li><a href="#Subzero.RidgeRaftSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.RidgeRaftSettings</code></a></li><li><a href="#Subzero.RidgeRaftSettings"><code>Subzero.RidgeRaftSettings</code></a></li><li><a href="#Subzero.RingVec"><code>Subzero.RingVec</code></a></li><li><a href="#Subzero.SimplificationSettings"><code>Subzero.SimplificationSettings</code></a></li><li><a href="#Subzero.SimplificationSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.SimplificationSettings</code></a></li><li><a href="#Subzero.Simulation"><code>Subzero.Simulation</code></a></li><li><a href="#Subzero.South"><code>Subzero.South</code></a></li><li><a href="#Subzero.StatusTag"><code>Subzero.StatusTag</code></a></li><li><a href="#Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.SubGridPointsGenerator</code></a></li><li><a href="#Subzero.SubGridPointsGenerator"><code>Subzero.SubGridPointsGenerator</code></a></li><li><a href="#Subzero.SubGridPointsGenerator-Tuple"><code>Subzero.SubGridPointsGenerator</code></a></li><li><a href="#Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{RegRectilinearGrid, Int64}} where FT&lt;:AbstractFloat"><code>Subzero.SubGridPointsGenerator</code></a></li><li><a href="#Subzero.SubzeroLogger"><code>Subzero.SubzeroLogger</code></a></li><li><a href="#Subzero.SubzeroLogger"><code>Subzero.SubzeroLogger</code></a></li><li><a href="#Subzero.SubzeroLogger"><code>Subzero.SubzeroLogger</code></a></li><li><a href="#Subzero.TopographyElement"><code>Subzero.TopographyElement</code></a></li><li><a href="#Subzero.TopographyElement-Tuple"><code>Subzero.TopographyElement</code></a></li><li><a href="#Subzero.TopographyElement-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat"><code>Subzero.TopographyElement</code></a></li><li><a href="#Subzero.TopographyElement-Union{Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.TopographyElement</code></a></li><li><a href="#Subzero.TopographyElement-Union{Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.TopographyElement</code></a></li><li><a href="#Subzero.WeldSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.WeldSettings</code></a></li><li><a href="#Subzero.WeldSettings"><code>Subzero.WeldSettings</code></a></li><li><a href="#Subzero.West"><code>Subzero.West</code></a></li><li><a href="#Base.::-Tuple{InteractionFields, InteractionFields}"><code>Base.::</code></a></li><li><a href="#Base.empty!-Tuple{IceStressCell}"><code>Base.empty!</code></a></li><li><a href="#Base.empty!-Tuple{CellFloes}"><code>Base.empty!</code></a></li><li><a href="#Base.to_index-Tuple{InteractionFields}"><code>Base.to_index</code></a></li><li><a href="#Logging.handle_message-Tuple{Subzero.SubzeroLogger, Vararg{Any, 7}}"><code>Logging.handle_message</code></a></li><li><a href="#Subzero._calculate_hibler-Union{Tuple{FT}, Tuple{Type{FT}, Any, Any, Any}} where FT"><code>Subzero._calculate_hibler</code></a></li><li><a href="#Subzero._calculate_mohrs-Union{Tuple{Type{FT}}, Tuple{FT}, Tuple{Type{FT}, Any}, Tuple{Type{FT}, Any, Any}, Tuple{Type{FT}, Any, Any, Any}} where FT"><code>Subzero._calculate_mohrs</code></a></li><li><a href="#Subzero._calculate_mohrs-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 4}}} where FT"><code>Subzero._calculate_mohrs</code></a></li><li><a href="#Subzero._initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Vararg{Any, 4}}} where FT&lt;:AbstractFloat"><code>Subzero._initialize_floe_field</code></a></li><li><a href="#Subzero._initialize_floe_field-Union{Tuple{V}, Tuple{FT}, Tuple{Type{FT}, V, Any, Any, Any}} where {FT&lt;:AbstractFloat, V&lt;:(AbstractVector)}"><code>Subzero._initialize_floe_field</code></a></li><li><a href="#Subzero.add_floe_ghosts!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}"><code>Subzero.add_floe_ghosts!</code></a></li><li><a href="#Subzero.add_floe_volume!-NTuple{4, Any}"><code>Subzero.add_floe_volume!</code></a></li><li><a href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s86&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s85&quot;&lt;:PeriodicBoundary, var&quot;#s84&quot;&lt;:PeriodicBoundary, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat"><code>Subzero.add_ghosts!</code></a></li><li><a href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s86&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s85&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s84&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat"><code>Subzero.add_ghosts!</code></a></li><li><a href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:PeriodicBoundary, var&quot;#s86&quot;&lt;:PeriodicBoundary, var&quot;#s85&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s84&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat"><code>Subzero.add_ghosts!</code></a></li><li><a href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:PeriodicBoundary, var&quot;#s86&quot;&lt;:PeriodicBoundary, var&quot;#s85&quot;&lt;:PeriodicBoundary, var&quot;#s84&quot;&lt;:PeriodicBoundary, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat"><code>Subzero.add_ghosts!</code></a></li><li><a href="#Subzero.add_point!-Tuple{CellFloes, IceStressCell, Vararg{Any, 5}}"><code>Subzero.add_point!</code></a></li><li><a href="#Subzero.add_point!-Tuple{CellFloes, Any, Any, Any}"><code>Subzero.add_point!</code></a></li><li><a href="#Subzero.auto_extension-Tuple{Any, Any}"><code>Subzero.auto_extension</code></a></li><li><a href="#Subzero.bin_floe_centroids-NTuple{5, Any}"><code>Subzero.bin_floe_centroids</code></a></li><li><a href="#Subzero.boundary_coords-Tuple{Any, Type{South}}"><code>Subzero.boundary_coords</code></a></li><li><a href="#Subzero.boundary_coords-Tuple{Any, Type{East}}"><code>Subzero.boundary_coords</code></a></li><li><a href="#Subzero.boundary_coords-Tuple{Any, Type{North}}"><code>Subzero.boundary_coords</code></a></li><li><a href="#Subzero.boundary_coords-Tuple{Any, Type{West}}"><code>Subzero.boundary_coords</code></a></li><li><a href="#Subzero.calc_angular_momentum-NTuple{7, Any}"><code>Subzero.calc_angular_momentum</code></a></li><li><a href="#Subzero.calc_atmosphere_forcing-NTuple{7, Any}"><code>Subzero.calc_atmosphere_forcing</code></a></li><li><a href="#Subzero.calc_elastic_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat"><code>Subzero.calc_elastic_forces</code></a></li><li><a href="#Subzero.calc_eulerian_data!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}"><code>Subzero.calc_eulerian_data!</code></a></li><li><a href="#Subzero.calc_friction_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Matrix{FT}, Any, Any, Any}} where FT"><code>Subzero.calc_friction_forces</code></a></li><li><a href="#Subzero.calc_kinetic_energy-NTuple{5, Any}"><code>Subzero.calc_kinetic_energy</code></a></li><li><a href="#Subzero.calc_linear_momentum-Tuple{Any, Any, Any}"><code>Subzero.calc_linear_momentum</code></a></li><li><a href="#Subzero.calc_normal_force-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat"><code>Subzero.calc_normal_force</code></a></li><li><a href="#Subzero.calc_ocean_forcing!-NTuple{9, Any}"><code>Subzero.calc_ocean_forcing!</code></a></li><li><a href="#Subzero.calc_one_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT"><code>Subzero.calc_one_way_coupling!</code></a></li><li><a href="#Subzero.calc_strain!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}}, Tuple{FT}} where FT"><code>Subzero.calc_strain!</code></a></li><li><a href="#Subzero.calc_stress!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Any, Any}} where FT"><code>Subzero.calc_stress!</code></a></li><li><a href="#Subzero.calc_subfloe_values!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat"><code>Subzero.calc_subfloe_values!</code></a></li><li><a href="#Subzero.calc_torque!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{&lt;:Floe{FT}}}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.calc_torque!</code></a></li><li><a href="#Subzero.calc_two_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, RegRectilinearGrid, Vararg{Any, 6}}} where FT"><code>Subzero.calc_two_way_coupling!</code></a></li><li><a href="#Subzero.center_cell_coords-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Int64, RegRectilinearGrid, Any, Any}} where FT"><code>Subzero.center_cell_coords</code></a></li><li><a href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, PeriodicBoundary}"><code>Subzero.check_cell_bounds</code></a></li><li><a href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.check_cell_bounds</code></a></li><li><a href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.check_cell_bounds</code></a></li><li><a href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}"><code>Subzero.check_cell_bounds</code></a></li><li><a href="#Subzero.check_energy_momentum_conservation_julia"><code>Subzero.check_energy_momentum_conservation_julia</code></a></li><li><a href="#Subzero.check_energy_momentum_conservation_matlab"><code>Subzero.check_energy_momentum_conservation_matlab</code></a></li><li><a href="#Subzero.check_for_edge_mid-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT"><code>Subzero.check_for_edge_mid</code></a></li><li><a href="#Subzero.compare_floe_data-Tuple{Any, Any}"><code>Subzero.compare_floe_data</code></a></li><li><a href="#Subzero.compare_grid_data-Tuple{Any, Any}"><code>Subzero.compare_grid_data</code></a></li><li><a href="#Subzero.compare_oa_checkpointer_data-Tuple{Any, Any}"><code>Subzero.compare_oa_checkpointer_data</code></a></li><li><a href="#Subzero.conserve_momentum_change_floe_shape!"><code>Subzero.conserve_momentum_change_floe_shape!</code></a></li><li><a href="#Subzero.conserve_momentum_fracture_floe!-Union{Tuple{FT}, Tuple{Any, StructArrays.StructArray{&lt;:Floe{FT}}, Any}} where FT"><code>Subzero.conserve_momentum_fracture_floe!</code></a></li><li><a href="#Subzero.conserve_momentum_transfer_mass!"><code>Subzero.conserve_momentum_transfer_mass!</code></a></li><li><a href="#Subzero.deepcopy_floe-Union{Tuple{StructArrays.LazyRow{Floe{FT}}}, Tuple{FT}} where FT"><code>Subzero.deepcopy_floe</code></a></li><li><a href="#Subzero.deform_floe!-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Vararg{Any, 4}}} where FT"><code>Subzero.deform_floe!</code></a></li><li><a href="#Subzero.determine_fractures-Tuple{Any, Subzero.AbstractFractureCriteria, Any}"><code>Subzero.determine_fractures</code></a></li><li><a href="#Subzero.dissolve_floe!-Tuple{Any, RegRectilinearGrid, Any, Any}"><code>Subzero.dissolve_floe!</code></a></li><li><a href="#Subzero.domain_in_grid-Tuple{Domain, AbstractGrid}"><code>Subzero.domain_in_grid</code></a></li><li><a href="#Subzero.euclidian_dist-Tuple{Any, Any, Any}"><code>Subzero.euclidian_dist</code></a></li><li><a href="#Subzero.find_center_cell_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.find_center_cell_index</code></a></li><li><a href="#Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{East, FT}, PeriodicBoundary{West, FT}}} where FT&lt;:AbstractFloat"><code>Subzero.find_ghosts!</code></a></li><li><a href="#Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{North, FT}, PeriodicBoundary{South, FT}}} where FT&lt;:AbstractFloat"><code>Subzero.find_ghosts!</code></a></li><li><a href="#Subzero.find_grid_cell_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.find_grid_cell_index</code></a></li><li><a href="#Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.find_interp_knots</code></a></li><li><a href="#Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, PeriodicBoundary}"><code>Subzero.find_interp_knots</code></a></li><li><a href="#Subzero.find_poly_coords-Tuple{Any}"><code>Subzero.find_poly_coords</code></a></li><li><a href="#Subzero.find_shared_edges_midpoint-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any}} where FT"><code>Subzero.find_shared_edges_midpoint</code></a></li><li><a href="#Subzero.floe_domain_element_interaction!-Tuple{Any, PeriodicBoundary, Vararg{Any, 4}}"><code>Subzero.floe_domain_element_interaction!</code></a></li><li><a href="#Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Any, Union{CollisionBoundary, MovingBoundary, TopographyElement}, Any, Any, Any, FT}} where FT"><code>Subzero.floe_domain_element_interaction!</code></a></li><li><a href="#Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, OpenBoundary, Vararg{Any, 4}}} where FT"><code>Subzero.floe_domain_element_interaction!</code></a></li><li><a href="#Subzero.floe_domain_interaction!-Union{Tuple{FT}, Tuple{Any, Domain, Any, Any, FT}} where FT&lt;:AbstractFloat"><code>Subzero.floe_domain_interaction!</code></a></li><li><a href="#Subzero.floe_domain_raft!-Tuple{Any, Any, Union{StructArrays.LazyRow{&lt;:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}"><code>Subzero.floe_domain_raft!</code></a></li><li><a href="#Subzero.floe_domain_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Union{StructArrays.LazyRow{&lt;:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}} where FT"><code>Subzero.floe_domain_ridge!</code></a></li><li><a href="#Subzero.floe_floe_interaction!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat"><code>Subzero.floe_floe_interaction!</code></a></li><li><a href="#Subzero.floe_floe_raft!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT"><code>Subzero.floe_floe_raft!</code></a></li><li><a href="#Subzero.floe_floe_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT"><code>Subzero.floe_floe_ridge!</code></a></li><li><a href="#Subzero.floe_to_grid_info!-Union{Tuple{FT}, Tuple{Any, Any, Any, FT, FT, Vararg{Any, 5}}} where FT"><code>Subzero.floe_to_grid_info!</code></a></li><li><a href="#Subzero.fracture_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat"><code>Subzero.fracture_floes!</code></a></li><li><a href="#Subzero.fuse_floes!-NTuple{5, Any}"><code>Subzero.fuse_floes!</code></a></li><li><a href="#Subzero.fuse_two_floes!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 5}}} where FT"><code>Subzero.fuse_two_floes!</code></a></li><li><a href="#Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{SubGridPointsGenerator{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat"><code>Subzero.generate_subfloe_points</code></a></li><li><a href="#Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{MonteCarloPointsGenerator{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat"><code>Subzero.generate_subfloe_points</code></a></li><li><a href="#Subzero.generate_voronoi_coords-Union{Tuple{FT}, Tuple{Int64, Any, Any, Vector{&lt;:Array{Array{Vector{var&quot;#s81&quot;}, 1}, 1} where var&quot;#s81&quot;&lt;:FT}, Any, Int64}} where FT&lt;:AbstractFloat"><code>Subzero.generate_voronoi_coords</code></a></li><li><a href="#Subzero.get_known_grid_outputs-Tuple{}"><code>Subzero.get_known_grid_outputs</code></a></li><li><a href="#Subzero.get_velocity-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, FT, FT}} where FT"><code>Subzero.get_velocity</code></a></li><li><a href="#Subzero.get_velocity-Union{Tuple{FT}, Tuple{Subzero.AbstractDomainElement{FT}, Any, Any}} where FT"><code>Subzero.get_velocity</code></a></li><li><a href="#Subzero.getattrs-Tuple{Symbol}"><code>Subzero.getattrs</code></a></li><li><a href="#Subzero.ghosts_on_bounds!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}"><code>Subzero.ghosts_on_bounds!</code></a></li><li><a href="#Subzero.grid_cell_index-Tuple{Any, Any, Any}"><code>Subzero.grid_cell_index</code></a></li><li><a href="#Subzero.grid_line_index-Tuple{Any, Any, Any}"><code>Subzero.grid_line_index</code></a></li><li><a href="#Subzero.grid_xc_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.grid_xc_index</code></a></li><li><a href="#Subzero.grid_xg_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.grid_xg_index</code></a></li><li><a href="#Subzero.grid_yc_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.grid_yc_index</code></a></li><li><a href="#Subzero.grid_yg_index-Tuple{Any, Any, RegRectilinearGrid}"><code>Subzero.grid_yg_index</code></a></li><li><a href="#Subzero.grids_from_lines-Tuple{Any, Any}"><code>Subzero.grids_from_lines</code></a></li><li><a href="#Subzero.hashole-Union{Tuple{Array{Array{Vector{FT}, 1}, 1}}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>Subzero.hashole</code></a></li><li><a href="#Subzero.hashole-Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat}"><code>Subzero.hashole</code></a></li><li><a href="#Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.in_bounds</code></a></li><li><a href="#Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, PeriodicBoundary}"><code>Subzero.in_bounds</code></a></li><li><a href="#Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}"><code>Subzero.in_bounds</code></a></li><li><a href="#Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.in_bounds</code></a></li><li><a href="#Subzero.initialize_floe_field-Tuple"><code>Subzero.initialize_floe_field</code></a></li><li><a href="#Subzero.initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT"><code>Subzero.initialize_floe_field</code></a></li><li><a href="#Subzero.initialize_jld2_file!-NTuple{5, Any}"><code>Subzero.initialize_jld2_file!</code></a></li><li><a href="#Subzero.initialize_netcdf_file!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 6}}} where FT"><code>Subzero.initialize_netcdf_file!</code></a></li><li><a href="#Subzero.initialize_topography_field-Union{Tuple{FT}, Tuple{Type{FT}, Any}} where FT&lt;:AbstractFloat"><code>Subzero.initialize_topography_field</code></a></li><li><a href="#Subzero.initialize_topography_field-Tuple"><code>Subzero.initialize_topography_field</code></a></li><li><a href="#Subzero.intersect_polys-Union{Tuple{FT}, Tuple{Any, Any}, Tuple{Any, Any, Type{FT}}} where FT"><code>Subzero.intersect_polys</code></a></li><li><a href="#Subzero.level_to_string-Tuple{Any}"><code>Subzero.level_to_string</code></a></li><li><a href="#Subzero.mc_interpolation-NTuple{7, Any}"><code>Subzero.mc_interpolation</code></a></li><li><a href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{South, &lt;:AbstractFloat}}} where FT"><code>Subzero.normal_direction_correct!</code></a></li><li><a href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{North, &lt;:AbstractFloat}}} where FT"><code>Subzero.normal_direction_correct!</code></a></li><li><a href="#Subzero.normal_direction_correct!-Tuple{Any, Any, TopographyElement}"><code>Subzero.normal_direction_correct!</code></a></li><li><a href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{West, &lt;:AbstractFloat}}} where FT"><code>Subzero.normal_direction_correct!</code></a></li><li><a href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{East, &lt;:AbstractFloat}}} where FT"><code>Subzero.normal_direction_correct!</code></a></li><li><a href="#Subzero.periodic_compat-Tuple{PeriodicBoundary, PeriodicBoundary}"><code>Subzero.periodic_compat</code></a></li><li><a href="#Subzero.plot_conservation-NTuple{7, Any}"><code>Subzero.plot_conservation</code></a></li><li><a href="#Subzero.poly_to_floes!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat"><code>Subzero.poly_to_floes!</code></a></li><li><a href="#Subzero.potential_interaction-NTuple{4, Any}"><code>Subzero.potential_interaction</code></a></li><li><a href="#Subzero.prettytime-Tuple{Any}"><code>Subzero.prettytime</code></a></li><li><a href="#Subzero.remove_floe_overlap!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT&lt;:AbstractFloat"><code>Subzero.remove_floe_overlap!</code></a></li><li><a href="#Subzero.remove_floes!-NTuple{5, Any}"><code>Subzero.remove_floes!</code></a></li><li><a href="#Subzero.replace_floe!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT"><code>Subzero.replace_floe!</code></a></li><li><a href="#Subzero.restart!-NTuple{4, Any}"><code>Subzero.restart!</code></a></li><li><a href="#Subzero.rotate_radians!-Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real, Any}"><code>Subzero.rotate_radians!</code></a></li><li><a href="#Subzero.run!-Tuple{Any}"><code>Subzero.run!</code></a></li><li><a href="#Subzero.shift_cell_idx-Tuple{Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}"><code>Subzero.shift_cell_idx</code></a></li><li><a href="#Subzero.shift_cell_idx-Tuple{Any, Any, PeriodicBoundary}"><code>Subzero.shift_cell_idx</code></a></li><li><a href="#Subzero.simplify_floes!-NTuple{7, Any}"><code>Subzero.simplify_floes!</code></a></li><li><a href="#Subzero.smooth_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT&lt;:AbstractFloat"><code>Subzero.smooth_floes!</code></a></li><li><a href="#Subzero.split_floe-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT"><code>Subzero.split_floe</code></a></li><li><a href="#Subzero.startup_sim"><code>Subzero.startup_sim</code></a></li><li><a href="#Subzero.teardown_sim-Tuple{Any}"><code>Subzero.teardown_sim</code></a></li><li><a href="#Subzero.timestep_collisions!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 6}}} where FT&lt;:AbstractFloat"><code>Subzero.timestep_collisions!</code></a></li><li><a href="#Subzero.timestep_coupling!-NTuple{5, Any}"><code>Subzero.timestep_coupling!</code></a></li><li><a href="#Subzero.timestep_floe_properties!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Any, Any}} where FT"><code>Subzero.timestep_floe_properties!</code></a></li><li><a href="#Subzero.timestep_ridging_rafting!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat"><code>Subzero.timestep_ridging_rafting!</code></a></li><li><a href="#Subzero.timestep_sim!"><code>Subzero.timestep_sim!</code></a></li><li><a href="#Subzero.timestep_welding!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat"><code>Subzero.timestep_welding!</code></a></li><li><a href="#Subzero.translate-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.translate</code></a></li><li><a href="#Subzero.translate!-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT&lt;:AbstractFloat"><code>Subzero.translate!</code></a></li><li><a href="#Subzero.update_boundaries!-Tuple{Any, Any}"><code>Subzero.update_boundaries!</code></a></li><li><a href="#Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D&lt;:Union{East, West}, FT&lt;:AbstractFloat}"><code>Subzero.update_boundary!</code></a></li><li><a href="#Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D&lt;:Union{North, South}, FT&lt;:AbstractFloat}"><code>Subzero.update_boundary!</code></a></li><li><a href="#Subzero.update_boundary!-Tuple{Union{CollisionBoundary, OpenBoundary, PeriodicBoundary}, Any}"><code>Subzero.update_boundary!</code></a></li><li><a href="#Subzero.update_criteria!-Union{Tuple{FT}, Tuple{HiblerYieldCurve{FT}, Any}} where FT"><code>Subzero.update_criteria!</code></a></li><li><a href="#Subzero.update_criteria!-Tuple{MohrsCone, Any}"><code>Subzero.update_criteria!</code></a></li><li><a href="#Subzero.update_ghost_timestep_vals!-Tuple{Any, Any, Any}"><code>Subzero.update_ghost_timestep_vals!</code></a></li><li><a href="#Subzero.update_new_rotation_conserve!-NTuple{9, Any}"><code>Subzero.update_new_rotation_conserve!</code></a></li><li><a href="#Subzero.valid_polyvec!-Tuple{Any}"><code>Subzero.valid_polyvec!</code></a></li><li><a href="#Subzero.valid_ringvec!-Tuple{Any}"><code>Subzero.valid_ringvec!</code></a></li><li><a href="#Subzero.which_points_on_edges-Tuple{Any, Any}"><code>Subzero.which_points_on_edges</code></a></li><li><a href="#Subzero.which_vertices_match_points-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Any}} where FT"><code>Subzero.which_vertices_match_points</code></a></li><li><a href="#Subzero.write_checkpoint_data!-Tuple{Any, Any}"><code>Subzero.write_checkpoint_data!</code></a></li><li><a href="#Subzero.write_data!-Tuple{Any, Any, Any}"><code>Subzero.write_data!</code></a></li><li><a href="#Subzero.write_floe_data!-Tuple{Any, Any, Any}"><code>Subzero.write_floe_data!</code></a></li><li><a href="#Subzero.write_grid_data!-NTuple{4, Any}"><code>Subzero.write_grid_data!</code></a></li><li><a href="#Subzero.write_init_state_data!-Tuple{Any}"><code>Subzero.write_init_state_data!</code></a></li></ul><h2 id="All-methods" tabindex="-1">All methods <a class="header-anchor" href="#All-methods" aria-label="Permalink to &quot;All methods {#All-methods}&quot;">​</a></h2><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Subzero" href="#Subzero.Subzero">#</a> <b><u>Subzero.Subzero</u></b> — <i>Module</i>. <p>Module <code>Subzero.jl</code> - UW&#39;s sea ice model ported from MATLAB to Julia</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.NonPeriodicBoundary" href="#Subzero.NonPeriodicBoundary">#</a> <b><u>Subzero.NonPeriodicBoundary</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">NonPeriodicBoundary</span></span></code></pre></div><p>Union of all non-peridic boundary types to use as shorthand for dispatch.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.AbstractBoundary" href="#Subzero.AbstractBoundary">#</a> <b><u>Subzero.AbstractBoundary</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractBoundary{D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractDirection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, FT}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractDomainElement{FT}</span></span></code></pre></div><p>An abstract type for the types of boundaries at the edges of the model domain. Boundary types will control behavior of sea ice floes at edges of domain. The direction given by type D denotes which edge of a domain this boundary could be and type FT is the simulation float type (e.g. Float64 or Float32).</p><p>Each boundary type has the coordinates of the boudnary as a field. These should be shapes that completely seal the domain, and should overlap on the corners as seen in the example below: ________________ |<strong>|_<em><strong>val</strong></em>|</strong>| &lt;- North coordinates include corners | | | | | | | | &lt;- East and west coordinates ALSO include corners | | | | Each bounday type also has a field called &quot;val&quot; that holds value that defines the line y = val or x = val (depending on boundary direction), such that if the floe crosses that line it would be partially within the boundary.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.AbstractDirection" href="#Subzero.AbstractDirection">#</a> <b><u>Subzero.AbstractDirection</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractDirection</span></span></code></pre></div><p>An abstract type for the boundary cardinal directions within model domain. Boundary direction will control behavior of sea ice floes at edges of domain.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.AbstractDomainElement" href="#Subzero.AbstractDomainElement">#</a> <b><u>Subzero.AbstractDomainElement</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractDomainElement{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>An abstract type for all of the element that create the shape of the domain: the 4 boundary walls that make up the rectangular domain and the topography within the domain.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.AbstractFractureCriteria" href="#Subzero.AbstractFractureCriteria">#</a> <b><u>Subzero.AbstractFractureCriteria</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractFractureCriteria</span></span></code></pre></div><p>Abstract type for fracture criteria. Each struct of this type must have a vertices field representing the criteria in principal stress space. For a given polygon, the minimum and maximum eigenvalues of its stress field will be its location in principal stress space. If that stress point falls outside of the criteria-verticies defined polygon it is a stress great enough to fracture the floe. Otherwise the floe will not be fractured. Each fracture criteria type must also have an update_criteria! function defined that is used to update the criteria each timestep. If the criteria does not need to be updated, this function can be empty.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.AbstractGrid" href="#Subzero.AbstractGrid">#</a> <b><u>Subzero.AbstractGrid</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractGrid</span></span></code></pre></div><p>An abstract type for the grid that model will be simulated on. Affects calculation on the grid.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.AbstractOutputWriter" href="#Subzero.AbstractOutputWriter">#</a> <b><u>Subzero.AbstractOutputWriter</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractOutputWriter</span></span></code></pre></div><p>An abstract type for output writers that provide data from simulation runs.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.AbstractStressCalculator" href="#Subzero.AbstractStressCalculator">#</a> <b><u>Subzero.AbstractStressCalculator</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AbstractStressCalculator{FT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Abstract super type for stress calculators, which calculate a floe&#39;s stress from floe interactions. The subtypes serve as dispatch types for the following three calculation methods.</p><p><strong>API</strong></p><p>The following methods must be implemented for all subtypes:</p><ul><li><p><code>_update_stress_accum!(stress_calculator::AbstractStressCalculator{FT}, curr_stress::Matrix{FT} , floe::FloeType{FT})</code></p></li><li><p><code>_scale_principal_stress!(stress_calculator::AbstractStressCalculator{FT}, σvals::Matrix{FT}, floe::FloeType{FT}, floe_settings::FloeSettings)</code></p></li></ul><p><code>_update_stress_accum!</code> is called in the <code>calc_stress!</code> function and takes the stress calculator, the <code>floe</code>&#39;s instantatious stress at the current timestep, and the <code>floe</code> itself and updates the <code>floe</code>&#39;s <code>stress_accum</code> field, which is used when determining floe fracture based off of stress. Within the function, other floe fields can be updated as needed.</p><p><code>_scale_principal_stress!</code> is called within the <code>find_σpoint</code> function which is called within the <code>determine_fractures</code> function. This function takes the stress calculator, the <code>floe</code>&#39;s accumulated stress in prinicpal stress space (<code>σvals = eigvals(stress_accum)</code>), the <code>floe</code> itself, and the <code>floe_settings</code> and scales <code>σvals</code> by some values/ratio using physical properties within <code>floe</code> and <code>floe_settings</code>. This is done to approximate changing the polygon defining the floe&#39;s fracture criteria without having to redefine the fracture criteria for each floe. This is almost like a proxy for damage.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.AbstractSubFloePointsGenerator" href="#Subzero.AbstractSubFloePointsGenerator">#</a> <b><u>Subzero.AbstractSubFloePointsGenerator</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractSubFloePointsGenerator</span></span></code></pre></div><p>Abstract type for parameters determining generation of sub-floe points used for interpolation. The points generated using these parameters will be used to find stresses on each floe from the ocean and the atmosphere. There must be a <code>generate_subfloe_points</code> function that dispatches off of the subtype of AbstractSubFloePointsGenerator to generate the points for a given floe. Points generated must all be within a given floe.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Atmos" href="#Subzero.Atmos">#</a> <b><u>Subzero.Atmos</u></b> — <i>Type</i>. <p>Atmos velocities in the x-direction (u) and y-direction (v). u and v should match the size of the corresponding model grid so that there is one x and y velocity value for each grid cell. Atmos also needs temperature at the atmosphere/ice interface in each grid cell. Model cannot be constructed if size of atmos fields and grid do not match.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Atmos-Tuple" href="#Subzero.Atmos-Tuple">#</a> <b><u>Subzero.Atmos</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Atmos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a type isn&#39;t specified, Atmos will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Atmos-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.Atmos-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.Atmos</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Atmos{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, u, v)</span></span></code></pre></div><p>Construct model atmosphere of type FT. Inputs: grid &lt;AbstractGrid&gt; model&#39;s grid u &lt;Real&gt; Atmos x-velocity for each grid cell v &lt;Real&gt; Atmos y-velocity for each grid cell temp &lt;Real&gt; temperature at atmopshere/ice interface per grid cell Output: Atmosphere of type FT with constant velocity and temperature over domain.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Atmos-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.Atmos-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.Atmos</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Atmos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any Atmos constructor. An Atmos of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.CellFloes" href="#Subzero.CellFloes">#</a> <b><u>Subzero.CellFloes</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CellFloes{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Struct that tracks which floes are within given cell, as well as the translation vector needed to move floe each from current postion into cell if it is in cell due to periodic boundaries. Each index in floeidx is the index of a floe within the cell and the Δx and Δy with the same index are that floe&#39;s translation vector. Note: the floeidx is the index of grid cells centered on grid lines, not on the grid cells defined by the regular, rectilinear grid.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.CellFloes-Union{Tuple{}, Tuple{FT}} where FT" href="#Subzero.CellFloes-Union{Tuple{}, Tuple{FT}} where FT">#</a> <b><u>Subzero.CellFloes</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CellFloes{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Constructs an CellFloes object with empty lists for fields.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.CheckpointOutputWriter" href="#Subzero.CheckpointOutputWriter">#</a> <b><u>Subzero.CheckpointOutputWriter</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CheckpointOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(writer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CheckpointOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [Δtout]; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates an checkpoint writer from an existing writer, copying all fields unless new field values are explicity provided either as the optional argument Δtout or through keyword arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.CheckpointOutputWriter-2" href="#Subzero.CheckpointOutputWriter-2">#</a> <b><u>Subzero.CheckpointOutputWriter</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CheckpointOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Δtout, fn){ST</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractOutputWriter</span></span></code></pre></div><p>Checkpoint subtype of AbstractOutputWriter that holds information for outputting checkpoint information used for restarting the simulation from a point where the writer saved data. Checkpoint data is saved every Δtout timesteps to filepath. If the given file doesn&#39;t end in &quot;.jld2&quot; the extension will be appended. If overwrite is true then if there is already a file of the given name, it will be overwriten. Else it will thrown an error.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.CheckpointOutputWriter-Tuple{Any}" href="#Subzero.CheckpointOutputWriter-Tuple{Any}">#</a> <b><u>Subzero.CheckpointOutputWriter</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CheckpointOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δtout;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    filename </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;checkpoint.jld2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    overwrite </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    jld2_kw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict{Symbol, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>CheckpointOutputWriter writer that outputs need data to restart simulation at given timesteps Δtout. Inputs: Δtout &lt;Int&gt; number of timesteps between output dir &lt;String&gt; Directory to save output to - default is &quot;.&quot; (current working directory). filename &lt;String&gt; filename to save file to overwrite &lt;Bool&gt; if true, exit file of the same name will be deleted, else an error will be thrown if other file exists jld2_kw list of JLD2 keywords for the jldopen function Outputs: CheckpointOutputWriter that outputs floes, ocean, and atmosphere states at desired timesteps.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.CollisionBoundary" href="#Subzero.CollisionBoundary">#</a> <b><u>Subzero.CollisionBoundary</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CollisionBoundary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractBoundary</span></span></code></pre></div><p>A sub-type of AbstractBoundary that stops a floe from exiting the domain by having the floe collide with the boundary. The boundary acts as an immovable, unbreakable ice floe in the collision.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.CollisionBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}" href="#Subzero.CollisionBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}">#</a> <b><u>Subzero.CollisionBoundary</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CollisionBoundary{D, FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid)</span></span></code></pre></div><p>Creates collision boundary on the edge of the grid, and with the direction as a type. Edge is determined by direction. Inputs: grid &lt;AbstractGrid&gt; model grid direction &lt;AbstractDirection&gt; direction of boundary wall Outputs: Collision Boundary on edge of grid given by direction.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}" href="#Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}">#</a> <b><u>Subzero.CollisionBoundary</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CollisionBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{D}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any CollisionBoundary constructor. The second argument D is the directional type of the boundary. A CollisionBoundary of type FT and D will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection" href="#Subzero.CollisionBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection">#</a> <b><u>Subzero.CollisionBoundary</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CollisionBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{D}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a float type isn&#39;t specified, CollisionBoundary will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.CollisionSettings" href="#Subzero.CollisionSettings">#</a> <b><u>Subzero.CollisionSettings</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CollisionSettings{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Settings needed for collisions within the model. If collisions_on is true, collisions will occur, else they will not. The floe_floe_max_overlap defines the percentage of overlap allowed between floes before marking them for ridging/rafting. The floe_domain_max_overlap defines the percentage of overlap allowed between floes and the domain (collision boundaries and topography) before removing the floe from the simulation. Both floe_floe_max_overlap and floe_domain_max_overlap should be between 0-1 and if a value &lt; 0 is given or a value &gt; 1 is given when collisions_on is true they will be set to 0 and 1 respectively.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.CollisionSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.CollisionSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.CollisionSettings</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CollisionSettings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any CollisionSettings constructor. A CollisionSettings of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Constants-Tuple" href="#Subzero.Constants-Tuple">#</a> <b><u>Subzero.Constants</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Constants</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a type isn&#39;t specified, Constants will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Constants-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.Constants-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.Constants</u></b> — <i>Method</i>. <p>Constants(::Type{FT}, args...)</p><p>A float type FT can be provided as the first argument of any Constants constructor. A Constants of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.CouplingSettings" href="#Subzero.CouplingSettings">#</a> <b><u>Subzero.CouplingSettings</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CouplingSettings</span></span></code></pre></div><p>Settings needed for coupling within the model. If coupling_on is true, the model will be coupled with the simulation&#39;s ocean and atmosphere. The Δt determines how many simulation timesteps between calculating ocean and atmospheric forces on the floes. Δd number of buffer grid cells on each side of floe for monte carlo interpolation and mc_n is the number of monte carlo points to attempt to generage for each floe. If two_way_coupling_on is true then the simulation calculates the stress the ice/atmosphere put on the ocean.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.DamageStressCalculator" href="#Subzero.DamageStressCalculator">#</a> <b><u>Subzero.DamageStressCalculator</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DamageStressCalculator{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractStressCalculator{FT}</span></span></code></pre></div><p>Type of AbstractStressCalculator that calculates stress with each timestep with <code>damage * stress_instant</code>, as suggested by Mukund Gupta. This method could keep track of damage directly within each floe using the <code>damage</code> floe field, perhapes as a value between 0-1, and rather than calculating an &quot;accumulated stress&quot; to store damage, as done in <code>DecayAreaScaledCalculator</code>.</p><p>In this calculator, the floe&#39;s <code>damage</code> field keeps track of an explicit parameter.</p><p><strong>Fields:</strong></p><p><strong>Note:</strong></p><p>This method is not implemented and thus throws an error upon creation. The infrastructure for the damage calculator is provided, but functions that depend on this calculator need to be implemented as detailed in the <code>AbstractStressCalculator</code> API.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.DamageStressCalculator-Tuple" href="#Subzero.DamageStressCalculator-Tuple">#</a> <b><u>Subzero.DamageStressCalculator</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DamageStressCalculator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If type isn&#39;t specified, <code>DamageStressCalculator</code>(; kwargs...) will be of type <code>Float64</code> and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.DamageStressCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.DamageStressCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.DamageStressCalculator</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DamageStressCalculator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type <code>FT</code> can be provided as the first argument of any <code>DamageStressCalculator</code> constructor. A <code>DamageStressCalculator</code> of type <code>FT</code> will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.DecayAreaScaledCalculator" href="#Subzero.DecayAreaScaledCalculator">#</a> <b><u>Subzero.DecayAreaScaledCalculator</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DecayAreaScaledCalculator{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractStressCalculator{FT}</span></span></code></pre></div><p>Type of AbstractStressCalculator that implements stress calculations by accumulating each timestep of stress using a decay equation. The decay aspect increases importance placed on new damage. The decay equation is as follows:</p><p>`stress_accum = stress_accum(1-λ) + stress_instant(λ)</p><p>The area-scaling part of the stress calculations comes into play when deciding if a floe will be fractured. The accumulated stress can be scaled by a ratio of (floe.area/min_floe_area)^α. By changing the α value, either larger or smaller floes fracture more eassily. The scaled value will not be saved as this is equivalent to scaling the simulation fracture criteria (morh&#39;s cone or hibler&#39;s ellipse, etc.), but it is less computationally intensive. By leaving the default <code>α = 0</code>, this extra scaling will not take place.</p><p><strong>Fields:</strong></p><ul><li><p><code>λ::AbstractFloat</code>: decay parameter used when calculating accumulated stress. Should be between 0 - 1.</p></li><li><p><code>α::AbstractFloat</code>: Adjusts ellipse in stress space by raising the ratio to the floe&#39;s area over the simulation minimum floe size to <code>α</code>.</p></li></ul><p><strong>Note:</strong></p><ul><li><code>λ</code> is used in <code>_update_stress_accum!</code>, whereas α is used in <code>_scale_principal_stress!</code>.</li></ul><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.DecayAreaScaledCalculator-Tuple" href="#Subzero.DecayAreaScaledCalculator-Tuple">#</a> <b><u>Subzero.DecayAreaScaledCalculator</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DecayAreaScaledCalculator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If type isn&#39;t specified as the first argument, <code>DecayAreaScaledCalculator</code>(; kwargs...) will be of type <code>Float64</code> and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.DecayAreaScaledCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.DecayAreaScaledCalculator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.DecayAreaScaledCalculator</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DecayAreaScaledCalculator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type <code>FT</code> can be provided as the first argument of any <code>DecayAreaScaledCalculator</code> constructor. A <code>DecayAreaScaledCalculator</code> of type <code>FT</code> will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Domain" href="#Subzero.Domain">#</a> <b><u>Subzero.Domain</u></b> — <i>Type</i>. <p>Domain that holds 4 Boundary elements, forming a rectangle bounding the model during the simulation, and a list of topography elements.</p><p>In order to create a Domain, three conditions need to be met. First, if needs to be periodically compatible. This means that pairs of opposite boundaries both need to be periodic if one of them is periodic. Next, the value in the north boundary must be greater than the south boundary and the value in the east boundary must be greater than the west in order to form a valid rectangle.</p><p>Note: The code depends on the boundaries forming a rectangle oriented along the cartesian grid. Other shapes/orientations are not supported at this time.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Domain-Union{Tuple{WB}, Tuple{EB}, Tuple{SB}, Tuple{NB}, Tuple{FT}, Tuple{NB, SB, EB, WB}} where {FT&lt;:AbstractFloat, NB&lt;:AbstractBoundary{North, FT}, SB&lt;:AbstractBoundary{South, FT}, EB&lt;:AbstractBoundary{East, FT}, WB&lt;:AbstractBoundary{West, FT}}" href="#Subzero.Domain-Union{Tuple{WB}, Tuple{EB}, Tuple{SB}, Tuple{NB}, Tuple{FT}, Tuple{NB, SB, EB, WB}} where {FT&lt;:AbstractFloat, NB&lt;:AbstractBoundary{North, FT}, SB&lt;:AbstractBoundary{South, FT}, EB&lt;:AbstractBoundary{East, FT}, WB&lt;:AbstractBoundary{West, FT}}">#</a> <b><u>Subzero.Domain</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Domain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(north, south, east, west)</span></span></code></pre></div><p>Creates domain with empty list of topography and given boundaries. Inputs: north &lt;AbstractBoundary&gt; north boundary south &lt;AbstractBoundary&gt; south boundary east &lt;AbstractBoundary&gt; east boundary west &lt;AbstractBoundary&gt; west boundary</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.East" href="#Subzero.East">#</a> <b><u>Subzero.East</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">East</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractDirection</span></span></code></pre></div><p>A simple direction type representing if a boundary is the eastern boundary in a rectangular domain.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Floe" href="#Subzero.Floe">#</a> <b><u>Subzero.Floe</u></b> — <i>Type</i>. <p>Singular sea ice floe with fields describing current state.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Floe-Tuple" href="#Subzero.Floe-Tuple">#</a> <b><u>Subzero.Floe</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Floe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a type isn&#39;t specified, Floe will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Floe-Union{Tuple{FT}, Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.Floe-Union{Tuple{FT}, Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real, Any, Any}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.Floe</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Floe{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    coords</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PolyVec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hmean,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δh;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ρi </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 920.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mc_n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Xoshiro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Floe constructor with PolyVec coordinates Inputs: coords &lt;Vector{Vector{Vector{Float64}}}&gt; floe coordinates hmean &lt;Real&gt; mean height for floes Δh &lt;Real&gt; variability in height for floes floe_settings &lt;FloeSettings&gt; settings needed to initialize floe rng &lt;RNG&gt; random number generator to generate random floe attributes - default uses Xoshiro256++ algorithm kwargs Any other floe fields to set as keyword arguments Output: &lt;Floe&gt; with needed fields defined - all default field values used so all forcings start at 0 and floe&#39;s status is &quot;active&quot; as long as monte carlo points were able to be generated.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Floe-Union{Tuple{FT}, Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.Floe-Union{Tuple{FT}, Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat, Any, Any}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.Floe</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Floe{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    poly</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Polys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hmean,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δh;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FloeSettings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Xoshiro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Constructor for floe with a polygon Inputs: poly &lt;Polygon&gt; hmean &lt;Real&gt; mean height for floes Δh &lt;Real&gt; variability in height for floes floe_settings &lt;FloeSettings&gt; settings needed to initialize floe rng &lt;RNG&gt; random number generator to generate floe attributes - default is Xoshiro256++ algorithm kwargs Any other floe fields to set as keyword arguments Output: &lt;Floe&gt; with needed fields defined - all default field values used so all forcings start at 0 and floe&#39;s status is &quot;active&quot; as long as monte carlo points were able to be generated.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Floe-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.Floe-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.Floe</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Floe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any Floe constructor. A Floe of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.FloeOutputWriter" href="#Subzero.FloeOutputWriter">#</a> <b><u>Subzero.FloeOutputWriter</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FloeOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(writer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FloeOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [Δtout]; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates an floe output writer from an existing writer, copying all fields unless new field values are explicity provided either as the optional argument Δtout or through keyword arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.FloeOutputWriter-2" href="#Subzero.FloeOutputWriter-2">#</a> <b><u>Subzero.FloeOutputWriter</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FloeOutputWriter{ST</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractOutputWriter</span></span></code></pre></div><p>Floe subtype of AbstractOutputWriter that holds information for outputting floe information from model throughout simulation. Output will be saved to the file defined by fn every Δtout timesteps. Only outputs within the outputs list will be saved. File will be saved as a JLD2 file to filepath. If the given file doesn&#39;t end in &quot;.jld2&quot; the extension will be appended. If overwrite is true then if there is already a file of the given name, it will be overwriten. Else it will thrown an error.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.FloeOutputWriter-Tuple{Any}" href="#Subzero.FloeOutputWriter-Tuple{Any}">#</a> <b><u>Subzero.FloeOutputWriter</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FloeOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δtout;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    outputs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> collect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fieldnames</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Floe)),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    filename </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;floes.jld2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    overwrite </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    jld2_kw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict{Symbol, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>FloeOutput writer that outputs provided Floe fields at given timesteps Δtout and saves the information in a file of the provided name. Inputs: Δtout &lt;Int&gt; number of timesteps between output outputs &lt;Vector{Symbols}&gt; list of floe fields to output dir &lt;String&gt; Directory to save output to - default is &quot;.&quot; (current working directory) filename &lt;String&gt; filename to save file to overwrite &lt;Bool&gt; if true, exit file of the same name will be deleted, else an error will be thrown if other file exists jld2_kw list of JLD2 keywords for the jldopen function Outputs: FloeOutputWriter that outputs provided Floe fields every Δtout timesteps to filename Note: If floe field&#39;s are not specified using <code>outputs</code>, all Floe fields will be saved</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.FloeSettings" href="#Subzero.FloeSettings">#</a> <b><u>Subzero.FloeSettings</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FloeSettings</span></span></code></pre></div><p>Settings needed to create floes within the model.</p><ul><li><p>ρi is the density of all floes within the model</p></li><li><p>min_floe_area is the minimum floe area within the model before removal</p></li><li><p>min_floe_height is the minimum floe height within the model before removal</p></li><li><p>max_floe_height is the maximum floe height within the model before the height can&#39;t increase any further</p></li><li><p>min_aspect_ratio is the minimum ratio between the x-length and y-length of any floe prior to removal</p></li><li><p>subfloe_point_generator is the method of subfloe point generation for each floe within the model</p></li><li><p>stress_calculator is the method of calculating current stress of floe</p></li></ul><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.FloeSettings-Union{Tuple{Type{FT}}, Tuple{CT}, Tuple{GT}, Tuple{FT}} where {FT&lt;:AbstractFloat, GT&lt;:Subzero.AbstractSubFloePointsGenerator, CT&lt;:AbstractStressCalculator}" href="#Subzero.FloeSettings-Union{Tuple{Type{FT}}, Tuple{CT}, Tuple{GT}, Tuple{FT}} where {FT&lt;:AbstractFloat, GT&lt;:Subzero.AbstractSubFloePointsGenerator, CT&lt;:AbstractStressCalculator}">#</a> <b><u>Subzero.FloeSettings</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FloeSettings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; subfloe_point_generator, kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any FloeSettings constructor. A FloeSettings of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.FractureSettings" href="#Subzero.FractureSettings">#</a> <b><u>Subzero.FractureSettings</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FractureSettings{CT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFractureCriteria</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Settings needed for fractures within the model. If fractures_on is true, fractures will occur, else they will not. The criteria defines which fracture criteria are used to determine which floes to fracture. The Δt determines how many simulation timesteps between fracturing floes. If deform_on is true, then the floe will be deformed around floe primarily causing the fracture, identified by the largest overlap area on the most recent set of collisions. Npieces denotes how many pieces to try to split a fractured floe into - 3 is suggested value.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.GridOutputWriter" href="#Subzero.GridOutputWriter">#</a> <b><u>Subzero.GridOutputWriter</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GridOutputWriter{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractOutputWriter</span></span></code></pre></div><p>Grid subtype of AbstractOutputWriter that holds information for outputting floe data on the grid. This output does not need to be the grid defined for the model. This grid can be coarser, or more fine, as defined by the xg and yg fields. Output on this scale will be saved to the file defined by filepath every Δtout timesteps. Data will be collected in the data field during calculation for easier writing to the NetCDF file. Only outputs within the outputs list will be saved. There is a limited number of floe outputs that can be calculated by the GridOutputWriter.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.GridOutputWriter-Tuple" href="#Subzero.GridOutputWriter-Tuple">#</a> <b><u>Subzero.GridOutputWriter</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GridOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a type isn&#39;t specified, GridOutputWriter will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.GridOutputWriter-Tuple{GridOutputWriter}" href="#Subzero.GridOutputWriter-Tuple{GridOutputWriter}">#</a> <b><u>Subzero.GridOutputWriter</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GridOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(writer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GridOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [Δtout]; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates an grid output writer from an existing writer, copying all fields unless new field values are explicity provided through keyword arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Any, AbstractGrid, Any}} where FT&lt;:AbstractFloat" href="#Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Any, AbstractGrid, Any}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.GridOutputWriter</u></b> — <i>Method</i>. <p>GridOutputWriter{FT}( outputs::Vector{Symbol}, Δtout, grid::AbstractGrid, dims; dir = &quot;.&quot;, filename = &quot;gridded_data.nc&quot;, overwrite = false, average = false,</p><p>Create GridOutputWriter for grid of given dimensions to output floe data averaged on this re-gridded gird at given frequency of timesteps. Only outputs provided outputs. Inputs: outputs &lt;Vector{Symbols}&gt; list of grid outputs desired Δtout &lt;Int&gt; number of timesteps between output grid &lt;Grid&gt; original grid, which we are re-gridding dims &lt;(Int, Int)&gt; output new grid dimensions for these calculations - rows -&gt; ny, cols -&gt; nx dir &lt;String&gt; Directory to save output to - default is &quot;.&quot; (current working directory) filename &lt;String&gt; filename to save file to overwrite &lt;Bool&gt; if true, exit file of the same name will be deleted, else an error will be thrown if other file exist average &lt;Bool&gt; if true, average gridded data over timesteps between outputs, else just calculate at output timestep Output: GridOutputWriter that re-grids grid to given dimensions, and saves floe information averaged on this new grid.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.GridOutputWriter-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.GridOutputWriter</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GridOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any GridOutputWriter constructor. A GridOutputWriter of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.HiblerYieldCurve" href="#Subzero.HiblerYieldCurve">#</a> <b><u>Subzero.HiblerYieldCurve</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HiblerYieldCurve{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFractureCriteria</span></span></code></pre></div><p>Type of AbstractFractureCriteria that creates a yield curve that determines if a floe fractures based off if its stress in principal stress space is inside or outside of the yield curve. Fields: pstar &lt;AbstractFloat&gt; used to tune ellipse for optimal fracturing c &lt;AbstractFloat&gt; used to tune ellipse for optimal fracturing verticies &lt;PolyVec&gt; vertices of criteria in principal stress space Note: Hibler&#39;s paper says that: Both pstar and c relate the ice strength to the ice thickness and compactness. c is determined to that 10% open water reduces the strength substantially and pstar is considered a free parameter</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.HiblerYieldCurve-Tuple" href="#Subzero.HiblerYieldCurve-Tuple">#</a> <b><u>Subzero.HiblerYieldCurve</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HiblerYieldCurve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a type isn&#39;t specified, HiblerYieldCurve will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.HiblerYieldCurve-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.HiblerYieldCurve-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.HiblerYieldCurve</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HiblerYieldCurve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any HiblerYieldCurve constructor. A HiblerYieldCurve of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.HiblerYieldCurve-Union{Tuple{StructArrays.StructArray{&lt;:Floe{FT}}}, Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.HiblerYieldCurve-Union{Tuple{StructArrays.StructArray{&lt;:Floe{FT}}}, Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Any}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.HiblerYieldCurve</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HiblerYieldCurve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(floes, pstar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.25e5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calculates Hibler&#39;s Elliptical Yield curve using parameters pstar, c, and the current floe field. Inputs: floes &lt;StructArray{Floes}&gt; model&#39;s list of floes pstar &lt;AbstractFloat&gt; used to tune ellipse for optimal fracturing c &lt;AbstractFloat&gt; used to tune ellipse for optimal fracturing Outputs: HiblerYieldCurve struct with vertices determined using the _calculate_hibler function.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.IceStressCell" href="#Subzero.IceStressCell">#</a> <b><u>Subzero.IceStressCell</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">IceStressCell{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Struct to collect stress from ice floes on ocean grid cells. One IceStressCell corresponds to one grid cell. It holds a list of running totals of stress on the cell, and a running list of the number of points making up those running totals. Each element in the list corresponds to one floe, which is denoted in the corresponding CellFloes matrix within the grid.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.IceStressCell-Union{Tuple{}, Tuple{FT}} where FT" href="#Subzero.IceStressCell-Union{Tuple{}, Tuple{FT}} where FT">#</a> <b><u>Subzero.IceStressCell</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IceStressCell{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Constructs an IceStressCell object with empty lists for fields.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.InitialStateOutputWriter" href="#Subzero.InitialStateOutputWriter">#</a> <b><u>Subzero.InitialStateOutputWriter</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">InitialStateOuputWriter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractOutputWriter</span></span></code></pre></div><p>Basic type of AbstractOutputWriter that records the intial state of the simulation. Writes JLD2 file with initial simulation state to the filepath specified. If overwrite is true, and there is a file of the given name at the filepath, that file will be overwritten.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.InitialStateOutputWriter-Tuple{InitialStateOutputWriter}" href="#Subzero.InitialStateOutputWriter-Tuple{InitialStateOutputWriter}">#</a> <b><u>Subzero.InitialStateOutputWriter</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">InitialStateOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(writer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">InitialStateOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates an initial state output writer from an existing writer, copying all fields unless new field values are explicity provided through keyword arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.InitialStateOutputWriter-Tuple{}" href="#Subzero.InitialStateOutputWriter-Tuple{}">#</a> <b><u>Subzero.InitialStateOutputWriter</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">InitialStateOutputWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    filename </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;initial_state.jld2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    overwrite </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    jld2_kw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict{Symbol, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates an initial state output writer. Inputs: dir &lt;String&gt; path to directory filename &lt;String&gt; filename to save file to overwrite &lt;Bool&gt; if true, exit file of the same name will be deleted, else an error will be thrown if other file exists jld2_kw list of JLD2 keywords for the jldopen function Outputs: Creates InitialStateOutputWriter that will write simulation&#39;s initial state.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.InteractionFields" href="#Subzero.InteractionFields">#</a> <b><u>Subzero.InteractionFields</u></b> — <i>Type</i>. <p>Enum to index into floe interactions field with more intuituve names</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Model" href="#Subzero.Model">#</a> <b><u>Subzero.Model</u></b> — <i>Type</i>. <p>Model which holds grid, ocean, atmos structs, each with the same underlying float type (either Float32 of Float64) and size. It also holds the domain information, which includes the topography and the boundaries. It holds a StructArray of floe structs, again each relying on the same underlying float type. Finally, it also holds the maximum floe id used thus far in the simulation. This should be the length of the floes array at the beginning of the run.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.MohrsCone" href="#Subzero.MohrsCone">#</a> <b><u>Subzero.MohrsCone</u></b> — <i>Type</i>. <p>MohrsCone{FT&lt;:AbstractFloat}&lt;:AbstractFractureCriteria</p><p>Type of AbstractFractureCriteria that creates a cone in principal stress space that determines if a floe fractures based off if its stress in principal stress space is inside or outside of the cone. Fields: verticies &lt;PolyVec&gt; vertices of criteria in principal stress space Note: Concepts from the following papter - Weiss, Jérôme, and Erland M. Schulson. &quot;Coulombic faulting from the grain scale to the geophysical scale: lessons from ice.&quot; Journal of Physics D: Applied Physics 42.21 (2009): 214017.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.MohrsCone-Tuple" href="#Subzero.MohrsCone-Tuple">#</a> <b><u>Subzero.MohrsCone</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MohrsCone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a type isn&#39;t specified, MohrsCone will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.MohrsCone-Union{Tuple, Tuple{FT}} where FT" href="#Subzero.MohrsCone-Union{Tuple, Tuple{FT}} where FT">#</a> <b><u>Subzero.MohrsCone</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MohrsCone{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calculate Mohr&#39;s Cone vertices given _calculate_mohrs arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.MohrsCone-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.MohrsCone-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.MohrsCone</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MohrsCone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any MohrsCone constructor. A MohrsCone of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.MonteCarloPointsGenerator" href="#Subzero.MonteCarloPointsGenerator">#</a> <b><u>Subzero.MonteCarloPointsGenerator</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MonteCarloPointsGenerator</span></span></code></pre></div><p>Subtype of AbstractSubFloePointsGenerator that defines parameters needed to generate a set of random monte carlo points within a given floe. <code>npoints</code> is the number of monte carlo points to generate within the floe&#39;s bounding box - the floe will not end up with this many points as all points outside of the floe will be removed. <code>ntries</code> is the number of tries to generate a set of points within the floe that have a smaller error than <code>err</code>.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.MonteCarloPointsGenerator-Tuple" href="#Subzero.MonteCarloPointsGenerator-Tuple">#</a> <b><u>Subzero.MonteCarloPointsGenerator</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MonteCarloPointsGenerator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If type isn&#39;t specified, MonteCarloPointsGenerator(; kwargs...) will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.MonteCarloPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.MonteCarloPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.MonteCarloPointsGenerator</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MonteCarloPointsGenerator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any MonteCarloPointsGenerator constructor. A MonteCarloPointsGenerato of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.MovingBoundary" href="#Subzero.MovingBoundary">#</a> <b><u>Subzero.MovingBoundary</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MovingBoundary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractBoundary</span></span></code></pre></div><p>A sub-type of AbstractBoundary that creates a floe along the boundary that moves towards the center of the domain at the given velocity, compressing the ice within the domain. This subtype is a mutable struct so that the coordinates and val can be changed as the boundary moves. The u and v velocities are in [m/s].</p><p>Note that with a u-velocity, east and west walls move towards the center of the domain, providing compressive stress, and with a v-velocity, the bounday creates a shear stress by incorporating the velocity into friction calculations but doesn&#39;t actually move. This means that the boundaries cannot move at an angle, distorting the shape of the domain regardless the the combination of u and v velocities. The same, but opposite is true for the north and south walls.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.MovingBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}" href="#Subzero.MovingBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}">#</a> <b><u>Subzero.MovingBoundary</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MovingBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{D}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any MovingBoundary constructor. The second argument D is the directional type of the boundary. A MovingBoundary of type FT and D will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.MovingBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection" href="#Subzero.MovingBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection">#</a> <b><u>Subzero.MovingBoundary</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MovingBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{D}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a float type isn&#39;t specified, MovingBoundary will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.MovingBoundary-Union{Tuple{FT}, Tuple{D}, Tuple{Any, Any, Any}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}" href="#Subzero.MovingBoundary-Union{Tuple{FT}, Tuple{D}, Tuple{Any, Any, Any}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}">#</a> <b><u>Subzero.MovingBoundary</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MovingBoundary{D, FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, velocity)</span></span></code></pre></div><p>Creates compression boundary on the edge of the grid, and with the direction as a type. Edge is determined by direction. Inputs: grid &lt;AbstractGrid&gt; model grid u &lt;AbstractFloat&gt; u velocity of boundary v &lt;AbstractFloat&gt; v velocity of boundary Outputs: MovingBoundary on edge of grid given by direction.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.NoFracture" href="#Subzero.NoFracture">#</a> <b><u>Subzero.NoFracture</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">NoFracture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFractureCriteria</span></span></code></pre></div><p>Simple AbstractFractureCriteria type representing when fracturing functionality is turned off. If this is the type provided to the simulation&#39;s FractureSettings then fractures will not occur.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.North" href="#Subzero.North">#</a> <b><u>Subzero.North</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">North</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractDirection</span></span></code></pre></div><p>A simple direction type representing if a boundary is the northern boundary in a rectangular domain.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Ocean" href="#Subzero.Ocean">#</a> <b><u>Subzero.Ocean</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Ocean{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Simulation ocean holding ocean values on the grid-scale with matricies of the same size as the model&#39;s grid. The struct has the following fields:</p><ul><li><p>u is the ocean velocities in the x-direction for each grid cell</p></li><li><p>v is the ocean velocities in the y-direction for each grid cell</p></li><li><p>temp is the ocean temperature for each grid cell</p></li><li><p>hflx_factor is a factor to calculate the ocean-atmosphere heat flux for a cell in that grid cell by multiplying by its height</p></li><li><p>si_frac is the fraction of area in each grid cell that is covered in sea-ice</p></li></ul><p>Ocean fields must all be matricies with dimensions equal to the number of grid lines in the model&#39;s grid. Note: If a periodic boundary is used in the domain, the last grid cell in that direction will not be used as it is equivalent to the first grid cell. Thus, for all of these fields, the first and last value in the x and/or y direction should be equal if the east-west or north-south boundary pair are periodic respectively.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Ocean-Tuple" href="#Subzero.Ocean-Tuple">#</a> <b><u>Subzero.Ocean</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Ocean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a type isn&#39;t specified, Ocean will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Ocean-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.Ocean-Union{Tuple{FT}, Tuple{AbstractGrid, Any, Any, Any}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.Ocean</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Ocean{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, u, v, temp)</span></span></code></pre></div><p>Construct model&#39;s ocean. Inputs: grid &lt;AbstractGrid&gt; model grid u &lt;Real&gt; ocean x-velocity for each grid line v &lt;Real&gt; ocean y-velocity for each grid line temp &lt;Real&gt; temperature at ocean/ice interface per grid cell Output: Ocean with constant velocity and temperature on each grid line.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Ocean-Union{Tuple{FT}, Tuple{Any, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.Ocean-Union{Tuple{FT}, Tuple{Any, Any, Any}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.Ocean</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Ocean{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u, v, temp)</span></span></code></pre></div><p>Construct model ocean. Inputs: u &lt;Matrix&gt; ocean x-velocity matrix with u for each grid line v &lt;Matrix&gt; ocean y-velocity matrix with u for each grid line temp &lt;Matrix&gt; temperature matrix with ocean/ice interface temperature for each grid line Output: Model ocean with given velocity and temperature fields on each grid line.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Ocean-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.Ocean-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.Ocean</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Ocean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any Ocean constructor. An Ocean of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.OpenBoundary" href="#Subzero.OpenBoundary">#</a> <b><u>Subzero.OpenBoundary</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">OpenBoundary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractBoundary</span></span></code></pre></div><p>A sub-type of AbstractBoundary that allows a floe to pass out of the domain edge without any effects on the floe.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.OpenBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}" href="#Subzero.OpenBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}">#</a> <b><u>Subzero.OpenBoundary</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpenBoundary{D, FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid)</span></span></code></pre></div><p>Creates open boundary on the edge of the grid, and with the direction as a type. Edge is determined by direction. Inputs: grid &lt;AbstractGrid&gt; model grid Outputs: Open Boundary on edge of grid given by direction and type.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.OpenBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}" href="#Subzero.OpenBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}">#</a> <b><u>Subzero.OpenBoundary</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpenBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{D}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any OpenBoundary constructor. The second argument D is the directional type of the boundary. An OpenBoundary of type FT and D will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.OpenBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection" href="#Subzero.OpenBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection">#</a> <b><u>Subzero.OpenBoundary</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpenBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{D}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a float type isn&#39;t specified, OpenBoundary will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.OutputWriters" href="#Subzero.OutputWriters">#</a> <b><u>Subzero.OutputWriters</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">OutputWriters{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Structure to hold all types of output writers a user might want. All fields are vectors so that more than one of each type of output writer can be defined, and so that a default OutputWriter object doesn&#39;t create default output writer fields, which would create files, but rather empty lists of output writers. If any of the fields is not provided, the default is just an empty list.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.PeriodicBoundary" href="#Subzero.PeriodicBoundary">#</a> <b><u>Subzero.PeriodicBoundary</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PeriodicBoundary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractBoundary</span></span></code></pre></div><p>A sub-type of AbstractBoundary that moves a floe from one side of the domain to the opposite side of the domain when it crosses the boundary, bringing the floe back into the domain.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.PeriodicBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}" href="#Subzero.PeriodicBoundary-Union{Tuple{Any}, Tuple{FT}, Tuple{D}} where {D&lt;:Subzero.AbstractDirection, FT&lt;:AbstractFloat}">#</a> <b><u>Subzero.PeriodicBoundary</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary{D, FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid)</span></span></code></pre></div><p>Creates periodic boundary on the edge of the grid, and with the direction as a type. Edge is determined by direction. Inputs: grid &lt;AbstractGrid&gt; model grid Outputs: Periodic Boundary on edge of grid given by direction and type.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}" href="#Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{FT}, Tuple{Type{FT}, Type{D}, Vararg{Any}}} where {FT&lt;:AbstractFloat, D&lt;:Subzero.AbstractDirection}">#</a> <b><u>Subzero.PeriodicBoundary</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{D}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any PeriodicBoundary constructor. The second argument D is the directional type of the boundary. A PeriodicBoundary of type FT and D will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection" href="#Subzero.PeriodicBoundary-Union{Tuple{D}, Tuple{Type{D}, Vararg{Any}}} where D&lt;:Subzero.AbstractDirection">#</a> <b><u>Subzero.PeriodicBoundary</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{D}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a float type isn&#39;t specified, PeriodicBoundary will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.PolyVec" href="#Subzero.PolyVec">#</a> <b><u>Subzero.PolyVec</u></b> — <i>Type</i>. <p>Coordinates are vector of vector of vector of points of the form: [[[x1, y1], [x2, y2], ..., [xn, yn], [x1, y1]], [[w1, z1], [w2, z2], ..., [wn, zn], [w1, z1]], ...] where the xy coordinates are the exterior border of the floe and the wz coordinates, or any other following sets of coordinates, describe holes within the floe. This form is for easy conversion to polygons.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.RegRectilinearGrid" href="#Subzero.RegRectilinearGrid">#</a> <b><u>Subzero.RegRectilinearGrid</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RegRectilinearGrid{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractGrid</span></span></code></pre></div><p>Tessellation of 2-dimensional Euclidean space into n-by-m congruent rectangles.</p><ul><li><p>Nx: number of grid cells in the x-direction</p></li><li><p>Ny: number of grid cells in the y-direction</p></li><li><p>x0: value of first x grid line</p></li><li><p>xf: value of final x grid line</p></li><li><p>y0: value of first y grid line</p></li><li><p>yf: value of final y grid line</p></li><li><p>Δx: grid cell width</p></li><li><p>Δy: grid cell height</p></li><li><p>floe_locations: matrix of CellFloes, which keep track of which floes are in each cell</p></li></ul><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.RegRectilinearGrid-Tuple" href="#Subzero.RegRectilinearGrid-Tuple">#</a> <b><u>Subzero.RegRectilinearGrid</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegRectilinearGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a type isn&#39;t specified, RegRectilinearGrid will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Int64, Int64, Tuple, Tuple}} where FT&lt;:AbstractFloat" href="#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Int64, Int64, Tuple, Tuple}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.RegRectilinearGrid</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegRectilinearGrid{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Nx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Ny,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xbounds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tuple{Real, Real}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ybounds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tuple{Real, Real}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {FT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Construct a RegRectilinearGrid for model given bounds for grid x and y and the number of grid cells in both the x and y direction. Inputs: Nx &lt;Int&gt; number of grid cells in the x-direction Ny &lt;Int&gt; number of grid cells in the y-direction xbounds &lt;Tuple{Real, Real}&gt; bound of grid x-direction in form (left, right) ybounds &lt;Tuple{Real, Real}&gt; bound of grid y-direction in form (bottom, top) Output: RegRectilinearGrid with width and height determined by xbound and ybounds and the number of grid cells in the x-direction and y-direction determined by dims.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Tuple, Tuple, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Tuple, Tuple, Any, Any}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.RegRectilinearGrid</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegRectilinearGrid{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xbounds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ybounds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δy,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Construct a RegRectilinearGrid for model given bounds for grid x and y and grid cell dimensions in meters. Inputs: xbounds &lt;Tuple{Real, Real}&gt; bound of grid x-direction in form (left, right) ybounds &lt;Tuple{Real, Real}&gt; bound of grid y-direction in form (bottom, top) Δx &lt;Real&gt; length/height of grid cells in x-direction Δy &lt;Real&gt; length/height of grid cells in y-direction Output: RegRectilinearGrid from lx to ux and height from ly to uy with grid squares of size Δx by Δy Warning: If Δx doesn&#39;t evenly divide x length (lu-lx) or Δy doesn&#39;t evenly divide y length (uy-ly) you won&#39;t get full size grid. The grid will be &quot;trimmed&quot; to the nearest full grid square in both directions.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.RegRectilinearGrid-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.RegRectilinearGrid</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegRectilinearGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any RegRectilinearGrid constructor. A RegRectilinearGrid of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.RidgeRaftSettings" href="#Subzero.RidgeRaftSettings">#</a> <b><u>Subzero.RidgeRaftSettings</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RidgeRaftSettings{FT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Settings needed for ridging and rafting within the model. The fields have the following meanings:</p><ul><li><p>ridge_raft_on: a boolean flag for if ridging and rafting should be turned on in the simulation</p></li><li><p>Δt: multiple of timesteps during which ridging and rafting code will run</p></li><li><p>ridge_probability: the probability a floe ridges with another floe/domain if it meets all other criteria</p></li><li><p>raft_probability: the probability a floe rafts with another floe/domain if it meets all other criteria</p></li><li><p>min_overlap_frac: the minimum overlap area fraction between a floe and another floe/domain for that floe to ridge or raft</p></li><li><p>min_ridge_height: the minimum floe height to ridge with a floe/domain</p></li><li><p>max_floe_ridge_height: the maximum floe height to ridge with another floe</p></li><li><p>max_domain_rdige_height: maximum floe height to ridge with a domain element</p></li><li><p>max_floe_raft_height: maximum floe height to raft with another floe</p></li><li><p>max_domain_raft_height: maximum floe height to raft with a domain element</p></li><li><p>domain_gain_probability: the probalility that a floe that rafts with a domain element keeps all of its mass (0) or if that mass is removed and lost to the domain element (1).</p></li></ul><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.RidgeRaftSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.RidgeRaftSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.RidgeRaftSettings</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RidgeRaftSettings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any RidgeRaftSettings constructor. A RidgeRaftSettings of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.RingVec" href="#Subzero.RingVec">#</a> <b><u>Subzero.RingVec</u></b> — <i>Type</i>. <p>Coordinates are vector of vector of points of the form: [[x1, y1], [x2, y2], ..., [xn, yn], [x1, y1]] where the xy coordinates form a closed ring. PolyVec objects can be made out RingVec objects. This form is for each conversion to LinearRings, which can also be made into Polygons.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.SimplificationSettings" href="#Subzero.SimplificationSettings">#</a> <b><u>Subzero.SimplificationSettings</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SimplificationSettings{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>If smooth_vertices_on is true then floe&#39;s with more vertices than max_vertices will be simplified every Δt_smooth timesteps. The tolerance is the Douglas–Peucker algorithm tolerance in (m).</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.SimplificationSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.SimplificationSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.SimplificationSettings</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimplificationSettings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any SimplificationSettings constructor. A SimplificationSettings of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.Simulation" href="#Subzero.Simulation">#</a> <b><u>Subzero.Simulation</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Simulation{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, DT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Domain{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Simulation which holds a model and parameters needed for running the simulation. This includes physical constants (consts), a random number generator (rng), the number of seconds in a timestep (Δt), and the number of timesteps to run (nΔt). We also have a flag for verbose, which will print out the number of timesteps every 50 timesteps and a simulation name, which can be used when saving files. The user can also define settings for each physical process.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.South" href="#Subzero.South">#</a> <b><u>Subzero.South</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">South</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractDirection</span></span></code></pre></div><p>A simple direction type representing if a boundary is the southern boundary in a rectangular domain.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.StatusTag" href="#Subzero.StatusTag">#</a> <b><u>Subzero.StatusTag</u></b> — <i>Type</i>. <p>Enum for differnt floe status</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.SubGridPointsGenerator" href="#Subzero.SubGridPointsGenerator">#</a> <b><u>Subzero.SubGridPointsGenerator</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SubGridPointsGenerator</span></span></code></pre></div><p>Subtype of AbstractSubFloePointsGenerator that defines parameters needed to generate a set of points on a &quot;subgrid&quot; within the floe where the subgrid is a regular rectilinar grid with cells of size <code>Δg</code> in both width and height. If two-way coupling, <code>Δg</code> should be smaller than the grid&#39;s Δx and Δy so that there is at least one point in each grid cell that the floe occupies.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.SubGridPointsGenerator-Tuple" href="#Subzero.SubGridPointsGenerator-Tuple">#</a> <b><u>Subzero.SubGridPointsGenerator</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SubGridPointsGenerator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If type isn&#39;t specified, SubGridPointsGenerator(; kwargs...) will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{RegRectilinearGrid, Int64}} where FT&lt;:AbstractFloat" href="#Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{RegRectilinearGrid, Int64}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.SubGridPointsGenerator</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SubGridPointsGenerator{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, npoint_per_cell)</span></span></code></pre></div><p>SubGridPointsGenerator constructor that uses the simulation grid and the desired number of sub-floe points per simulation grid cell to determine the correct value of Δg Inputs: grid &lt;RegRectilinearGrid&gt; simulation&#39;s grid npoint_per_cell &lt;Int&gt; number of points per grid cell, where the grid is redefined to have width and height equal to the minimum of Δx and Δy Output: SubGridPointsGenerator with Δg defined to be the minimum of Δx and Δy over the number of desired points per grid cell</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.SubGridPointsGenerator-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.SubGridPointsGenerator</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SubGridPointsGenerator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any SubGridPointsGenerator constructor. A SubGridPointsGenerator of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.SubzeroLogger" href="#Subzero.SubzeroLogger">#</a> <b><u>Subzero.SubzeroLogger</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SubzeroLogger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim; messages_per_tstep </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Created Subzero logger and writes log events to log file in current directory to file with the same name as the simulation&#39;s name field. Inputs: sim &lt;Simulation&gt; messages_per_tstep &lt;Int&gt; maximum number of times a given message should be written per timestep Outputs: Subzero logger that saves log to file with the same name as the simulation&#39;s name field and optional keyword arguments set.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.SubzeroLogger-2" href="#Subzero.SubzeroLogger-2">#</a> <b><u>Subzero.SubzeroLogger</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SubzeroLogger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim, messages_per_tstep </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Constructor from Subzero logger. Inputs: filename &lt;String&gt; file path to file to write log events into messages_per_tstep &lt;Int&gt; maximum number of times a given message should be written per timestep Outputs: Subzero logger that saves log to file with the same name as the simulation&#39;s name field and optional keyword arguments set.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.SubzeroLogger-3" href="#Subzero.SubzeroLogger-3">#</a> <b><u>Subzero.SubzeroLogger</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SubzeroLogger</span></span></code></pre></div><p>Logger for Subzero. Logs unique messages <code>messages_per_tstep</code> times per timestep to prevent overwhelming number of messages timesteps from multiple floes triggering the same log event. Fields:</p><ul><li><p>stream: ogs are written to this IO</p></li><li><p>min_level: minimum log event level to write</p></li><li><p>message_limits: dictionary with message IDs for key whose values are the number of times that message can still be written in current timestep - current timestep is stored in same dictionary under key &#39;tstep&#39;</p></li><li><p>messages_per_tstep: maximum number of times a given message should be written per timestep</p></li></ul><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.TopographyElement" href="#Subzero.TopographyElement">#</a> <b><u>Subzero.TopographyElement</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TopographyElement{FT}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractDomainElement{FT}</span></span></code></pre></div><p>Singular topographic element with coordinates field storing where the element is within the grid. These are used to create the desired topography within the simulation and will be treated as islands or coastline within the model in that they will not move or break due to floe interactions, but they will affect floes.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.TopographyElement-Tuple" href="#Subzero.TopographyElement-Tuple">#</a> <b><u>Subzero.TopographyElement</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TopographyElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a type isn&#39;t specified, TopographyElement will be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.TopographyElement-Union{Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.TopographyElement-Union{Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real}, Tuple{FT}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.TopographyElement</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TopographyElement{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coords)</span></span></code></pre></div><p>Constructor for topographic element with PolyVec coordinates Inputs: coords &lt;PolyVec&gt; Output: Topographic element of abstract float type FT</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.TopographyElement-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat" href="#Subzero.TopographyElement-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.TopographyElement</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TopographyElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any TopographyElement constructor. A TopographyElement of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.TopographyElement-Union{Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.TopographyElement-Union{Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat}, Tuple{FT}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.TopographyElement</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TopographyElement{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(poly)</span></span></code></pre></div><p>Constructor for topographic element with Polygon Inputs: poly &lt;Polygon&gt; Output: Topographic element of abstract float type FT</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.WeldSettings" href="#Subzero.WeldSettings">#</a> <b><u>Subzero.WeldSettings</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WeldSettings{FT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Settings needed for welding within the model. The fields have the following meanings:</p><ul><li><p>weld_on: a boolean flag for if welding should be turned on in the simulation</p></li><li><p>Δts: a list of multiples of timesteps during which welding code will run, welding will be run at multiples of all elements, each with domain split into corresponding Nx and Ny values</p></li><li><p>Nxs: a list of number of x-directional bins to split the domain into at corresponding timesteps</p></li><li><p>Nys: a list of number of x-directional bins to split the domain into at corresponding timesteps</p></li><li><p>min_weld_area: minimum area a weld can create for two floes to weld</p></li><li><p>max_weld_area: maximum area a weld can create for two floes to weld</p></li><li><p>welding_coeff: non-dimensional parameter, multiplied by ratio of overlap between two floes to original floe area to determin probability that a floe will merge. The larger this is, the more likely floes are to weld. Probability with 5% overlap is <code>welding_coeff * (0.05) &amp;gt; rand()</code></p></li></ul><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.WeldSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.WeldSettings-Union{Tuple{Type{FT}}, Tuple{FT}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.WeldSettings</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WeldSettings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of any WeldSettings constructor. A WeldSettings of type FT will be created by passing all other arguments to the correct constructor.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.West" href="#Subzero.West">#</a> <b><u>Subzero.West</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">West</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractDirection</span></span></code></pre></div><p>A simple direction type representing if a boundary is the western boundary in a rectangular domain.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Base.::-Tuple{InteractionFields, InteractionFields}" href="#Base.::-Tuple{InteractionFields, InteractionFields}">#</a> <b><u>Base.::</u></b> — <i>Method</i>. <p>Create a range of interactions field columns with InteractionFields enum objects</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Base.empty!-Tuple{CellFloes}" href="#Base.empty!-Tuple{CellFloes}">#</a> <b><u>Base.empty!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">empty!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cell</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CellFloes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Empties the vectors within a CellFloes object</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Base.empty!-Tuple{IceStressCell}" href="#Base.empty!-Tuple{IceStressCell}">#</a> <b><u>Base.empty!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">empty!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cell</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IceStressCell</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Empties the vectors within an IceStressCell</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Base.to_index-Tuple{InteractionFields}" href="#Base.to_index-Tuple{InteractionFields}">#</a> <b><u>Base.to_index</u></b> — <i>Method</i>. <p>Index into interactions field with InteractionFields enum objects</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Logging.handle_message-Tuple{Subzero.SubzeroLogger, Vararg{Any, 7}}" href="#Logging.handle_message-Tuple{Subzero.SubzeroLogger, Vararg{Any, 7}}">#</a> <b><u>Logging.handle_message</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">handle_message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    logger</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SubzeroLogger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    level,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    message,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    _module,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    group,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    id,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    filepath,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    line;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    tstep </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Function that determines if log event should be written to file depending on how many times that event has been written to file in current timestep.</p><p>Note: This is called when a log macro is called (e.g. @warn), not explicitly by the user. Additionally, it is not threadsafe so a message may be written more times than <code>messages_per_tstep</code>, but it should be in the ballpark. Putting a lock would slow down logging and isn&#39;t worth it given that this problem only records a few extra log events.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero._calculate_hibler-Union{Tuple{FT}, Tuple{Type{FT}, Any, Any, Any}} where FT" href="#Subzero._calculate_hibler-Union{Tuple{FT}, Tuple{Type{FT}, Any, Any, Any}} where FT">#</a> <b><u>Subzero._calculate_hibler</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_calculate_hibler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(FT, floes, pstar, c)</span></span></code></pre></div><p>Calculate Hibler&#39;s Elliptical Yield Curve as described in his 1979 paper &quot;A Dynamic Thermodynamic Sea Ice Model&quot;. Inputs: floes &lt;StructArray{Floes}&gt; model&#39;s list of floes pstar &lt;AbstractFloat&gt; used to tune ellipse for optimal fracturing c &lt;AbstractFloat&gt; used to tune ellipse for optimal fracturing Outputs: vertices &lt;PolyVec{AbstractFloat}&gt; vertices of elliptical yield curve Note: Hibler&#39;s paper says that: Both pstar and c relate the ice strength to the ice thickness and compactness. c is determined to that 10% open water reduces the strength substantially and pstar is considered a free parameter.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero._calculate_mohrs-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 4}}} where FT" href="#Subzero._calculate_mohrs-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 4}}} where FT">#</a> <b><u>Subzero._calculate_mohrs</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_calculate_mohrs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(FT, σ1, σ2, σ11, σ22)</span></span></code></pre></div><p>Creates PolyVec from vertex values for Mohr&#39;s Cone (triangle in 2D) Inputs: σ1 &lt;AbstractFloat&gt; x-coordiante of first point in cone σ2 &lt;AbstractFloat&gt; y-coordiante of first point in cone σ11 &lt;AbstractFloat&gt; x-coordinate of one vertex of cone and negative of the y-coordinate of adjacend vertex in principal stress space σ22 &lt;AbstractFloat&gt; y-coordinate of one vertex of cone and negative of the x-coordinate of adjacend vertex in principal stress space Output: Mohr&#39;s Cone vertices (triangle since we are in 2D) in principal stress space</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero._calculate_mohrs-Union{Tuple{Type{FT}}, Tuple{FT}, Tuple{Type{FT}, Any}, Tuple{Type{FT}, Any, Any}, Tuple{Type{FT}, Any, Any, Any}} where FT" href="#Subzero._calculate_mohrs-Union{Tuple{Type{FT}}, Tuple{FT}, Tuple{Type{FT}, Any}, Tuple{Type{FT}, Any, Any}, Tuple{Type{FT}, Any, Any, Any}} where FT">#</a> <b><u>Subzero._calculate_mohrs</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_calculate_mohrs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    FT,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    q,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    σc,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    σ11;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    σ1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    σ2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    σ22 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calculate Mohr&#39;s Cone coordinates in principal stress space. Inputs: q &lt;AbstractFloat&gt; based on the coefficient of internal friction (µi) by ((μi^2 + 1)^(1/2) + μi^2 σc &lt;AbstractFloat&gt; uniaxial compressive strength σ11 &lt;AbstractFloat&gt; negative of the x-coordinate of one vertex of cone (triangle in 2D) and negative of the y-coordinate of adjacend vertex in principal stress space Outputs: Mohr&#39;s Cone vertices (triangle since we are in 2D) in principal stress space Note: Concepts from the following papter - Weiss, Jérôme, and Erland M. Schulson. &quot;Coulombic faulting from the grain scale to the geophysical scale: lessons from ice.&quot; Journal of Physics D: Applied Physics 42.21 (2009): 214017. Equations taken from original version of Subzero written in MATLAB</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero._initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Vararg{Any, 4}}} where FT&lt;:AbstractFloat" href="#Subzero._initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Vararg{Any, 4}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero._initialize_floe_field</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_initialize_floe_field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nfloes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    concentrations,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hmean,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δh;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a field of floes using Voronoi Tesselation. Inputs: Type{FT} &lt;AbstractFloat&gt; Type for grid&#39;s numberical fields - determines simulation run type nfloes &lt;Int&gt; number of floes to try to create - note you might not end up with this number of floes - topography in domain and multiple concentrations can decrease number of floes created concentrations &lt;Matrix&gt; matrix of concentrations to fill domain. If size(concentrations) = N, M then split the domain into NxM cells, each to be filled with the corresponding concentration. If concentration is below 0, it will default to 0. If it is above 1, it will default to 1 domain &lt;Domain&gt; model domain hmean &lt;Float&gt; average floe height Δh &lt;Float&gt; height range - floes will range in height from hmean - Δh to hmean + Δh floe_bounds &lt;PolyVec&gt; coordinates of boundary within which to populate floes. This can be smaller that the domain, but will be limited to open space within the domain floe_settings &lt;FloeSettings&gt; settings needed to initialize floes rng &lt;RNG&gt; random number generator to generate random floe attributes - default uses Xoshiro256++ Output: floe_arr &lt;StructArray&gt; list of floes created using Voronoi Tesselation of the domain with given concentrations.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero._initialize_floe_field-Union{Tuple{V}, Tuple{FT}, Tuple{Type{FT}, V, Any, Any, Any}} where {FT&lt;:AbstractFloat, V&lt;:(AbstractVector)}" href="#Subzero._initialize_floe_field-Union{Tuple{V}, Tuple{FT}, Tuple{Type{FT}, V, Any, Any, Any}} where {FT&lt;:AbstractFloat, V&lt;:(AbstractVector)}">#</a> <b><u>Subzero._initialize_floe_field</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_initialize_floe_field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    coords,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hmean,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δh;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a field of floes from a list of polygon coordiantes. User is wanrned if floe&#39;s do not meet minimum size requirment. Inputs: Type{FT} &lt;AbstractFloat&gt; Type for grid&#39;s numberical fields - determines simulation run type coords &lt;Vector{PolyVec}&gt; list of polygon coords to make into floes domain &lt;Domain&gt; model domain hmean &lt;Float&gt; average floe height Δh &lt;Float&gt; height range - floes will range in height from hmean ± Δh floe_settings &lt;FloeSettings&gt; settings needed to initialize floes rng &lt;RNG&gt; random number generator to generate random floe attributes - default uses Xoshiro256++ algorithm Output: floe_arr &lt;StructArray{Floe}&gt; list of floes created from given polygon coordinates</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.add_floe_ghosts!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}" href="#Subzero.add_floe_ghosts!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}">#</a> <b><u>Subzero.add_floe_ghosts!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_floe_ghosts!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(floes, max_boundary, min_boundary)</span></span></code></pre></div><p>Add ghosts of all of the given floes passing through the two given boundaries to the list of floes. Inputs: floes &lt;StructArray{Floe{FT}}&gt; list of floes to find ghosts for max_boundary &lt;PeriodicBoundary&gt; northern or eastern boundary of domain min_boundary &lt;PeriodicBoundary&gt; southern or western boundary of domain Outputs: None. Ghosts of floes are added to floe list.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.add_floe_volume!-NTuple{4, Any}" href="#Subzero.add_floe_volume!-NTuple{4, Any}">#</a> <b><u>Subzero.add_floe_volume!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_floe_volume!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    idx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vol,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Add volume to existing floe and update fields that depend on the volume. Inputs: floes &lt;StructArray{Frloe}&gt; list of floes idx &lt;Int&gt; index of floe to add volume to vol &lt;AbstractFloat&gt; volume to add to floe floe_settings &lt;FloeSettings&gt; simulation&#39;s settings for making floes Outputs: Nothing. Floe&#39;s fields are updated to reflect increase in volume.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:PeriodicBoundary, var&quot;#s86&quot;&lt;:PeriodicBoundary, var&quot;#s85&quot;&lt;:PeriodicBoundary, var&quot;#s84&quot;&lt;:PeriodicBoundary, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat" href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:PeriodicBoundary, var&quot;#s86&quot;&lt;:PeriodicBoundary, var&quot;#s85&quot;&lt;:PeriodicBoundary, var&quot;#s84&quot;&lt;:PeriodicBoundary, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.add_ghosts!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_ghosts!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    elems,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Add ghosts for elements that pass through any of the boundaries. Inputs: elems &lt;StructArray{Floe} or StructArray{TopographyElement}&gt; list of elements to add ghosts to domain &lt;Domain{ AbstractFloat, PeriodicBoundary, PeriodicBoundary, PeriodicBoundary, PeriodicBoundary, }&gt; domain with all boundaries Outputs: None. Ghosts are added to list of elements.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:PeriodicBoundary, var&quot;#s86&quot;&lt;:PeriodicBoundary, var&quot;#s85&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s84&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat" href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:PeriodicBoundary, var&quot;#s86&quot;&lt;:PeriodicBoundary, var&quot;#s85&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s84&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.add_ghosts!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_ghosts!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    elems,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Add ghosts for elements that pass through the northern or southern boundaries. Inputs: elems &lt;StructArray{Floe} or StructArray{TopographyElement}&gt; list of elements to add ghosts to domain &lt;Domain{ Float, PeriodicBoundary, PeriodicBoundary, NonPeriodicBoundary, NonPeriodicBoundary, }&gt; domain with northern and southern periodic boundaries Outputs: None. Ghosts are added to list of elements.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s86&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s85&quot;&lt;:PeriodicBoundary, var&quot;#s84&quot;&lt;:PeriodicBoundary, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat" href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s86&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s85&quot;&lt;:PeriodicBoundary, var&quot;#s84&quot;&lt;:PeriodicBoundary, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.add_ghosts!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_ghosts!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    elems,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Add ghosts for elements that pass through the eastern or western boundaries. Inputs: elems &lt;StructArray{Floe} or StructArray{TopographyElement}&gt; list of elements to add ghosts to domain &lt;Domain{ Float, NonPeriodicBoundary, NonPeriodicBoundary, PeriodicBoundary, PeriodicBoundary, }&gt; domain with eastern and western periodic boundaries Outputs: None. Ghosts are added to list of elements.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s86&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s85&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s84&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat" href="#Subzero.add_ghosts!-Union{Tuple{FT}, Tuple{Any, Domain{FT, var&quot;#s87&quot;, var&quot;#s86&quot;, var&quot;#s85&quot;, var&quot;#s84&quot;, TT} where {var&quot;#s87&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s86&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s85&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, var&quot;#s84&quot;&lt;:Union{CollisionBoundary, MovingBoundary, OpenBoundary}, TT&lt;:(StructArrays.StructArray{&lt;:TopographyElement{FT}})}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.add_ghosts!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_ghosts!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    elems,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>When there are no periodic boundaries, no ghosts should be added. Inputs: None are used. Outputs: None.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.add_point!-Tuple{CellFloes, Any, Any, Any}" href="#Subzero.add_point!-Tuple{CellFloes, Any, Any, Any}">#</a> <b><u>Subzero.add_point!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_point!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cfloes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CellFloes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floeidx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δy,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Add floe to CellFloes list of floes within that grid cell and aggragate the stress caused by monte carlo point in floe into IceStressCell object. Inputs: cfloes &lt;CellFloes&gt; CellFloes object representing one grid cell (centered on model&#39;s grid lines) floeidx &lt;Int&gt; floe index within model&#39;s list of floes Δx &lt;AbstractFloat&gt; x-translation to move floe from current position into given grid cell if shifted due to periodic boundaries Δy &lt;AbstractFloat&gt; y-translation to move floe from current position into given grid cell if shifted due to periodic boundaries Outputs: None. Add information to both cfloes to record where floe is on model grid.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.add_point!-Tuple{CellFloes, IceStressCell, Vararg{Any, 5}}" href="#Subzero.add_point!-Tuple{CellFloes, IceStressCell, Vararg{Any, 5}}">#</a> <b><u>Subzero.add_point!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_point!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cfloes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CellFloes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    scell</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IceStressCell</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floeidx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    τx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    τy,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δy,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Add floe to CellFloes list of floes within that grid cell and aggragate the stress caused by monte carlo point in floe into IceStressCell object. Inputs: cfloes &lt;CellFloes&gt; CellFloes object representing one grid cell (centered on model&#39;s grid lines) scell &lt;IceStressCell&gt; IceStressCell aggragating stresses from floes within grid cell from each floes&#39; monte carlo points floeidx &lt;Int&gt; floe index within model&#39;s list of floes τx &lt;AbstractFloat&gt; x-directional stress from monte carlo point on ocean τy &lt;AbstractFloat&gt; y-directional stress from monte carlo point on ocean Δx &lt;AbstractFloat&gt; x-translation to move floe from current position into given grid cell if shifted due to periodic boundaries Δy &lt;AbstractFloat&gt; y-translation to move floe from current position into given grid cell if shifted due to periodic boundaries Outputs: None. Add information to both cfloes and scell to aggregate stress on ocean grid cell and record where floe is on model grid.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.auto_extension-Tuple{Any, Any}" href="#Subzero.auto_extension-Tuple{Any, Any}">#</a> <b><u>Subzero.auto_extension</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">auto_extension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filename, ext)</span></span></code></pre></div><p>If <code>filename</code> ends in <code>ext</code>, return <code>filename</code>. Otherwise return <code>filename * ext</code>.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.bin_floe_centroids-NTuple{5, Any}" href="#Subzero.bin_floe_centroids-NTuple{5, Any}">#</a> <b><u>Subzero.bin_floe_centroids</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bin_floe_centroids</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(floes, grid, domain, Nx, Ny)</span></span></code></pre></div><p>Split floe locations into a grid of Nx by Ny by floe centroid location Inputs: floes &lt;StructArray{Floe}&gt; simulation&#39;s list of floes grid &lt;RegRectilinearGrid&gt; simulation&#39;s grid domain &lt;Domain&gt; simulation&#39;s domain Nx &lt;Int&gt; number of grid cells in the x-direction to split domain into for welding groups Ny &lt;Int&gt; number of grid cells in the y-direction to split domain into for welding groups Outputs: floe_bins &lt;Matrix{Vector{Int}}&gt; Nx by Ny matrix where each element is a list of floe indices whose centroids are in the corresponding section of the grid. May also have elements of value 0 if there are less than average number of floes in the section. nfloes &lt;Maxtrix{Int}&gt; Nx by Ny matrix where each element is the total number of indices within floe_bins[Nx, Ny] that are non-zeros and represent a floe within the grid section.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.boundary_coords-Tuple{Any, Type{East}}" href="#Subzero.boundary_coords-Tuple{Any, Type{East}}">#</a> <b><u>Subzero.boundary_coords</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">boundary_coords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{East}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Determine coordinates of eastern-most boundary of domain if around the edge of the grid. Inputs: grid &lt;AbstractGrid&gt; model grid &lt;Type{East}&gt; boundary direction type Output: PolyVec of boundary coordinates. See documentation of North method of this function for more details.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.boundary_coords-Tuple{Any, Type{North}}" href="#Subzero.boundary_coords-Tuple{Any, Type{North}}">#</a> <b><u>Subzero.boundary_coords</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">boundary_coords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{North}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Determine coordinates of northen-most boundary of domain if around the edge of the grid. Inputs: grid &lt;AbstractGrid&gt; model grid &lt;Type{North}&gt; boundary direction type Output: PolyVec of boundary coordinates. These coordinates describe a rectangle that has a length 2-times the length of the grid in the x-direction, centered on the grid so that there is a buffer of half of the grid on either side. The height is half of the grid in the y-direction. This buffer prevents pieces of floes from passing outside the boundary before the next timestep - possibly too cautious. If boundary_coords methods are used for each direction, corners will be shared between adjacent boundaries.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.boundary_coords-Tuple{Any, Type{South}}" href="#Subzero.boundary_coords-Tuple{Any, Type{South}}">#</a> <b><u>Subzero.boundary_coords</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">boundary_coords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{South}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Determine coordinates of southern-most boundary of domain if around the edge of the grid. Inputs: grid &lt;AbstractGrid&gt; model grid &lt;Type{South}&gt; boundary direction type Output: PolyVec of boundary coordinates. See documentation of North method of this function for more details.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.boundary_coords-Tuple{Any, Type{West}}" href="#Subzero.boundary_coords-Tuple{Any, Type{West}}">#</a> <b><u>Subzero.boundary_coords</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">boundary_coords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{West}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Determine coordinates of western-most boundary of domain if around the edge of the grid. Inputs: grid &lt;AbstractGrid&gt; model grid &lt;Type{West}&gt; boundary direction Output: PolyVec of boundary coordinates. See documentation of North method of this function for more details.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_angular_momentum-NTuple{7, Any}" href="#Subzero.calc_angular_momentum-NTuple{7, Any}">#</a> <b><u>Subzero.calc_angular_momentum</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_angular_momentum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u, v, mass, ξ, moment, x, y)</span></span></code></pre></div><p>Calculates angular momentum for one timestep given the floe&#39;s velocities, mass, moment of intertia, and centroid position. Inputs: u &lt;Vector{Real}&gt; list of floes&#39; u velocities v &lt;Vector{Real}&gt; list of floes&#39; v velocities mass &lt;Vector{Real}&gt; list of floes&#39; masses ξ &lt;Vector{Real}&gt; list of floes&#39; angular velocities moment &lt;Vector{Real}&gt; list of floes&#39; moments of intertia x &lt;Vector{Real}&gt; list of floes&#39; centroid x-value y &lt;Vector{Real}&gt; list of floes&#39; centroid y-value Outputs: &lt;Real&gt; total spin angular momentum from the floes &lt;Real&gt; total orbital angular momentum from the floes</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_atmosphere_forcing-NTuple{7, Any}" href="#Subzero.calc_atmosphere_forcing-NTuple{7, Any}">#</a> <b><u>Subzero.calc_atmosphere_forcing</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_atmosphere_forcing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mc_xr, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mc_yr,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    upoint,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vpoint,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    uatm_interp,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vatm_interp,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calculates the stresses on a floe from the atmosphere above at given monte carlo point. Inputs: mc_xr &lt;AbstractFloat&gt; monte carlo point x-coordinate mc_yr &lt;AbstractFloat&gt; monte carlo point y-coordinate upoint &lt;AbstractFloat&gt; u velocity of floe at monte carlo point vpoint &lt;AbstractFloat&gt; v velocity of floe at monte carlo point uatm_interp &lt;Interplations object&gt; linear interpolation function from Interpolations.jl that takes in two arguments (x, y) and interpolates the atompshere u velocity onto point vatm_interp &lt;Interplations object&gt; linear interpolation function from Interpolations.jl that takes in two arguments (x, y) and interpolates the atompshere v velocity onto point c &lt;Constants&gt; simulation&#39;s constants Outputs: τx_atm &lt;AbstractFloat&gt; stress from atmosphere on floe in x-direction at given monte carlo point τy_atm &lt;AbstractFloat&gt; stress from atmosphere on floe in y-direction at given monte carlo point</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_elastic_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat" href="#Subzero.calc_elastic_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.calc_elastic_forces</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_elastic_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    p1,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    p2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    regions,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    region_areas,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    force_factor,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    consts,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calculate normal forces, the point the force is applied, and the overlap area of regions created from floe collisions Inputs: p1 &lt;Polygon&gt; first floe&#39;s polygon in collision p2 &lt;Polygon&gt; second floe&#39;s polygon in collision regions &lt;Vector{Polygon}&gt; polygon regions of overlap during collision region_areas &lt;Vector{Float}&gt; area of each polygon in regions force_factor &lt;Float&gt; Spring constant equivalent for collisions Outputs: force &lt;Array{Float, n, 2}&gt; normal forces on each of the n regions greater than a minimum area fpoint &lt;Array{Float, n, 2}&gt; point force is applied on each of the n regions greater than a minimum area overlap &lt;Array{Float, n, 2}&gt; area of each of the n regions greater than a minimum area Δl &lt;Float&gt; mean length of distance between intersection points</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_eulerian_data!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}" href="#Subzero.calc_eulerian_data!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}">#</a> <b><u>Subzero.calc_eulerian_data!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_eulerian_data!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(floes, topography, writer, istep)</span></span></code></pre></div><p>Calculate floe data averaged on grid defined by GridOutputWriter for current timestep (istep). Inputs: floes &lt;StructArray{Floe}&gt; array of model&#39;s floes topography &lt;StructArray{Topography} array of model&#39;s topography writer &lt;GridOutputWriter&gt; istep &lt;Int&gt; current simulation timestep Output: Floe data averaged on eularian grid provided and saved in writer.data field</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_friction_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Matrix{FT}, Any, Any, Any}} where FT" href="#Subzero.calc_friction_forces-Union{Tuple{FT}, Tuple{Any, Any, Any, Matrix{FT}, Any, Any, Any}} where FT">#</a> <b><u>Subzero.calc_friction_forces</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_friction_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ifloe,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    jfloe,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fpoints,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    normal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Matrix{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δl,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    consts,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calculate frictional force for collision between two floes or a floe and a domain element. Input: ifloe &lt;Floe&gt; first floe in collsion jfloe &lt;Union{Floe, DomainElement}&gt; either second floe or topography element/boundary element fpoints &lt;Array{Float, N, 2}&gt; x,y-coordinates of the point the force is applied on floe overlap region normal &lt;Array{Float, N, 2}&gt; x,y normal force applied on fpoint on floe overlap region Δl &lt;Vector&gt; mean length of distance between intersection points consts &lt;Constants&gt; model constants needed for calculations Δt &lt;AbstractFloat&gt; simulation&#39;s timestep Outputs: force &lt;Array{Float, N, 2}&gt; frictional/tangential force of the collision in x and y (each row) for each collision (each column)</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_kinetic_energy-NTuple{5, Any}" href="#Subzero.calc_kinetic_energy-NTuple{5, Any}">#</a> <b><u>Subzero.calc_kinetic_energy</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_total_energy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u, v, mass, ξ, moment)</span></span></code></pre></div><p>Calculates linear and rotational energy for one timestep given the floe&#39;s velocities, mass, and moment of intertia. Inputs: u &lt;Vector{Real}&gt; list of floes&#39; u velocities v &lt;Vector{Real}&gt; list of floes&#39; v velocities mass &lt;Vector{Real}&gt; list of floes&#39; masses ξ &lt;Vector{Real}&gt; list of floes&#39; angular velocities moment &lt;Vector{Real}&gt; list of floes&#39; moments of intertia Outputs: linear &lt;Real&gt; total linear kinetic energy generated by the floes rotational &lt;Real&gt; total rotational kinetic energy generated by the floes</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_linear_momentum-Tuple{Any, Any, Any}" href="#Subzero.calc_linear_momentum-Tuple{Any, Any, Any}">#</a> <b><u>Subzero.calc_linear_momentum</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_linear_momentum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u, v, mass)</span></span></code></pre></div><p>Calculates linear momentum for one timestep given the floe&#39;s velocities and mass. Inputs: u &lt;Vector{Real}&gt; list of floes&#39; u velocities v &lt;Vector{Real}&gt; list of floes&#39; v velocities mass &lt;Vector{Real}&gt; list of floes&#39; masses Outputs: &lt;Real&gt; total linear momentum in the x-direction from floes &lt;Real&gt; total linear momentum in the y-direction from floes</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_normal_force-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat" href="#Subzero.calc_normal_force-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.calc_normal_force</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_normal_force</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c1,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    region,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    area,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ipoints,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    force_factor,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calculate normal force for collision between polygons p1 and p2 given an overlapping region, the area of that region, their intersection points in the region, and a force factor. Inputs: p1 &lt;Polys&gt; first polygon p2 &lt;Polys&gt; second polygon region &lt;PolyVec{Float64}&gt; coordiantes for one region of intersection between the polygons area &lt;Float&gt; area of region ipoints &lt;Vector{Tuple{Float, Float} or Vector{Vector{Float}}}&gt; Points of intersection between polygon 1 and 2 force_factor &lt;Float&gt; Spring constant equivalent for collisions Outputs: &lt;Float&gt; normal force of collision Δl &lt;Float&gt; mean length of distance between intersection points</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_ocean_forcing!-NTuple{9, Any}" href="#Subzero.calc_ocean_forcing!-NTuple{9, Any}">#</a> <b><u>Subzero.calc_ocean_forcing!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_ocean_forcing!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mc_xr,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mc_yr,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    upoint,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vpoint,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    uocn_interp,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vocn_interp,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hflx_interp,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ma_ratio,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calculates the stresses on a floe from the ocean above at given monte carlo point. Inputs: mc_xr &lt;AbstractFloat&gt; monte carlo point x-coordinate mc_yr &lt;AbstractFloat&gt; monte carlo point y-coordinate upoint &lt;AbstractFloat&gt; u velocity of floe at monte carlo point vpoint &lt;AbstractFloat&gt; v velocity of floe at monte carlo point uocn_interp &lt;Interplations object&gt; linear interpolation function from Interpolations.jl that takes in two arguments (x, y) and interpolates the ocean u velocity onto point vocn_interp &lt;Interplations object&gt; linear interpolation function from Interpolations.jl that takes in two arguments (x, y) and interpolates the ocean v velocity onto point hflx_interp &lt;Interplations object&gt; linear interpolation function from Interpolations.jl that takes in two arguments (x, y) and interpolates the ocean heatflux factor velocity onto point ma_ratio &lt;AbstractFloat&gt; floe&#39;s mass to area ratio c &lt;Constants&gt; simulation&#39;s constants Outputs: τx_ocn &lt;AbstractFloat&gt; stress from ocean velocity on floe in x-direction at given monte carlo point τy_ocn &lt;AbstractFloat&gt; stress from ocean velocity on floe in y-direction at given monte carlo point τx_pressure∇ &lt;AbstractFloat&gt; stress from ocean pressure gradient on floe in x-direction at given monte carlo point τy_pressure∇ &lt;AbstractFloat&gt; stress from ocean pressure gradient on floe in y-direction at given monte carlo point hflx_factor &lt;AbstractFloat&gt; heatflux factor at given monte carlo point from the heatflux factors of ocean below floe</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_one_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT" href="#Subzero.calc_one_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT">#</a> <b><u>Subzero.calc_one_way_coupling!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_one_way_coupling!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StructArray{Floe{FT}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    atmos,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ocean,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    coupling_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    consts,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Preforms calculations needed for one way coupling by calculating floe&#39;s forcings from ocean and atmosphere as well as the heatflux below a given floe.</p><p>Floe location on grid is also recorded. If two-way coupling is on, total stress on each grid cell per-floe in grid cell is also recorded for use in calc_two_way_coupling! Inputs: floes &lt;StructArray{Floe{FT}}&gt; model&#39;s floe list grid &lt;AbstractGrid&gt; model&#39;s grid atmos &lt;Ocean&gt; model&#39;s atmosphere ocean &lt;Ocean&gt; model&#39;s ocean domain &lt;Domain&gt; model&#39;s domain coupling_settings &lt;CouplingSettings&gt; simulation coupling settings consts &lt;Constants&gt; simulation&#39;s constants Ouputs: None. Update each floe&#39;s forces, torque, and heatflux factor from ocean/atmosphere. Determine location of floe within grid and if two-way coupling in enabled, save floe stress on grid.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_strain!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}}, Tuple{FT}} where FT" href="#Subzero.calc_strain!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}}, Tuple{FT}} where FT">#</a> <b><u>Subzero.calc_strain!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_strain!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coords, centroid, u, v, ξ, area)</span></span></code></pre></div><p>Calculates the strain on a floe given the velocity at each vertex Inputs: floe &lt;Floe{AbstractFloat}&gt; a floe Outputs: strain &lt;Matrix{AbstractFloat}&gt; 2x2 matrix for floe strain</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_stress!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Any, Any}} where FT" href="#Subzero.calc_stress!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Any, Any}} where FT">#</a> <b><u>Subzero.calc_stress!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_stress!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(floe)</span></span></code></pre></div><p>Calculates the stress on a floe for current collisions given interactions and floe properties. Inputs: floe &lt;Union{LazyRow{Floe{AbstractFloat}}, Floe{AbstractFloat}&gt; properties of floe floe_settings &lt;FloeSettings{AbstractFloat}&gt; Settings to create floes within model Δt &lt;AbstractFloat&gt; Simulation timestep in seconds Outputs: Does not return anything, but updates floe.stress_accum and floe.stress_instant</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_subfloe_values!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat" href="#Subzero.calc_subfloe_values!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.calc_subfloe_values!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_subfloe_values!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Floe{FT}, LazyRow{Floe{FT}}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mc_cart,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mc_grid_idx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calculates subfloe point&#39;s cartesian coordiantes, polar coordiantes, velocity and index within the grid. Inputs: floe &lt;Union{Floe{AbstractFloat}, LazyRow{Floe{AbstractFloat}}}&gt; floe grid &lt;AbstractGrid&gt; model&#39;s grid domain &lt;Domain&gt; model&#39;s domain mc_cart &lt;Matrix{AbstractFloat}&gt; pre-allocated nx2 matrix for floe&#39;s monte carlo point&#39;s cartesian coordinates where the first column is x and second is y mc_grid_idx &lt;Matrix{AbstractFloat}&gt; pre-allocated nx2 matrix for floe&#39;s monte carlo point&#39;s grid indices where the first column is the column and the second is the row that the point is in on the grid split into cells centered on grid lines. Outputs: j &lt;Int&gt; last element in mc_cart and mc_grid_idx that holds monte carlo point information for given floe. mc_cart and mc_grid_idx filled with data for given floe&#39;s monte carlo points up to row j.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_torque!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{&lt;:Floe{FT}}}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.calc_torque!-Union{Tuple{Union{Floe{FT}, StructArrays.LazyRow{&lt;:Floe{FT}}}}, Tuple{FT}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.calc_torque!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_torque!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(floe)</span></span></code></pre></div><p>Calculate a floe&#39;s torque based on the interactions. Inputs: floe &lt;Floe&gt; floe in model Outputs: None. Floe&#39;s interactions field is updated with calculated torque.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.calc_two_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, RegRectilinearGrid, Vararg{Any, 6}}} where FT" href="#Subzero.calc_two_way_coupling!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, RegRectilinearGrid, Vararg{Any, 6}}} where FT">#</a> <b><u>Subzero.calc_two_way_coupling!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc_two_way_coupling!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StructArray{Floe{FT}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegRectilinearGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    atmos,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ocean,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    consts,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calculate effects of ice and atmosphere on the ocean and update ocean stress fields and sea ice fraction. Inputs: floes &lt;StructArray{Floe}&gt; model&#39;s floes grid &lt;AbstractGrid&gt; model&#39;s grid atmos &lt;Atmos&gt; model&#39;s atmosphere ocean &lt;Ocean&gt; model&#39;s ocean domain &lt;Domain&gt; model&#39;s domain floe_settings &lt;FloeSettings&gt; simulation&#39;s floe settings consts &lt;Constants&gt; model&#39;s constants Δt &lt;Int&gt; simulation&#39;s timestep in seconds Output: None. Update&#39;s ocean&#39;s stress fields and heatflux factor field.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.center_cell_coords-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Int64, RegRectilinearGrid, Any, Any}} where FT" href="#Subzero.center_cell_coords-Union{Tuple{FT}, Tuple{Type{FT}, Int64, Int64, RegRectilinearGrid, Any, Any}} where FT">#</a> <b><u>Subzero.center_cell_coords</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">center_cell_coords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xidx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    yidx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegRectilinearGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ns_bound,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ew_bound,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find the coordinates of a given grid cell, centered on a grid line with row yidx and column xidx. This is offset from the cells within the regular rectilinear grid by half of a grid cell. Inputs: xidx &lt;Int&gt; x index of grid line within list of gridlines (cell column) yidx &lt;Int&gt; y index of grid line within list of gridlines (cell row) grid &lt;RegRectilinearGrid&gt; model&#39;s grid ns_bound &lt;AbstractBoundary&gt; type of either north or south boundary - for checking if periodic ew_bound &lt;AbstractBoundary&gt; type of either east or west boundary - for checking if perioidic Output: &lt;PolyVec&gt; coordinates for cell centered on grid line with given indices. Note that cell bounds will be adjusted depending on if the bounds are periodic. Cells cannot extend outside of non-periodic boundaries and thus will be trimmed at boundaries. Therefore, if indices place cell completely outside of grid, could return a line at the edge of the boundary.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, PeriodicBoundary}" href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, PeriodicBoundary}">#</a> <b><u>Subzero.check_cell_bounds</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_cell_bounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xmin,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xmax,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ymin,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ymax,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return cell bounding values as is given the domain is doubley periodic and thus the cell can extend beyond the grid as it will simply wrap back around into grid through opposite periodic boundary. Inputs: xmin &lt;Float&gt; center cell minimum x value xmax &lt;Float&gt; center cell maxumum x value ymin &lt;Float&gt; center cell minimum y value ymax &lt;Float&gt; center cell maximum y value grid &lt;AbstractGrid&gt; model&#39;s grid &lt;PeriodicBoundary&gt; type of north or south boundary - periodic pair &lt;PeriodicBoundary&gt; type of east or west boundary - periodic pair Output: x and y minimums and maximums as given since they can extend past the grid due to periodic boundaries.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}" href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}">#</a> <b><u>Subzero.check_cell_bounds</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_cell_bounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xmin,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xmax,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ymin,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ymax,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NonPeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Trim cell bound in the east-west direction if it exends past grid due to non-periodic boundary pair. Inputs: xmin &lt;Float&gt; center cell minimum x value xmax &lt;Float&gt; center cell maxumum x value ymin &lt;Float&gt; center cell minimum y value ymax &lt;Float&gt; center cell maximum y value grid &lt;AbstractGrid&gt; &lt;PeriodicBoundary&gt; type of either north or south boundary - periodic pair &lt;NonPeriodicBoundary&gt; type of either east or west boundary - not a periodic pair Output: Potentially trimmed x min and max if these values extend beyond grid values. Else returned unchanged.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}" href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}">#</a> <b><u>Subzero.check_cell_bounds</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_cell_bounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xmin,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xmax,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ymin,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ymax,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NonPeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Trim cell bound in the north-south direction if it exends past grid due to non-periodic boundary pair. Inputs: xmin &lt;Float&gt; center cell minimum x value xmax &lt;Float&gt; center cell maxumum x value ymin &lt;Float&gt; center cell minimum y value ymax &lt;Float&gt; center cell maximum y value grid &lt;AbstractGrid&gt; &lt;NonPeriodicBoundary&gt; type of either north or south boundary - not a periodic pair &lt;PeriodicBoundary&gt; type of either east or west boundary - periodic pair Output: Potentially trimmed y min and y max if these values extend beyond grid values. Else returned unchanged.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}" href="#Subzero.check_cell_bounds-Tuple{Any, Any, Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}">#</a> <b><u>Subzero.check_cell_bounds</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_cell_bounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xmin,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xmax,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ymin,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ymax,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NonPeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NonPeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Trim cell bounds in the east-west and north-south direction if they exend past grid due to non-periodic boundary pairs. Inputs: xmin &lt;Float&gt; center cell minimum x value xmax &lt;Float&gt; center cell maxumum x value ymin &lt;Float&gt; center cell minimum y value ymax &lt;Float&gt; center cell maximum y value grid &lt;AbstractGrid&gt; &lt;NonPeriodicBoundary&gt; type of either north or south boundary - not a periodic pair &lt;NonPeriodicBoundary&gt; type of either east or west boundary - not a periodic pair Output: Potentially trimmed x and y minimums and maximums if these values extend beyond grid values. Else returned unchanged.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.check_energy_momentum_conservation_julia" href="#Subzero.check_energy_momentum_conservation_julia">#</a> <b><u>Subzero.check_energy_momentum_conservation_julia</u></b> — <i>Function</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_energy_momentum_conservation_julia</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filename, dir, verbose)</span></span></code></pre></div><p>Calculates total kinetic energy and momentum at each timestep and plots the output to check for conservation from floe outputwriter file. Also gives percent change in energy and momentum from first to last timestep in terminal. Inputs: filename &lt;String&gt; floe outputwriter filename + path dir &lt;String&gt; directory to save total energy and momentum conservation plots plot &lt;Bool&gt; plots energy and momentum over time if true Outputs: Δenergy &lt;Float&gt; percentage change in energy from first to last timestep Δxmomentum &lt;Float&gt; % change in x momentum from first to last timestep Δymomentum &lt;Float&gt; % change in y momentum from first to last timestep Δangularmomentum &lt;Float&gt; % change in angular momentum from first to last timestep Also saves energy and momentum plots over time to given directory if plots is true</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.check_energy_momentum_conservation_matlab" href="#Subzero.check_energy_momentum_conservation_matlab">#</a> <b><u>Subzero.check_energy_momentum_conservation_matlab</u></b> — <i>Function</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_energy_momentum_conservation_matlab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mat_path, dir, plot)</span></span></code></pre></div><p>Calculates total kinetic energy and momentum at each timestep and plots the output to check for conservation from MATLAB verion of model output. The mat_path should lead to the Floes file within the MATLAB version of the model. Also givesnpercent change in energy and momentum from first to last timestep in terminal. Inputs: mat_path &lt;String&gt; path to MATLAB version&#39;s Floe folder dir &lt;String&gt; directory to save total energy and momentum conservation plots plot &lt;Bool&gt; plots energy and momentum over time if true Outputs: Δenergy &lt;Float&gt; percentage change in energy from first to last timestep Δxmomentum &lt;Float&gt; % change in x momentum from first to last timestep Δymomentum &lt;Float&gt; % change in y momentum from first to last timestep Δangularmomentum &lt;Float&gt; % change in angular momentum from first to last timestep Also saves energy and momentum plots over time to given directory if plots is true</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.check_for_edge_mid-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT" href="#Subzero.check_for_edge_mid-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, FT}} where FT">#</a> <b><u>Subzero.check_for_edge_mid</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_for_edge_mid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c, start, stop, shared_idx, shared_dist, running_dist)</span></span></code></pre></div><p>Check if indices from start to stop index of given coords includes midpoint given the shared distance and return midpoint if it exists in given range. Inputs: c &lt;PolyVec&gt; floe coordinates start &lt;Int&gt; index of shared_index list to start search from stop &lt;Int&gt; index of shared_index list to stop search at shared_idx &lt;Vector{Int}&gt; list of indices of c used to calculate midpoint shared_dist &lt;Float&gt; total length of edges considered from shared_idx running_dist &lt;Float&gt; total length of edges traveled along in midpoint search so far Outputs: mid_x &lt;Float&gt; x-coordinate of midpoint, Inf if midpoint not in given range mid_y &lt;Float&gt; y-coordinate of midpoint, Inf if midpoint not in given range running_dist &lt;Float&gt; sum of distances travelled along shared edges</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.compare_floe_data-Tuple{Any, Any}" href="#Subzero.compare_floe_data-Tuple{Any, Any}">#</a> <b><u>Subzero.compare_floe_data</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compare_floe_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filename1, filename2)</span></span></code></pre></div><p>Compare two files output by the floe output writer. Prints out first instances of not matching per timestep and field. Inputs: filename1 &lt;String&gt; filename and path of first file filename2 &lt;String&gt; filename and path of second file Outputs: If there are instances of differences, function will print time and index of floes that don&#39;t match</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.compare_grid_data-Tuple{Any, Any}" href="#Subzero.compare_grid_data-Tuple{Any, Any}">#</a> <b><u>Subzero.compare_grid_data</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compare_grid_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filename1, filename2)</span></span></code></pre></div><p>Compare two files output by the grid output writer. Prints out first instances of not matching per field. All timesteps are compared at once. Inputs: filename1 &lt;String&gt; filename and path of first file filename2 &lt;String&gt; filename and path of second file Outputs: If there are instances of differences, function will print the field that has discrepancies.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.compare_oa_checkpointer_data-Tuple{Any, Any}" href="#Subzero.compare_oa_checkpointer_data-Tuple{Any, Any}">#</a> <b><u>Subzero.compare_oa_checkpointer_data</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compare_checkpointer_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filename1, filename2)</span></span></code></pre></div><p>Compare two files output by the checkpointer output writer. Compares ocean and atmosphere. If there are discrepancies between the files, it will timesteps and field. Inputs: filename1 &lt;String&gt; filename and path of first file filename2 &lt;String&gt; filename and path of second file Outputs: If there are instances of differences, function will print the field and timesteps that have discrepancies.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.conserve_momentum_change_floe_shape!" href="#Subzero.conserve_momentum_change_floe_shape!">#</a> <b><u>Subzero.conserve_momentum_change_floe_shape!</u></b> — <i>Function</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">conserve_momentum_change_floe_shape!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mass_tmp,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    moment_tmp,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x_tmp,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    y_tmp,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    keep_floe,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    combine_floe </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Update current and previous velocity/acceleration fields to conserve momentum of a floe whose shape has been changed, given the previous mass, momentum, and centroid. Inputs: mass_tmp &lt;AbstractFloat&gt; original mass of floe before shape change moment_tmp &lt;AbstractFloat&gt; original moment of intertia of floe before shape change x_tmp &lt;AbstractFloat&gt; original x-coordinate of centroid of floe before shape change y_tmp &lt;AbstractFloat&gt; original y-coordinate of centroid of floe before shape change Δt &lt;Int&gt; timestep of simulation in seconds keep_floe &lt;Union{Floe, LazyRow{Floe}}&gt; floe whose shape has been changed combine_floe &lt;Union{Floe, LazyRow{Floe}}&gt; if keep_floe&#39;s shape has been changed due to an interaction with another floe, combine_floe is that floe - optional parameter Output: None. keep_floe&#39;s u, v, ξ, p_dxdt, p_dydt, p_dαdt, p_dudt, p_dvdt, and p_dξdt fields all updated to preserve momentum. Note: Function does not depend on conservation of mass</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.conserve_momentum_fracture_floe!-Union{Tuple{FT}, Tuple{Any, StructArrays.StructArray{&lt;:Floe{FT}}, Any}} where FT" href="#Subzero.conserve_momentum_fracture_floe!-Union{Tuple{FT}, Tuple{Any, StructArrays.StructArray{&lt;:Floe{FT}}, Any}} where FT">#</a> <b><u>Subzero.conserve_momentum_fracture_floe!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">conserve_momentum_fracture_floe!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    init_floe,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    new_floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Update new_floes&#39;s current and previous velocity/acceleration fields to conserve momentum when a floe has been fractured into several new floes, given the previous mass, momentum, and centroid. The assumption is made that each new floe has the same velocities/accelerations Inputs: init_floe &lt;Union{Floe, LazyRow{Floe}}&gt; original floe new_floes &lt;StructArray{Floe}&gt; fractured pieces of original floe Δt &lt;Int&gt; simulation&#39;s timestep in seconds Output: None. new_floes velocities and accelerations are updated for current and previous timestep to conserve momentum. Note: Depends on conservation of mass.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.conserve_momentum_transfer_mass!" href="#Subzero.conserve_momentum_transfer_mass!">#</a> <b><u>Subzero.conserve_momentum_transfer_mass!</u></b> — <i>Function</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">conserve_momentum_transfer_mass!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    idx1, idx2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    m1, m2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    I1, I2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x1, x2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    y1, y2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pieces_list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pieces_idx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Conserve linear momentum when mass is transfered from one floe to another floe. Inputs: floes &lt;StructArray{Floes}&gt; list of floes idx1 &lt;Int&gt; index of first floe in floes list idx2 &lt;Int&gt; index of second floe in floes list m1 &lt;Float&gt; initial mass of first floe before mass transfer m2 &lt;Float&gt; initial mass of second floe before mass transfer Δt &lt;Int&gt; timestep of simulation in seconds pieces_list &lt;Union{nothing, Vector{Floe}}&gt; list of floes created from floes breaking during ridging and rafting pieces_idx &lt;Int&gt; start index of pieces included in conservation calculations within the pieces_list Outputs: Nothing. Update floes&#39; velocities and accelerations to conserve linear momentum.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.deepcopy_floe-Union{Tuple{StructArrays.LazyRow{Floe{FT}}}, Tuple{FT}} where FT" href="#Subzero.deepcopy_floe-Union{Tuple{StructArrays.LazyRow{Floe{FT}}}, Tuple{FT}} where FT">#</a> <b><u>Subzero.deepcopy_floe</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">deepcopy_floe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(floe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LazyRow{Floe{FT}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Deepcopy of a floe by creating a new floe and copying all fields. Inputs: floe &lt;Floe&gt; Outputs: New floe with floes that are equal in value. Any vector fields are copies so they share values, but not referance.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.deform_floe!-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Vararg{Any, 4}}} where FT" href="#Subzero.deform_floe!-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Vararg{Any, 4}}} where FT">#</a> <b><u>Subzero.deform_floe!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">deform_floe!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    deformer_poly,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    deforming_forces,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Deform a floe around the area of its collision with largest area overlap within the last timestep. Inputs: floe &lt;Floe&gt; floe to deform deformer_coords &lt;PolyVec&gt; coords of floe that is deforming floe argument deforming_forces &lt;Vector{AbstractFloat}&gt; 1x2 matrix of forces between floe and the deforming floe from floe&#39;s interactions - of the form: [xforce yforce] Outputs: None. The input floe&#39;s centroid, coordinates, and area are updated to reflect a deformation due to the collision with the deforming floe.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.determine_fractures-Tuple{Any, Subzero.AbstractFractureCriteria, Any}" href="#Subzero.determine_fractures-Tuple{Any, Subzero.AbstractFractureCriteria, Any}">#</a> <b><u>Subzero.determine_fractures</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">determine_fractures</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    criteria,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    min_floe_area,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Determines which floes will fracture depending on the principal stress criteria. Inputs: floes &lt;StructArray{Floe}&gt; model&#39;s list of floes criteria &lt;AbstractFractureCriteria&gt; fracture criteria floe_settings &lt;FloeSettings&gt; Floe settings. Contains Floe properties and stress calculator. Outputs: &lt;Vector{Int}&gt; list of indices of floes to fracture</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.dissolve_floe!-Tuple{Any, RegRectilinearGrid, Any, Any}" href="#Subzero.dissolve_floe!-Tuple{Any, RegRectilinearGrid, Any, Any}">#</a> <b><u>Subzero.dissolve_floe!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dissolve_floe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(floe, grid, dissolved)</span></span></code></pre></div><p>Dissolve given floe into dissolved ocean matrix. Inputs: floe &lt;Union{Floe, LazyRow{Floe}}&gt; single floe grid &lt;RegRectilinearGrid&gt; model&#39;s grid domain &lt;Domain&gt; model&#39;s domain dissolved &lt;Matrix{AbstractFloat}&gt; ocean&#39;s dissolved field Outputs: None. Update dissolved matrix with given floe&#39;s mass and mark floe for removal.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.domain_in_grid-Tuple{Domain, AbstractGrid}" href="#Subzero.domain_in_grid-Tuple{Domain, AbstractGrid}">#</a> <b><u>Subzero.domain_in_grid</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">domain_in_grid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(domain, grid)</span></span></code></pre></div><p>Checks if given rectangular domain is within given grid and gives user a warning if domain is not of maximum possible size given grid dimensions. Inputs: domain &lt;RectangularDomain&gt; grid &lt;AbstractGrid&gt; Outputs: &lt;Boolean&gt; true if domain is within grid bounds, else false</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.euclidian_dist-Tuple{Any, Any, Any}" href="#Subzero.euclidian_dist-Tuple{Any, Any, Any}">#</a> <b><u>Subzero.euclidian_dist</u></b> — <i>Method</i>. <p>euclidian_dist(c, idx2, idx1)</p><p>Calculate euclidean distance between two points within given coordinates</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.find_center_cell_index-Tuple{Any, Any, RegRectilinearGrid}" href="#Subzero.find_center_cell_index-Tuple{Any, Any, RegRectilinearGrid}">#</a> <b><u>Subzero.find_center_cell_index</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_center_cell_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xp, yp, grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegRectilinearGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find index of the cell centered on grid lines of the given RegRectilinearGrid that the given x-coordinate and y-coordinate falls within. This cell is centered around the grid lines, so it is a shifted grid cell by half a cell. Method depends on grid being a regular rectilinear grid. Inputs: xp &lt;AbstractFloat&gt; x-coordinates of point yp &lt;AbstractFloat&gt; y-coordinate of point grid &lt;RegRectilinearGrid&gt; simulation grid Outputs: xidx &lt;AbstractFloat&gt; x-index of grid cell (cented on grid lines) x-point is within - this is the column yidx &lt;AbstractFloat&gt; y-index of grid cell (cented on grid lines) y-point is within - this is the row Note: Points can be outside of the grid, so index can be less than 1 or greater than the number of grid lines in a given direction.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{East, FT}, PeriodicBoundary{West, FT}}} where FT&lt;:AbstractFloat" href="#Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{East, FT}, PeriodicBoundary{West, FT}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.find_ghosts!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_ghosts!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    elem_idx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ebound</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    wbound</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find ghosts of given element and its known ghosts through an eastern or western periodic boundary. If element&#39;s centroid isn&#39;t within the domain in the east/west direction, swap it with its ghost since the ghost&#39;s centroid must then be within the domain. Inputs: floes &lt;StructArray{Floe}&gt; model&#39;s list of floes elem_idx &lt;Int&gt; floe of interest&#39;s index within the floe list eboundary &lt;PeriodicBoundary{East, Float}&gt; domain&#39;s eastern boundary wboundary &lt;PeriodicBoundary{West, Float}&gt; domain&#39;s western boundary Outputs: None. Ghosts added to the floe list. Primary floe always has centroid within the domain, else it is swapped with one of its ghost&#39;s which has a centroid within the domain.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{North, FT}, PeriodicBoundary{South, FT}}} where FT&lt;:AbstractFloat" href="#Subzero.find_ghosts!-Union{Tuple{FT}, Tuple{Any, Any, PeriodicBoundary{North, FT}, PeriodicBoundary{South, FT}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.find_ghosts!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_ghosts!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    elem_idx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nbound</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary{North, &lt;:AbstractFloat}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sbound</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary{South, &lt;:AbstractFloat}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find ghosts of given element and its known ghosts through an northern or southern periodic boundary. If element&#39;s centroid isn&#39;t within the domain in the north/south direction, swap it with its ghost since the ghost&#39;s centroid must then be within the domain. Inputs: floes &lt;StructArray{Floe}&gt; model&#39;s list of floes elem_idx &lt;Int&gt; floe of interest&#39;s index within the floe list nboundary &lt;PeriodicBoundary{North, Float}&gt; domain&#39;s northern boundary sboundary &lt;PeriodicBoundary{South, Float}&gt; domain&#39;s southern boundary Outputs: None. Ghosts added to the floe list. Primary floe always has centroid within the domain, else it is swapped with one of its ghost&#39;s which has a centroid within the domain.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.find_grid_cell_index-Tuple{Any, Any, RegRectilinearGrid}" href="#Subzero.find_grid_cell_index-Tuple{Any, Any, RegRectilinearGrid}">#</a> <b><u>Subzero.find_grid_cell_index</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_grid_cell_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xp, yp, grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegRectilinearGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find index of the grid cell of the given RegRectilinearGrid that the given x-coordinate and y-coordinate falls within. Method depends on grid being a regular rectilinear grid. Inputs: xp &lt;AbstractFloat&gt; x-coordinates of point yp &lt;AbstractFloat&gt; y-coordinate of point grid &lt;RegRectilinearGrid&gt; simulation grid Outputs: xidx &lt;AbstractFloat&gt; x-index of grid cell x-point is within - this is the column yidx &lt;AbstractFloat&gt; y-index of grid cell y-point is within - this is the row Note: Points can be outside of the grid, so index can be less than 1 or greater than the number of grid cells</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, PeriodicBoundary}" href="#Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, PeriodicBoundary}">#</a> <b><u>Subzero.find_interp_knots</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_interp_knots</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    point_idx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ncells,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    L,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find indicies in list of grid lines that surround points with indicies &#39;point_idx&#39;, with a buffer of Δd indices on each side of the points. In this case, the points are being considered near a periodic boundary, which means that they can loop around to the other side of the grid. If these points exist, we extend the grid lines to cover the points and buffer. Inputs: point_idx &lt;Vector{Int}&gt; vector of point indices representing the grid line they are nearest ncells &lt;Int&gt; number of grid cells in given dimension glines &lt;Vector or Range&gt; grid line values L &lt;AbstractFloat&gt; length of grid in given dimension Δd &lt;Int&gt; number of buffer grid cells to include on either side of the provided indicies &lt;PeriodicBoundary&gt; dispatching on periodic boundary Outputs: knots &lt;Vector{AbstractFloat}&gt; interpolation knots - grid line values knot_idx &lt;Vector{Int}&gt; - indices of grid line values within grid list of grid lines. Note: The grid values are extended if points expand past gridlines, however, the indices are within the grid. For example, consider a grid where the maximum grid value is 1e5, with grid cells of length 1e4. One of the knot values might be 1.1e5, however, its index would be 2 since the grid line at 1e5 is equivalent to the first grid line since it is periodic, and 1.1e5 is one grid cell length past that value.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>This function depends on the ocean being periodic in the given direction.</span></span>
<span class="line"><span>We assume that first grid line and the last grid line are the same, and have</span></span>
<span class="line"><span>the same values within the ocean/atmosphere. These are not repeated in the</span></span>
<span class="line"><span>knots, but rather only one is used. So if there are 10 grid lines, grid line</span></span>
<span class="line"><span>1 and 10 are the equivalent and we use grid line 1 exclusively.</span></span></code></pre></div><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}" href="#Subzero.find_interp_knots-Tuple{Any, Any, Any, Any, Int64, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}">#</a> <b><u>Subzero.find_interp_knots</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_interp_knots</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    point_idx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ncells,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    L,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NonPeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find indicies in list of grid lines that surround points with indicies &#39;point_idx&#39; with a buffer of Δd indices on each side of the points. In this case, the points are being considered near a NON-periodic boundary, so we cut off the possible indices past the edge of the grid. Inputs: point_idx &lt;Vector{Int}&gt; vector of indices representing the grid line they are nearest ncells &lt;Int&gt; number of grid cells in given dimension glines &lt;Vector or Range&gt; grid line values L &lt;AbstractFloat&gt; length of grid in given dimension Δd &lt;Int&gt; number of buffer grid cells to include on either side of the provided indicies &lt;PeriodicBoundary&gt; dispatching on periodic boundary Outputs: knots &lt;Vector{AbstractFloat}&gt; interpolation knots - grid line values knot_idx &lt;Vector{Int}&gt; - indices of grid line values within grid list of grid lines. Note: Only knots within the grid will be returned since this is a non-periodic boundary.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.find_poly_coords-Tuple{Any}" href="#Subzero.find_poly_coords-Tuple{Any}">#</a> <b><u>Subzero.find_poly_coords</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_poly_coords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(poly)</span></span></code></pre></div><p>Syntactic sugar for to find a polygon&#39;s coordinates Input: poly &lt;Polygon&gt; Output: &lt;PolyVec&gt; representing the floe&#39;s coordinates xy plane</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.find_shared_edges_midpoint-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any}} where FT" href="#Subzero.find_shared_edges_midpoint-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any}} where FT">#</a> <b><u>Subzero.find_shared_edges_midpoint</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_shared_edges_midpoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c1, c2)</span></span></code></pre></div><p>Find &quot;midpoint&quot; of shared polygon edges by distance Inputs: c1 &lt;PolVec&gt; polygon coordinates for floe 1 c2 &lt;PolVec&gt; polygon coordinates for floe 2 Outputs: mid_x &lt;Float&gt; x-coordinate of midpoint mid_y &lt;Float&gt; y-coordinate of midpoint</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.floe_domain_element_interaction!-Tuple{Any, PeriodicBoundary, Vararg{Any, 4}}" href="#Subzero.floe_domain_element_interaction!-Tuple{Any, PeriodicBoundary, Vararg{Any, 4}}">#</a> <b><u>Subzero.floe_domain_element_interaction!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">floe_domain_element_interaction!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    element_idx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    consts,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a given floe intersects with a periodic boundary, nothing happens at this point. Periodic floes pass through boundaries using ghost floes. Inputs: None are used. Output: None. This function does not do anyting.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Any, Union{CollisionBoundary, MovingBoundary, TopographyElement}, Any, Any, Any, FT}} where FT" href="#Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Any, Union{CollisionBoundary, MovingBoundary, TopographyElement}, Any, Any, Any, FT}} where FT">#</a> <b><u>Subzero.floe_domain_element_interaction!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">floe_domain_element_interaction!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    element,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    element_idx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    consts,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If floe intersects with given element (either collision boundary or topography element), floe interactions field and overarea field are updated. Inputs: floe &lt;Floe&gt; floe interacting with element element &lt;Union{CollisionBoundary, TopographyElement}&gt; coordinates of element consts &lt;Constants&gt; model constants needed for calculations Δt &lt;Int&gt; current simulation timestep max_overlap &lt;Float&gt; Percent a floe can overlap with a collision wall or topography before being killed/removed Outputs: None. If floe interacts, the floe&#39;s interactions field is updated with the details of each region of overlap. The interactions field will have the following form for each region of overlap with the element: [Inf, xforce, yforce, xfpoints, yfpoints, overlaps] where the xforce and yforce are the forces, xfpoints and yfpoints are the location of the force and overlaps is the overlap between the floe and element. The overlaps field is also added to the floe&#39;s overarea field that describes the total overlapping area at any timestep.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, OpenBoundary, Vararg{Any, 4}}} where FT" href="#Subzero.floe_domain_element_interaction!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, OpenBoundary, Vararg{Any, 4}}} where FT">#</a> <b><u>Subzero.floe_domain_element_interaction!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">floe_domain_element_interaction!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(floe, boundary, _, _,)</span></span></code></pre></div><p>If given floe insersects with an open boundary, the floe is set to be removed from the simulation. Inputs: floe &lt;Floe&gt; floe interacting with boundary boundary &lt;OpenBoundary&gt; coordinates of boundary _ &lt;Constants&gt; model constants needed in other methods of this function - not needed here _ &lt;Int&gt; current simulation timestep - not needed here - &lt;Float&gt; maximum overlap between floe and domain elements - not needed here Output: None. If floe is interacting with the boundary, floe&#39;s status is set to remove. Else, nothing is changed.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.floe_domain_interaction!-Union{Tuple{FT}, Tuple{Any, Domain, Any, Any, FT}} where FT&lt;:AbstractFloat" href="#Subzero.floe_domain_interaction!-Union{Tuple{FT}, Tuple{Any, Domain, Any, Any, FT}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.floe_domain_interaction!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">floe_domain_interaction!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    consts,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_overlap,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If the floe interacts with the domain, update the floe accordingly. Dispatches on different boundary types within the domain. Inputs: floe &lt;Floe&gt; floe interacting with boundary domain &lt;Domain&gt; model domain consts &lt;Constants&gt; model constants needed for calculations Δt &lt;Int&gt; current simulation timestep max_overlap &lt;Float&gt; Percent a floe can overlap with a collision wall or topography before being killed/removed Outputs: None. Floe is updated according to which boundaries it interacts with and the types of those boundaries.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.floe_domain_raft!-Tuple{Any, Any, Union{StructArrays.LazyRow{&lt;:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}" href="#Subzero.floe_domain_raft!-Tuple{Any, Any, Union{StructArrays.LazyRow{&lt;:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}">#</a> <b><u>Subzero.floe_domain_raft!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">floe_domain_raft!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    idx1,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain_element,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pieces_buffer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_floe_id,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    broken,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ridgeraft_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    simp_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Raft a floe against a boundary or a topography element and return any excess floes created by the rafting. This is equivalent to ridging. Inputs: floes &lt;StructArray{Floe}&gt; floe list idx1 &lt;Int&gt; index of first floe domain_element &lt;AbstractDomainElement&gt; boundary or topography element pieces_buffer &lt;StructArray{Floe}&gt; list of new floe pieces caused by breakage of floes max_floe_id &lt;Int&gt; maximum floe ID before this ridging/rafting broken &lt;Vector{Bool}&gt; floe index is true if that floe has broken in a previous ridge/raft interaction ridgeraft_settings &lt;RidgeRaftSettings&gt; ridge/raft settings floe_settings &lt;FloeSettings&gt; simulation&#39;s settings for making floes simp_settings &lt;SimplificationSettings&gt; simplification settings Δt &lt;Int&gt; simulation timestep in seconds rng &lt;RandomNumberGenerator&gt; simulation&#39;s random number generator Outputs: floe1 is updated with new shape. If any new floes are created by rafting they are returned, else nothing.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.floe_domain_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Union{StructArrays.LazyRow{&lt;:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}} where FT" href="#Subzero.floe_domain_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Union{StructArrays.LazyRow{&lt;:Subzero.AbstractDomainElement}, Subzero.AbstractDomainElement}, Vararg{Any, 8}}} where FT">#</a> <b><u>Subzero.floe_domain_ridge!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">floe_domain_ridge!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    idx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain_element,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pieces_buffer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_floe_id,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    broken,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ridgeraft_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    simp_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Ridge a floe against a boundary or a topography element and return any excess floes created by the ridging. Inputs: floes &lt;StructArray{Floe}&gt; floe list idx1 &lt;Int&gt; index of first floe domain_element &lt;AbstractDomainElement&gt; boundary or topography element pieces_buffer &lt;StructArray{Floe}&gt; list of new floe pieces caused by breakage of floes max_floe_id &lt;Int&gt; maximum floe ID before this ridging/rafting broken &lt;Vector{Bool}&gt; floe index is true if that floe has broken in a previous ridge/raft interaction ridgeraft_settings &lt;RidgeRaftSettings&gt; simulation&#39;s settings for ridge/raft floe_settings &lt;FloeSettings&gt; simulation&#39;s settings for making floes simp_settings &lt;SimplificationSettings&gt; simulation&#39;s settings for simplification Δt &lt;Int&gt; simulation timestep in seconds rng &lt;RandomNumberGenerator&gt; simulation&#39;s random number generator Outputs: floe1 is updated with new shape. Return maximum floe id of floes created</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.floe_floe_interaction!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat" href="#Subzero.floe_floe_interaction!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, Any, Any, FT}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.floe_floe_interaction!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">floe_floe_interaction!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ifloe,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    jfloe,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    j,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nfloes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    consts,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If the two floes interact, update floe i&#39;s interactions accordingly. Floe j is not update here so that the function can be parallelized. Inputs: ifloe &lt;Floe&gt; first floe in potential interaction i &lt;Int&gt; index of ifloe in model&#39;s list of floes jfloe &lt;Floe&gt; second floe in potential interaction j &lt;Int&gt; index of jfloe in model&#39;s list of floes nfloes &lt;Int&gt; number of non-ghost floes in the simulation this timestep consts &lt;Constants&gt; model constants needed for calculations Δt &lt;Int&gt; Simulation&#39;s current timestep max_overlap &lt;Float&gt; Percent two floes can overlap before marking them for fusion Outputs: None. Updates floes interactions fields. If floes overlap by more than the max_overlap fraction, they will be marked for fusion. Note: If ifloe interacts with jfloe, only ifloe&#39;s interactions field is updated with the details of each region of overlap. The interactions field will have the following form for each region of overlap with the boundary: [Inf, xforce, yforce, xfpoints, yfpoints, overlaps] where the xforce and yforce are the forces, xfpoints and yfpoints are the location of the force and overlaps is the overlap between the floe and boundary. The overlaps field is also added to the floe&#39;s overarea field that describes the total overlapping area at any timestep.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.floe_floe_raft!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT" href="#Subzero.floe_floe_raft!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT">#</a> <b><u>Subzero.floe_floe_raft!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">floe_floe_raft!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    idx1,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    idx2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pieces_buffer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_floe_id,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    broken,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ridgeraft_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    simp_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Raft two floes, updating both in-place and returning any new floes that resulting from the rafting event. Inputs: floes &lt;StructArray{Floe}&gt; floe list idx1 &lt;Int&gt; index of first floe idx2 &lt;Int&gt; index of second floe pieces_buffer &lt;StructArray{Floe}&gt; list of new floe pieces caused by breakage of floes max_floe_id &lt;Int&gt; maximum floe ID before this ridging/rafting broken &lt;Vector{Bool}&gt; floe index is true if that floe has broken in a previous ridge/raft interaction ridgeraft_settings &lt;RidgeRaftSettings&gt; simulation&#39;s ridge/raft settings floe_settings &lt;FloeSettings&gt; simultion&#39;s settings for making floes simp_settings &lt;SimplificationSettings&gt; simulation&#39;s simplification settings Δt &lt;Int&gt; simulation timestep in seconds rng &lt;RandomNumberGenerator&gt; simulation&#39;s random number generator Outputs: Updates floe1 and floe2 and returns any new floes created by rafting</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.floe_floe_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT" href="#Subzero.floe_floe_ridge!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT">#</a> <b><u>Subzero.floe_floe_ridge!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">floe_floe_ridge!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    idx1,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    idx2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    overlap_area,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ridgeraft_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    simp_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Ridge two floes, updating both in-place and returning any new floes that resulting from the ridging event. Inputs: floes &lt;StructArray{Floe}&gt; floe list idx1 &lt;Int&gt; index of first floe idx2 &lt;Int&gt; index of second floe pieces_buffer &lt;StructArray{Floe}&gt; list of new floe pieces caused by breakage of floes max_floe_id &lt;Int&gt; maximum floe ID before this ridging/rafting broken &lt;Vector{Bool}&gt; floe index is true if that floe has broken in a previous ridge/raft interaction ridgeraft_settings &lt;RidgeRaftSettings&gt; simulation&#39;s settings for ridging and rafting floe_settings &lt;FloeSettings&gt; simulation&#39;s settings for making floes simp_settings &lt;SimplificationSettings&gt; simulation&#39;s simplification settings Δt &lt;Int&gt; simulation timestep in seconds rng &lt;RandomNumberGenerator&gt; simulation&#39;s random number generator Outputs: Updates floe1 and floe2 and returns any new floes created by ridging</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.floe_to_grid_info!-Union{Tuple{FT}, Tuple{Any, Any, Any, FT, FT, Vararg{Any, 5}}} where FT" href="#Subzero.floe_to_grid_info!-Union{Tuple{FT}, Tuple{Any, Any, Any, FT, FT, Vararg{Any, 5}}} where FT">#</a> <b><u>Subzero.floe_to_grid_info!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">floe_to_grid_info!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floeidx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xidx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    yidx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    τx_ocn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    τy_ocn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    scells,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Add force from the ice on ocean to ocean force fields (fx &amp; fy) for each grid cell and update ocean sea ice area fraction (si_area), representing total area of sea ice in a given cell. Function is called for each monte carlo point. Inputs: floeidx &lt;Int&gt; index of floe within model&#39;s floe array xidx &lt;Int&gt; grid x index that floe&#39;s point is within for grid centered on grid lines yidx &lt;Int&gt; grid column that floe&#39;s point is within for grid centered on grid lines τx_ocn &lt;AbstractFloat&gt; x-stress caused by ocean on point τy_ocn &lt;AbstractFloat&gt; y-stress caused by ocean on point grid &lt;AbstractGrid&gt; model&#39;s grid domain &lt;Domain&gt; model&#39;s domain cell_floes &lt;Matrix{CellFloes}&gt; matrix of CellFloes, one for each grid cell scells &lt;Matrix{IceStressCell}&gt; matrix of IceStressCells, one for each grid cell coupling_settings &lt;CouplingSettings&gt; simulation&#39;s coupling settings</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.fracture_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat" href="#Subzero.fracture_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.fracture_floes!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fracture_floes!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_floe_id,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fracture_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Fractures floes that meet the criteria defined in the fracture settings. Inputs: floes &lt;StructArray{Floe}&gt; model&#39;s list of floes max_floe_id &lt;Int&gt; maximum ID of any floe created so far in simulation rng &lt;RNG&gt; random number generator fracture_settings &lt;FractureSettings&gt; sim&#39;s fracture settings floe_settings &lt;FloeSettings&gt; sim&#39;s settings to make floes Δtout &lt;Int&gt; length of simulation timestep in seconds Outputs: max_floe_id &lt;Int&gt; new highest floe ID after adding new floes to floe array. Floe pieces added to floe array and original fractured floes removed.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.fuse_floes!-NTuple{5, Any}" href="#Subzero.fuse_floes!-NTuple{5, Any}">#</a> <b><u>Subzero.fuse_floes!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fuse_floes!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_floe_id,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Fuse all floes marked for fusion. Inputs: floes &lt;StructArray{Floe}&gt; model&#39;s floes max_floe_id &lt;Int&gt; maximum floe ID created yet floe_settings &lt;FloeSettings&gt; simulation&#39;s settings for making floes Δt &lt;Int&gt; simulation timestep in seconds rng &lt;RNG&gt; random number generator Outputs: None. Fuses floes marked for fusion. Marks floes fused into another floe for removal.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.fuse_two_floes!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 5}}} where FT" href="#Subzero.fuse_two_floes!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 5}}} where FT">#</a> <b><u>Subzero.fuse_two_floes!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fuse_two_floes!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    keep_floe,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    remove_floe,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_floe_id,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Fuses two floes together if they intersect and replaces the larger of the two floes with their union. Mass and momentum are conserved. Inputs: keep_floe &lt;Union{Floe, LazyRow{Floe}}&gt; first floe remove_floe &lt;Union{Floe, LazyRow{Floe}}&gt; second floe floe_settings &lt;FloeSettings&gt; simulation&#39;s settings to make new floes prefuse_max_floe_id &lt;Int&gt; maximum floe ID used yet in simulation rng &lt;RNG&gt; random number generator Outputs: If floes are not intersecting, no changes. If intersecing, the fused floe replaces the larger of the two floes and the smaller floe is marked for removal. Note that the smaller floe&#39;s ID is NOT updated!</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{MonteCarloPointsGenerator{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat" href="#Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{MonteCarloPointsGenerator{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.generate_subfloe_points</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">generate_subfloe_points</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    point_generator</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    poly,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    centroid,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    area,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    status,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate monte carlo points centered on the origin within the floe according to parameters defined in the point_generator argument. Inputs: point_generator &lt;MonteCarloPointsGenerator&gt; monte carlo point generator poly &lt;Polygon&gt; Polygon representing floe shape centroid &lt;Matrix&gt; floe&#39;s centroid area &lt;AbstractFloat&gt; floe&#39;s area status &lt;Status&gt; floe status (i.e. active, fuse in simulation) rng &lt;AbstractRNG&gt; random number generator to generate monte carlo points Ouputs: x_sub_floe &lt;Vector{FT}&gt; vector of sub-floe grid points x-coords within floe y_sub_floe &lt;Vector{FT}&gt; vector of sub-floe grid points y-coords within floe status &lt;Status&gt; floe&#39;s status post generation, changed to remove if generation is unsuccessful</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{SubGridPointsGenerator{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat" href="#Subzero.generate_subfloe_points-Union{Tuple{FT}, Tuple{SubGridPointsGenerator{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.generate_subfloe_points</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">generate_subfloe_points</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    point_generator,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    poly,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    centroid,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    area,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    status,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate evenly spaced points within given floe coordinates to be used for coupling. If only one point falls within the floe, return the floe&#39;s centroid. Inputs: point_generator &lt;SubGridPointsGenerator&gt; sub-grid point generator poly &lt;Polygon&gt; Polygon representing floe shape centroid &lt;Matrix&gt; floe&#39;s centroid area &lt;AbstractFloat&gt; floe&#39;s area status &lt;Status&gt; floe status (i.e. active, fuse in simulation) rng &lt;AbstractRNG&gt; random number generator is not used in this generation method Ouputs: x_sub_floe &lt;Vector{FT}&gt; vector of sub-floe grid points x-coords within floe y_sub_floe &lt;Vector{FT}&gt; vector of sub-floe grid points y-coords within floe status &lt;Status&gt; tag isn&#39;t changed with this generation method</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.generate_voronoi_coords-Union{Tuple{FT}, Tuple{Int64, Any, Any, Vector{&lt;:Array{Array{Vector{var&quot;#s81&quot;}, 1}, 1} where var&quot;#s81&quot;&lt;:FT}, Any, Int64}} where FT&lt;:AbstractFloat" href="#Subzero.generate_voronoi_coords-Union{Tuple{FT}, Tuple{Int64, Any, Any, Vector{&lt;:Array{Array{Vector{var&quot;#s81&quot;}, 1}, 1} where var&quot;#s81&quot;&lt;:FT}, Any, Int64}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.generate_voronoi_coords</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">generate_voronoi_coords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    desired_points,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    scale_fac,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    trans_vec,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain_coords,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_tries </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate voronoi coords within a bounding box defined by its lower left corner and its height and width. Attempt to generate <code>npieces</code> cells within the box. Inputs: desired_points &lt;Int&gt; desired number of voronoi cells scale_fac &lt;Vector{AbstractFloat}&gt; width and height of bounding box - formatted as [w, h] trans_vec &lt;Vector{AbstractFloat}&gt; lower left corner of bounding box - formatted as [x, y] domain_coords &lt;Vector{PolyVec{AbstractFloat}}&gt; multipolygon that will eventually be filled with/intersected with the voronoi cells - such as topography rng &lt;RNG&gt; random number generator to generate voronoi cells min_to_warn &lt;Int&gt; minimum number of points to warn if not generated to seed voronoi max_tries &lt;Int&gt; number of tires to generate desired number of points within domain_coords to seed voronoi cell creation Outputs: coords &lt;Vector{PolyVec{Float}}&gt; vector of polygon coordinates generated by voronoi tesselation. These polygons all fall within the space defined by the domain_coords. If less polygons than min_to_warn are generated, the user will be warned.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.get_known_grid_outputs-Tuple{}" href="#Subzero.get_known_grid_outputs-Tuple{}">#</a> <b><u>Subzero.get_known_grid_outputs</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_known_grid_outputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns list of symbols that represent calculations available in calc_eularian_grid to average floe data.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.get_velocity-Union{Tuple{FT}, Tuple{Subzero.AbstractDomainElement{FT}, Any, Any}} where FT" href="#Subzero.get_velocity-Union{Tuple{FT}, Tuple{Subzero.AbstractDomainElement{FT}, Any, Any}} where FT">#</a> <b><u>Subzero.get_velocity</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_velocity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractDomainElement{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    y,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get velocity, which is 0m/s by default, of a point on topography element or boundary.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.get_velocity-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, FT, FT}} where FT" href="#Subzero.get_velocity-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, FT, FT}} where FT">#</a> <b><u>Subzero.get_velocity</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_velocity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    y,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get velocity of a point, assumed to be on given floe. Inputs: floe &lt;Union{LazyRow{Floe}, Floe}&gt; floe x &lt;AbstractFloat&gt; x-coordinate of point to find velocity at y &lt;AbstractFloat&gt; y-coordinate of point to find velocity at Outputs: u &lt;AbstractFloat&gt; u velocity at point (x, y) assuming it is on given floe v &lt;AbstractFloat&gt; v velocity at point (x, y) assuming it is on given floe</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.getattrs-Tuple{Symbol}" href="#Subzero.getattrs-Tuple{Symbol}">#</a> <b><u>Subzero.getattrs</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getattrs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(output</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FloeOutput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Returns unit and comment attributes for each output type to be saved within output NetCDF file Input: output&lt;FloeOutput&gt; Output: &lt;Tuple(String, String)&gt; tuple of string units and comments to be saved to output NetCDF file</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.ghosts_on_bounds!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}" href="#Subzero.ghosts_on_bounds!-Union{Tuple{FLT}, Tuple{FT}, Tuple{FLT, Any, Any, Any}} where {FT&lt;:AbstractFloat, FLT&lt;:(StructArrays.StructArray{&lt;:Floe{FT}})}">#</a> <b><u>Subzero.ghosts_on_bounds!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ghosts_on_bounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element, ghosts, boundary, trans_vec)</span></span></code></pre></div><p>If the given element intersects with the boundary, add ghosts of the element and any of its existing ghosts. Inputs: floes &lt;StructArray{Floe}&gt; model&#39;s list of floes elem_idx &lt;Int&gt; floe of interest&#39;s index within the floe list boundary &lt;PeriodicBoundary&gt; boundary to translate element through trans_vec &lt;Matrix{Float}&gt; 1x2 matrix of form [x y] to translate element through the boundary Outputs: Nothing. New ghosts created by the given element, or its current ghosts, are added to the floe list</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.grid_cell_index-Tuple{Any, Any, Any}" href="#Subzero.grid_cell_index-Tuple{Any, Any, Any}">#</a> <b><u>Subzero.grid_cell_index</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grid_cell_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, Δg, g0)</span></span></code></pre></div><p>Find the index of given point&#39;s cartesian value (in either the x or y direction) within the simulation grid. Inputs: p &lt;Real&gt; point&#39;s cartesian value in either x or y direction Δg &lt;Real&gt; simulation grid&#39;s cell width or height g0 &lt;Real&gt; simulation grid&#39;s first grid line value in either x or y direction Output: Point&#39;s grid cell index within the simulation grid, as specified by the grid cell dimension and grid line starting value, in either the x or y direction</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.grid_line_index-Tuple{Any, Any, Any}" href="#Subzero.grid_line_index-Tuple{Any, Any, Any}">#</a> <b><u>Subzero.grid_line_index</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grid_line_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, Δg, g0)</span></span></code></pre></div><p>Find the index of given point&#39;s cartesian value (in either the x or y direction) within grid with cells centered on simulation grid&#39;s grid lines. Thus these cells are shifted from simulation&#39;s grid cells by half of a grid cell to the left. Inputs: p &lt;Real&gt; point&#39;s cartesian value in either x or y direction Δg &lt;Real&gt; grid&#39;s cell width or height g0 &lt;Real&gt; grid&#39;s first grid line value in either x or y direction Output: Point&#39;s grid cell index within the shifted simulation grid, as specified by the grid cell dimension and grid line starting value, in either the x or y direction</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.grid_xc_index-Tuple{Any, Any, RegRectilinearGrid}" href="#Subzero.grid_xc_index-Tuple{Any, Any, RegRectilinearGrid}">#</a> <b><u>Subzero.grid_xc_index</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grid_xc_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xp, yp, grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegRectilinearGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find indices of given cartesian point within simulation&#39;s xc-grid. Inputs: xp &lt;Real&gt; point&#39;s x-cartesian value yp &lt;Real&gt; point&#39;s y-cartesian value grid &lt;RegRectilinearGrid&gt; simulation&#39;s grid Outputs: x index and y indices within xc-grid Note: This is equivalent fo the yc-grid</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.grid_xg_index-Tuple{Any, Any, RegRectilinearGrid}" href="#Subzero.grid_xg_index-Tuple{Any, Any, RegRectilinearGrid}">#</a> <b><u>Subzero.grid_xg_index</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grid_xg_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xp, yp, grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegRectilinearGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find indices of given cartesian point within simulation&#39;s xg-grid. Inputs: xp &lt;Real&gt; point&#39;s x-cartesian value yp &lt;Real&gt; point&#39;s y-cartesian value grid &lt;RegRectilinearGrid&gt; simulation&#39;s grid Outputs: x index and y indices within xg-grid</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.grid_yc_index-Tuple{Any, Any, RegRectilinearGrid}" href="#Subzero.grid_yc_index-Tuple{Any, Any, RegRectilinearGrid}">#</a> <b><u>Subzero.grid_yc_index</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grid_yc_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xp, yp, grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegRectilinearGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find indices of given cartesian point within simulation&#39;s yc-grid. Inputs: xp &lt;Real&gt; point&#39;s x-cartesian value yp &lt;Real&gt; point&#39;s y-cartesian value grid &lt;RegRectilinearGrid&gt; simulation&#39;s grid Outputs: x index and y indices within yc-grid Note: This is equivalent fo the xc-grid</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.grid_yg_index-Tuple{Any, Any, RegRectilinearGrid}" href="#Subzero.grid_yg_index-Tuple{Any, Any, RegRectilinearGrid}">#</a> <b><u>Subzero.grid_yg_index</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grid_yg_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xp, yp, grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegRectilinearGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find indices of given cartesian point within simulation&#39;s yg-grid. Inputs: xp &lt;Real&gt; point&#39;s x-cartesian value yp &lt;Real&gt; point&#39;s y-cartesian value grid &lt;RegRectilinearGrid&gt; simulation&#39;s grid Outputs: x index and y indices within yg-grid</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.grids_from_lines-Tuple{Any, Any}" href="#Subzero.grids_from_lines-Tuple{Any, Any}">#</a> <b><u>Subzero.grids_from_lines</u></b> — <i>Method</i>. <p>grids_from_lines(xlines, ylines)</p><p>Creates x-grid and y-grid. Assume xlines has length n and ylines has length m. xgrid is the grid&#39;s xline vector repeated m times as rows in a mxn array and ygrid is the yline vector repeated n times as columns in a mxn vector. xlines and ylines are typically either xg and yg or xc and yc.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.hashole-Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat}" href="#Subzero.hashole-Tuple{GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{T, T}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing} where T&lt;:AbstractFloat}">#</a> <b><u>Subzero.hashole</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hashole</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(poly</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Polys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Determine if polygon has one or more holes Inputs: poly &lt;Polygon&gt; polygon Outputs: &lt;Bool&gt; true if there is a hole in the polygons, else false</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.hashole-Union{Tuple{Array{Array{Vector{FT}, 1}, 1}}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#Subzero.hashole-Union{Tuple{Array{Array{Vector{FT}, 1}, 1}}, Tuple{FT}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.hashole</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hashole</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coords</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PolyVec{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Determine if polygon coordinates have one or more holes Inputs: coords &lt;PolyVec{Float}&gt; Outputs: &lt;Bool&gt;</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, PeriodicBoundary}" href="#Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, PeriodicBoundary}">#</a> <b><u>Subzero.in_bounds</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> in_bounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xr,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    yr,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>With all periodic boundaries, all points are considered to be in-bounds. Inputs: xr &lt;AbstractFloat&gt; point x-coordinate yr &lt;AbstractFloat&gt; point y-coordinate &lt;::PeriodicBoundary&gt; type of either north or south boundary - checking if periodic pair &lt;::PeriodicBoundary&gt; type of either east or west boundary - checking if periodic pair Output: Boolean that is true regardless of point values.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}" href="#Subzero.in_bounds-Tuple{Any, Any, Any, PeriodicBoundary, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}">#</a> <b><u>Subzero.in_bounds</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> in_bounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xr,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    yr,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NonPeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>With the east/west non-periodic boundaries, points outside of the grid in the x-direction are defined to be out of bounds since these points can&#39;t be interpolated as we don&#39;t have any information on the ocean outside of the grid. Inputs: xr &lt;AbstractFloat&gt; point x-coordinate yr &lt;AbstractFloat&gt; point y-coordinate &lt;::PeriodicBoundary&gt; type of either north or south boundary - checking if periodic pair &lt;::NonPeriodicBoundary&gt; type of either east or west boundary - checking if periodic pair Output: Boolean that is true if xr is within domain boundaries, and false otherwise.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}" href="#Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, PeriodicBoundary}">#</a> <b><u>Subzero.in_bounds</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> in_bounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xr,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    yr,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NonPeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>With the north/south non-periodic boundaries, points outside of the grid in the y-direction are defined to be out of bounds since these points can&#39;t be interpolated as we don&#39;t have any information on the ocean outside of the grid. Inputs: xr &lt;AbstractFloat&gt; point x-coordinate yr &lt;AbstractFloat&gt; point y-coordinate &lt;::NonPeriodicBoundary&gt; type of either north or south boundary - checking if periodic pair &lt;::PeriodicBoundary&gt; type of either east or west boundary - checking if periodic pair Output: Boolean that is true if yr is within domain boundaries, and false otherwise.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}" href="#Subzero.in_bounds-Tuple{Any, Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}">#</a> <b><u>Subzero.in_bounds</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">in_bounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xr,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    yr,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NonPeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NonPeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>With all non-periodic boundaries, points outside of the grid in both the x and y are defined to be out of bounds since these points can&#39;t be interpolated as we don&#39;t have any information on the ocean outside of the grid. Inputs: xr &lt;AbstractFloat&gt; point x-coordinate yr &lt;AbstractFloat&gt; point y-coordinate &lt;::NonPeriodicBoundary&gt; type of either north or south boundary - checking if periodic pair &lt;::NonPeriodicBoundary&gt; type of either east or west boundary - checking if periodic pair Output: Boolean that is true if both xr and yr are within domain boundaries, and false otherwise.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.initialize_floe_field-Tuple" href="#Subzero.initialize_floe_field-Tuple">#</a> <b><u>Subzero.initialize_floe_field</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">initialize_floe_field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A float type FT can be provided as the first argument of the initialize_floe_field constructor. A field of floes of type FT will be created by passing all other arguments to the correct method.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT" href="#Subzero.initialize_floe_field-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any}}} where FT">#</a> <b><u>Subzero.initialize_floe_field</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">initialize_floe_field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a type isn&#39;t specified, the field of Floes will each be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.initialize_jld2_file!-NTuple{5, Any}" href="#Subzero.initialize_jld2_file!-NTuple{5, Any}">#</a> <b><u>Subzero.initialize_jld2_file!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">initialize_jld2_file!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dir, filename, overwrite, outputs, jld2_kw)</span></span></code></pre></div><p>Initializes a JLD2 file in the given directory with the given filename. Setup file to write given outputs. Inputs: dir &lt;String&gt; path to directory filename &lt;String&gt; filename to save file to overwrite &lt;Bool&gt; if true, exit file of the same name will be deleted, else an error will be thrown if other file exists outputs &lt;Vector{Symbol}&gt; list of symbols to save as a group within the file jld2_kw list of JLD2 keywords for the jldopen function Outputs: Create JLD2 file dir/filename where each output is a group within the file</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.initialize_netcdf_file!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 6}}} where FT" href="#Subzero.initialize_netcdf_file!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 6}}} where FT">#</a> <b><u>Subzero.initialize_netcdf_file!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> initialize_netcdf_file!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dir,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    filename,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    overwrite,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    outputs,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xg,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    yg,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Initializes a NetCDF file in the given directory with the given filename. Setup file to write given outputs. Inputs: Type{FT} &lt;Type{AbstractFloat}&gt; type of float to run simulation calculations using dir &lt;String&gt; path to directory filename &lt;String&gt; filename to save file to overwrite &lt;Bool&gt; if true, exit file of the same name will be deleted, else an error will be thrown if other file exists outputs &lt;Vector{Symbol}&gt; list of symbols to save as a group within the file xg &lt;Vector{AbstractFloat}&gt; list of x grid lines yg &lt;Vector{AbstractFloat}&gt; list of y grid lines Outputs: Create NetCDF file dir/filename with each output added as a variable and with the dimensions time, x, and y.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.initialize_topography_field-Tuple" href="#Subzero.initialize_topography_field-Tuple">#</a> <b><u>Subzero.initialize_topography_field</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">initialize_topography_field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If a type isn&#39;t specified, the list of TopographyElements will each be of type Float64 and the correct constructor will be called with all other arguments.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.initialize_topography_field-Union{Tuple{FT}, Tuple{Type{FT}, Any}} where FT&lt;:AbstractFloat" href="#Subzero.initialize_topography_field-Union{Tuple{FT}, Tuple{Type{FT}, Any}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.initialize_topography_field</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">initialize_topography_field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    coords,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a field of topography from a list of polygon coordiantes. Inputs: Type{FT} &lt;AbstractFloat&gt; Type for grid&#39;s numberical fields - determines simulation run type coords &lt;Vector{PolyVec}&gt; list of polygon coords to make into floes Outputs: topo_arr &lt;StructArray{TopographyElement}&gt; list of topography elements created from given polygon coordinates</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.intersect_polys-Union{Tuple{FT}, Tuple{Any, Any}, Tuple{Any, Any, Type{FT}}} where FT" href="#Subzero.intersect_polys-Union{Tuple{FT}, Tuple{Any, Any}, Tuple{Any, Any, Type{FT}}} where FT">#</a> <b><u>Subzero.intersect_polys</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">intersect_polys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p1, p2)</span></span></code></pre></div><p>Intersect two geometries and return a list of polygons resulting. Inputs: p1 &lt;AbstractGeometry&gt; p2 &lt;AbstractGeometry&gt; Output: Vector of Polygons</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.level_to_string-Tuple{Any}" href="#Subzero.level_to_string-Tuple{Any}">#</a> <b><u>Subzero.level_to_string</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">level_to_string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(level)</span></span></code></pre></div><p>Returns string with log event name given log event level</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.mc_interpolation-NTuple{7, Any}" href="#Subzero.mc_interpolation-NTuple{7, Any}">#</a> <b><u>Subzero.mc_interpolation</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mc_interpolation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mc_cart,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mc_grid_idx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    atmos,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ocean,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    coupling_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create and returns interpolation objects for atmosphere u and v velocities, and ocean u and v velocities, in addition to ocean&#39;s heatflux factor. Inputs: npoints &lt;Int&gt; number of monte carlo points to consider - the number of rows to use in mc_cart and mc_grid_idx mc_cart &lt;Matrix{AbstractFloat}&gt; cartesian coordinates for model coordinates - nx2 matrix of monte carlo coordinates where first column is the x-coords and the second column is the y-coords mc_grid_idx &lt;Matrix{Int}&gt; index of monte carlo points within the grid - nx2 matrix of indices where the first column is the grid column index and the second column is the grid row index for cells centered on grid lines grid &lt;AbstractGrid&gt; model grid domain &lt;Domain&gt; model domain atmos &lt;Atmos&gt; model atmosphere ocean &lt;Ocean&gt; model ocean coupling_settings &lt;CouplingSettings&gt; simulation&#39;s coupling settings Outputs: uatm_interp &lt;Interplations object&gt; linear interpolation function from Interpolations.jl that takes in two arguments (x, y) and interpolates the atompshere u velocity onto point vatm_interp &lt;Interplations object&gt; linear interpolation function from Interpolations.jl that takes in two arguments (x, y) and interpolates the atompshere v velocity onto point uocn_interp &lt;Interplations object&gt; linear interpolation function from Interpolations.jl that takes in two arguments (x, y) and interpolates the ocean u velocity onto point vocn_interp &lt;Interplations object&gt; linear interpolation function from Interpolations.jl that takes in two arguments (x, y) and interpolates the ocean v velocity onto point hflx_interp &lt;Interplations object&gt; linear interpolation function from Interpolations.jl that takes in two arguments (x, y) and interpolates the ocean heatflux factor velocity onto point</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.normal_direction_correct!-Tuple{Any, Any, TopographyElement}" href="#Subzero.normal_direction_correct!-Tuple{Any, Any, TopographyElement}">#</a> <b><u>Subzero.normal_direction_correct!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">normal_direction_correct!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    forces,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fpoints,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TopographyElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>No forces should be zero-ed out in collidions with topography elements. Inputs: None used. Outputs: None.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{East, &lt;:AbstractFloat}}} where FT" href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{East, &lt;:AbstractFloat}}} where FT">#</a> <b><u>Subzero.normal_direction_correct!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">normal_direction_correct!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    forces,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fpoints,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    boundary</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractBoundary{East, &lt;:AbstractFloat}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Zero-out forces that point in direction not perpendicular to East boundary wall. See normal_direction_correct! on northern wall for more information</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{North, &lt;:AbstractFloat}}} where FT" href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{North, &lt;:AbstractFloat}}} where FT">#</a> <b><u>Subzero.normal_direction_correct!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">normal_direction_correct!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    forces,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fpoints,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    boundary</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractBoundary{North, &lt;:AbstractFloat}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Zero-out forces that point in direction not perpendicular to North boundary wall. Inputs: force &lt;Array{Float, n, 2}&gt; normal forces on each of the n regions greater than a minimum area fpoint &lt;Array{Float, n, 2}&gt; point force is applied on each of the n regions greater than a minimum area boundary &lt;AbstractBoundary{North, &lt;:AbstractFloat}&gt; domain&#39;s northern boundary Outputs: None. All forces in the x direction set to 0 if the point the force is applied to is in the northern boundary.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{South, &lt;:AbstractFloat}}} where FT" href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{South, &lt;:AbstractFloat}}} where FT">#</a> <b><u>Subzero.normal_direction_correct!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">normal_direction_correct!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    forces,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fpoints,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    boundary</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractBoundary{South, &lt;:AbstractFloat}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Zero-out forces that point in direction not perpendicular to South boundary wall. See normal_direction_correct! on northern wall for more information</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{West, &lt;:AbstractFloat}}} where FT" href="#Subzero.normal_direction_correct!-Union{Tuple{FT}, Tuple{Matrix{FT}, Any, AbstractBoundary{West, &lt;:AbstractFloat}}} where FT">#</a> <b><u>Subzero.normal_direction_correct!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">normal_direction_correct!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    forces,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fpoints,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    boundary</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractBoundary{&lt;:AbstractFloat, West}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Zero-out forces that point in direction not perpendicular to West boundary wall. See normal_direction_correct! on northern wall for more information</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.periodic_compat-Tuple{PeriodicBoundary, PeriodicBoundary}" href="#Subzero.periodic_compat-Tuple{PeriodicBoundary, PeriodicBoundary}">#</a> <b><u>Subzero.periodic_compat</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">periodic_compat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b1, b2)</span></span></code></pre></div><p>Checks if two boundaries are compatible as a periodic pair. This is true if they are both periodic, or if neither are periodic. Otherwise, it is false.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.plot_conservation-NTuple{7, Any}" href="#Subzero.plot_conservation-NTuple{7, Any}">#</a> <b><u>Subzero.plot_conservation</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">plot_conservation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    linear_energy,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rotational_energy,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    linear_x_momentum,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    linear_y_momentum,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    angular_spin_momentum,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    angular_orbital_momentum,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dir,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Takes in vectors of energy and momentum at each simulation timestep and plots conservation over time. Plots are saved to given directory. Also prints total change in both kinetic energy and momentum from beginning to end of simulation to terminal. Inputs: linear_energy &lt;Vector{Real}&gt; list of total energy from x and y motion per timestep rotational_energy &lt;Vector{Real}&gt; list of total energy from rotational motion per timestep linear_x_momentum &lt;Vector{Real}&gt; list of total momentum from x motion per timestep linear_y_momentum &lt;Vector{Real}&gt; list of total momentum from y motion per timestep angular_spin_momentum &lt;Vector{Real}&gt; list of total momentum from floes spinning around their own center of masses per timestep angular_orbital_momentum &lt;Vector{Real}&gt; list of total momentum from floes spinning around origin per timestep dir &lt;String&gt; directory to save images to Outputs: Δenergy &lt;Float&gt; % change in energy from first to last timestep Δxmomentum &lt;Float&gt; % change in x momentum from first to last timestep Δymomentum &lt;Float&gt; % change in y momentum from first to last timestep Δangularmomentum &lt;Float&gt; % change in angular momentum from first to last timestep Also saves energy and momentum plots over time to given directory</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.poly_to_floes!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat" href="#Subzero.poly_to_floes!-Union{Tuple{FT}, Tuple{Type{FT}, Vararg{Any, 5}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.poly_to_floes!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">poly_to_floes!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    poly,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hmean,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δh,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rmax;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Xoshiro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Split a given polygon around any holes before turning each region with an area greater than the minimum floe area into a floe. Inputs: Type{FT} &lt;AbstractFloat&gt; Type for grid&#39;s numberical fields - determines simulation run type floes &lt;StructArray{Floe}&gt; vector of floes to add new floes to poly &lt;Polygon&gt; polygons to turn into floes hmean &lt;AbstratFloat&gt; average floe height Δh &lt;AbstratFloat&gt; height range - floes will range in height from hmean - Δh to hmean + Δh rmax &lt;AbstractFloat&gt; maximum radius of floe (could be larger given context) floe_settings &lt;FloeSettings&gt; settings needed to initialize floe settings rng &lt;RNG&gt; random number generator to generate random floe attributes - default uses Xoshiro256++ algorithm kwargs... Any additional keywords to pass to floe constructor</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.potential_interaction-NTuple{4, Any}" href="#Subzero.potential_interaction-NTuple{4, Any}">#</a> <b><u>Subzero.potential_interaction</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">potential_interaction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    centroid1,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    centroid2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rmax1,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rmax2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Determine if two floes could potentially interact using the two centroid and two radii to form a bounding circle. Inputs: centroid1 &lt;Vector&gt; first floe&#39;s centroid [x, y] centroid2 &lt;Vector&gt; second floe&#39;s centroid [x, y] rmax1 &lt;Float&gt; first floe&#39;s maximum radius rmax2 &lt;Float&gt; second floe&#39;s maximum radius Outputs: &lt;Bool&gt; true if floes could potentially interact, false otherwise</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.prettytime-Tuple{Any}" href="#Subzero.prettytime-Tuple{Any}">#</a> <b><u>Subzero.prettytime</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prettytime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t)</span></span></code></pre></div><p>Turn time in seconds into units of minutes, hours, days, or years as appropriate</p><p><strong>Aguments:</strong></p><ul><li><code>t::Real</code>: number of seconds</li></ul><p><strong>Returns:</strong></p><ul><li><code>::String</code>: number of seconds converted to a string value in minutes, hours, days, or years with units</li></ul><p><strong>Note:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>This code was modified from the this [source code](https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/src/trials.jl).</span></span></code></pre></div><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.remove_floe_overlap!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT&lt;:AbstractFloat" href="#Subzero.remove_floe_overlap!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 10}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.remove_floe_overlap!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">remove_floe_overlap!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    shrink_idx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grow_floe_poly,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pieces_buffer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_floe_id,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    broken,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ridgeraft_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Removes area/volume of overlap from floe that loses area during ridging/rafting Inputs: floes &lt;StructArray{Floe}&gt; list of floes shrink_idx &lt;Int&gt; index of floe that loses area grow_floe_poly &lt;Polys&gt; polygon of floe/domain that subsumes area pieces_buffer &lt;StructArray{Floe}&gt; list of new floe pieces caused by breakage of floes max_floe_id &lt;Int&gt; maximum floe ID before this ridging/rafting broken &lt;Vector{Bool}&gt; floe index is true if that floe has broken in a previous ridge/raft interaction ridgeraft_settings &lt;RidgeRaftSettings&gt; simulation&#39;s ridge/raft settings floe_settings &lt;FloeSettings&gt; simulation&#39;s settings for making floes simp_settings &lt;SimplificationSettings&gt; simulation&#39;s simplification settings rng &lt;AbstractRNG&gt; random number generator Outputs: transfer_vol &lt;Float&gt; total volume to transfer away from floe max_floe_id &lt;Int&gt; maximum floe id of floe created during overlap removal floe_num &lt;Int&gt; total number of floes created from origianl floe -&gt; one if floe doesn&#39;t break, more otherwise</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.remove_floes!-NTuple{5, Any}" href="#Subzero.remove_floes!-NTuple{5, Any}">#</a> <b><u>Subzero.remove_floes!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">remove_floes!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dissolved,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Remove floes marked for removal and dissolve floes smaller than minimum floe area if the dissolve setting is on. Inputs: floes &lt;StructArray{Floe}&gt; model&#39;s floes grid &lt;AbstractGrid&gt; model&#39;s grid domain &lt;Domain&gt; model&#39;s domain dissolved &lt;Matrix{AbstractFloat}&gt; ocean&#39;s dissolved field floe_settings &lt;FloeSettings&gt; simulation&#39;s settings for making floes Outputs: None. Removes floes that do not continue to the next timestep and reset all continuing floes status to active.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.replace_floe!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT" href="#Subzero.replace_floe!-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT">#</a> <b><u>Subzero.replace_floe!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">replace_floe!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Floe{FT}, LazyRow{Floe{FT}}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    new_poly,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    new_mass,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Updates existing floe shape and related physical properties based of the polygon defining the floe. Inputs: floe &lt;Union{Floe, LazyRow{Floe}}&gt; floe to update new_poly &lt;Polygon&gt; polygon representing new outline of floe new_mass &lt;AbstractFloat&gt; mass of floe floe_settings &lt;FloeSettings&gt; simulation&#39;s settings for making floes rng &lt;RNG&gt; random number generator Ouputs: Updates a given floe&#39;s physical properties given new shape and total mass.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.restart!-NTuple{4, Any}" href="#Subzero.restart!-NTuple{4, Any}">#</a> <b><u>Subzero.restart!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">restart!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(initial_state_fn, checkpointer_fn, new_nΔt, new_output_writers; start_tstep </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Continue the simulation run started with the given initial state and floe file for an additional <code>new_nΔt</code> timesteps and with the new output_writers provided. The simulation will restart with a recorded timestep of <code>start_tstep</code>.</p><p>Note that this <code>restart!</code> function may not fit your needs and you may need to write your own. This function is meant to act as a simplest case and as a template for users to write their own restart functions.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.rotate_radians!-Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real, Any}" href="#Subzero.rotate_radians!-Tuple{Array{Array{Vector{T}, 1}, 1} where T&lt;:Real, Any}">#</a> <b><u>Subzero.rotate_radians!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rotate_radians!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coords</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PolyVec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, α)</span></span></code></pre></div><p>Rotate a polygon&#39;s coordinates by α radians around the origin. Inputs: coords &lt;PolyVec{AbstractFloat}&gt; polygon coordinates α &lt;Real&gt; radians to rotate the coordinates Outputs: Updates coordinates in place</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.run!-Tuple{Any}" href="#Subzero.run!-Tuple{Any}">#</a> <b><u>Subzero.run!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">run!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim; logger </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, messages_per_tstep </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, start_tstep </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Run given simulation and generate output for given writers. Simulation calculations will be done with Floats of type T (Float64 of Float32).</p><p>Inputs: sim &lt;Simulation&gt; simulation to Run logger &lt;AbstractLogger&gt; logger for simulation - default is Subzero logger messages_per_tstep &lt;Int&gt; number of messages to print per timestep if using default SubzeroLogger, else not needed start_tstep &lt;Int&gt; which timestep to start the simulation on Outputs: None. The simulation will be run and outputs will be saved in the output folder.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.shift_cell_idx-Tuple{Any, Any, PeriodicBoundary}" href="#Subzero.shift_cell_idx-Tuple{Any, Any, PeriodicBoundary}">#</a> <b><u>Subzero.shift_cell_idx</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">shift_cell_idx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(idx, nlines, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If index is greater than or equal to the grid lines, shift index to equivalent grid line on opposite side of grid due to periodic boundary. Similarly if given index is less than 1, shift index to equivalent grid line on opposite side of grid due to periodic boundary. Inputs: idx &lt;Int&gt; grid line index in either x or y nlines &lt;Int&gt; number of grid lines in model grid in either x or y direction &lt;PeriodicBoundary&gt; boundary pair is periodic Output: &lt;Int&gt; if given index is greater than or equal to number of grid lines, shift index. If given index is less than 1, shift grid index. For example, the last grid index, nlines, is equivalent to the 1st grid line. The nlines+1 grid line is equivalent to the 2nd grid line.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.shift_cell_idx-Tuple{Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}" href="#Subzero.shift_cell_idx-Tuple{Any, Any, Union{CollisionBoundary, MovingBoundary, OpenBoundary}}">#</a> <b><u>Subzero.shift_cell_idx</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">shift_cell_idx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(idx, nlines, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NonPeriodicBoundary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return index as is given non-periodic boundary pair in either x or y direction. Inputs: idx &lt;Int&gt; grid line index in either x or y nlines &lt;Int&gt; number of grid lines in model grid in either x or y direction &lt;NonPeriodicBoundary&gt; boundary pair is non-periodic Ouput: idx &lt;Int&gt; as given. Can include the index nlines, unlike with the periodic case, which will use the first index instead.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.simplify_floes!-NTuple{7, Any}" href="#Subzero.simplify_floes!-NTuple{7, Any}">#</a> <b><u>Subzero.simplify_floes!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simplify_floes!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    model,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    simp_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    collision_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Simplify the floe list be smoothing vertices, fusing floes, dissolving floes, and removing floes as needed. Inputs: model &lt;Model&gt; model max_floe_id &lt;Int&gt; maximum floe id in simulation simp_settings &lt;SimplificationSettings&gt; simulation&#39;s simplification settings collision_settings &lt;CollisionSettings&gt; simulation&#39;s collision settings floe_settings &lt;FloeSettings&gt; simulation&#39;s settings for making floes Δt &lt;Int&gt; simulation timestep in seconds rng &lt;RNG&gt; random number generator Outputs: Updates floe list and removes floe that won&#39;t continue to the next timestep</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.smooth_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT&lt;:AbstractFloat" href="#Subzero.smooth_floes!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{Floe{FT}}, Vararg{Any, 6}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.smooth_floes!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">smooth_floes!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    topography,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    simp_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    collision_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Smooths floe coordinates for floes with more vertices than the maximum allowed number. Uses Ramer–Douglas–Peucker algorithm with a user-defined tolerance. If new shape causes overlap greater with another floe greater than the maximum percentage allowed, mark the two floes for fusion. Inputs: floes &lt;StructArray{Floe}&gt; model&#39;s floes topography &lt;StructArray{TopographyElement}&gt; domain&#39;s topography simp_settings &lt;SimplificationSettings&gt; simulation&#39;s simplification settings collision_settings &lt;CollisionSettings&gt; simulation&#39;s collision settings Δt &lt;Int&gt; length of simulation timestep in seconds rng &lt;RNG&gt; random number generator for new monte carlo points</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.split_floe-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT" href="#Subzero.split_floe-Union{Tuple{FT}, Tuple{Union{Floe{FT}, StructArrays.LazyRow{Floe{FT}}}, Vararg{Any, 4}}} where FT">#</a> <b><u>Subzero.split_floe</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">split_floe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fracture_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Splits a given floe into pieces using voronoi tesselation. User will recieve a warning if floe isn&#39;t split. Inputs: floe &lt;Floe&gt; floe in simulation rng &lt;RNG&gt; random number generator used for voronoi tesselation fracture_settings &lt;FractureSettings&gt; simulation&#39;s fracture settings floe_settings &lt;FloeSettings&gt; simulation&#39;s settings for making floes Δt &lt;Int&gt; length of simulation timesteps in seconds Outputs: new_floes &lt;StructArray{Floes}&gt; list of pieces floe is split into, each of which is a new floe</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.startup_sim" href="#Subzero.startup_sim">#</a> <b><u>Subzero.startup_sim</u></b> — <i>Function</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">startup_sim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim)</span></span></code></pre></div><p>Required actions to setup simulation. For example, setting up the simulation logger. Inputs: sim &lt;Simulation&gt; logger &lt;AbstractLogger&gt; logger for simulation - default is Subzero logger messages_per_tstep &lt;Int&gt; number of messages to print per timestep if using default SubzeroLogger, else not needed Outputs: None.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.teardown_sim-Tuple{Any}" href="#Subzero.teardown_sim-Tuple{Any}">#</a> <b><u>Subzero.teardown_sim</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">teardown_sim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim)</span></span></code></pre></div><p>Required actions to tear down simulation. For example, flushing the simulation&#39;s logger and closing the stream. Inputs: sim &lt;Simulation&gt; Outputs: None.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.timestep_collisions!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 6}}} where FT&lt;:AbstractFloat" href="#Subzero.timestep_collisions!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Vararg{Any, 6}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.timestep_collisions!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">timestep_collisions!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    n_init_floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    consts,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    collision_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    spinlock,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Resolves collisions between pairs of floes and calculates the forces and torques caused by those collisions. Inputs: floes &lt;StructArray{Floe}&gt; model&#39;s list of floes n_init_floes &lt;Int&gt; number of floes without ghost floes domain &lt;Domain&gt; model&#39;s domain consts &lt;Constants&gt; simulation constants Δt &lt;Int&gt; length of simulation timestep in seconds collision_settings &lt;CollisionSettings&gt; simulation collision settings spinlock &lt;Thread.SpinLock&gt;</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.timestep_coupling!-NTuple{5, Any}" href="#Subzero.timestep_coupling!-NTuple{5, Any}">#</a> <b><u>Subzero.timestep_coupling!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">timestep_coupling!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    model,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    consts,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    coupling_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calculates the effects of the ocean and atmosphere on the ice and the effects of the ice and atmosphere on the ocean if the coupling is two-way. Inputs: model &lt;Model&gt; model Δt &lt;Int&gt; length of timestep in seconds consts &lt;Constants&gt; constants used in simulation coupling_settings &lt;CouplingSettings&gt; settings for coupling floe_settings &lt;FloeSettings&gt; settings for basic floe properties Outputs: None. Updates each floe&#39;s ocean/atmosphere forcings (fxOA, fyOA, torqueOA) and calculates stresses on each ocean grid cell from ice and atmosphere if two-way coupling is enabled in coupling_settings</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.timestep_floe_properties!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Any, Any}} where FT" href="#Subzero.timestep_floe_properties!-Union{Tuple{FT}, Tuple{StructArrays.StructArray{&lt;:Floe{FT}}, Any, Any, Any}} where FT">#</a> <b><u>Subzero.timestep_floe_properties!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">timestep_floe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(floe)</span></span></code></pre></div><p>Update floe position and velocities using second-order time stepping with tendencies calculated at previous timesteps. Height, mass, stress, and strain also updated based on previous timestep thermodynamics and interactions with other floes. Input: floe &lt;Floe&gt; Δt &lt;Int&gt; simulation timestep in second floe_settings &lt;FloeSettings&gt; simulation floe settings Output: None. Floe&#39;s fields are updated with values.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.timestep_ridging_rafting!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat" href="#Subzero.timestep_ridging_rafting!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, RidgeRaftSettings{FT}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.timestep_ridging_rafting!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">timestep_ridging_rafting!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pieces_buffer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_floe_id,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ridgeraft_settings</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RidgeRaftSettings{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    simp_settings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Ridge and raft floes that meet probability and height criteria. Inputs: floes &lt;StructArray{Floe}&gt; simulation&#39;s list of floes pieces_buffer &lt;StructArray{Floe}&gt; list of new floe pieces caused by breakage of floes domain &lt;Domain&gt; simulation&#39;s domain max_floe_id &lt;Int&gt; maximum floe ID before this ridging/rafting ridgeraft_settings &lt;RidgeRaftSettings&gt; ridge/raft settings floe_settings &lt;FloeSettings&gt; simulation&#39;s settings for making floes simp_settings &lt;SimplificationSettings&gt; simplification settings Δt &lt;Int&gt; length of timestep in seconds rng &lt;RandomNumberGenerator&gt; simulation&#39;s rng Outputs: Updates floes post ridging and rafting and adds any new pieces to the pieces buffer to be made into new floes.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.timestep_sim!" href="#Subzero.timestep_sim!">#</a> <b><u>Subzero.timestep_sim!</u></b> — <i>Function</i>. <p>timestep_sim!(sim, tstep, start_tstep)</p><p>Run one step of the simulation and write output. Inputs: sim &lt;Simulation&gt; simulation to advance tstep &lt;Int&gt; current timestep start_tstep &lt;Int&gt; timestep simulation started on Outputs: None. Simulation advances by one timestep.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.timestep_welding!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat" href="#Subzero.timestep_welding!-Union{Tuple{FT}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Any, Any, Any}, Tuple{Any, Any, Any, Any, WeldSettings{FT}, Vararg{Any, 4}}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.timestep_welding!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">timestep_welding!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max_floe_id,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grid,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    domain,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Nx,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Ny,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    weld_settings</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WeldSettings{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe_settings</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rng,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Weld floes within sections of the domain that meet overlap and size criteria together, ensuring resulting floe doesn&#39;t surpass maximum floe area. Inputs: floes &lt;StructArray{Floe}&gt; simulation&#39;s list of floes max_floe_id &lt;Int&gt; maximum floe ID before this welding grid &lt;RegRectilinearGrid&gt; simulation&#39;s grid domain &lt;Domain&gt; simulation&#39;s domain Nx &lt;Int&gt; number of grid cells in the x-direction to split domain into for welding groups Ny &lt;Int&gt; number of grid cells in the y-direction to split domain into for welding groups weld_settings &lt;WeldSettings&gt; welding settings floe_settings &lt;FloeSettings&gt; sim&#39;s settings for making new floes consts &lt;Consts&gt; simulation&#39;s constants Δt &lt;Int&gt; length of timestep in seconds rng &lt;RandomNumberGenerator&gt; simulation&#39;s rng Outputs: Returns nothing. Welds groups of floes together that meet requirments. Floes that are fused into other floes are marked for removal.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.translate!-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.translate!-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.translate!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">translate!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coords, Δx, Δy)</span></span></code></pre></div><p>Translate each of the given coodinates by given deltas in place Inputs: coords PolyVec{Float} vec &lt;Vector{Real}&gt; Output: Updates given coords</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.translate-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT&lt;:AbstractFloat" href="#Subzero.translate-Union{Tuple{FT}, Tuple{Array{Array{Vector{FT}, 1}, 1}, Any, Any}} where FT&lt;:AbstractFloat">#</a> <b><u>Subzero.translate</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">translate!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coords, Δx, Δy)</span></span></code></pre></div><p>Make a copy of given coordinates and translate by given deltas. Inputs: coords PolyVec{Float} vec &lt;Vector{Real}&gt; Output: Updates given coords</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.update_boundaries!-Tuple{Any, Any}" href="#Subzero.update_boundaries!-Tuple{Any, Any}">#</a> <b><u>Subzero.update_boundaries!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_boundaries!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(domain)</span></span></code></pre></div><p>Update each boundary in the domain. For now, this simply means moving compression boundaries by their velocities.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.update_boundary!-Tuple{Union{CollisionBoundary, OpenBoundary, PeriodicBoundary}, Any}" href="#Subzero.update_boundary!-Tuple{Union{CollisionBoundary, OpenBoundary, PeriodicBoundary}, Any}">#</a> <b><u>Subzero.update_boundary!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_boundary!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>No updates to boundaries that aren&#39;t compression boundaries.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D&lt;:Union{East, West}, FT&lt;:AbstractFloat}" href="#Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D&lt;:Union{East, West}, FT&lt;:AbstractFloat}">#</a> <b><u>Subzero.update_boundary!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_boundary!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(boundary, Δt)</span></span></code></pre></div><p>Move East/West compression boundaries by given velocity. Update coords and val fields to reflect new position. Inputs: boundary &lt;MovingBoundary{Union{East, West}, AbstractFloat}&gt; domain compression boundary Δt &lt;Int&gt; number of seconds in a timestep Outputs: None. Move boundary East/West depending on velocity.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D&lt;:Union{North, South}, FT&lt;:AbstractFloat}" href="#Subzero.update_boundary!-Union{Tuple{FT}, Tuple{D}, Tuple{MovingBoundary{D, FT}, Any}} where {D&lt;:Union{North, South}, FT&lt;:AbstractFloat}">#</a> <b><u>Subzero.update_boundary!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_boundary!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(boundary, Δt)</span></span></code></pre></div><p>Move North/South compression boundaries by given velocity. Update coords and val fields to reflect new position. Inputs: boundary &lt;MovingBoundary{Union{North, South}, AbstractFloat}&gt; domain compression boundary Δt &lt;Int&gt; number of seconds in a timestep Outputs: None. Move boundary North or South depending on velocity.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.update_criteria!-Tuple{MohrsCone, Any}" href="#Subzero.update_criteria!-Tuple{MohrsCone, Any}">#</a> <b><u>Subzero.update_criteria!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_criteria!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MohrsCone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, floes)</span></span></code></pre></div><p>Mohr&#39;s cone is not time or floe dependent so it doesn&#39;t need to be updates.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.update_criteria!-Union{Tuple{FT}, Tuple{HiblerYieldCurve{FT}, Any}} where FT" href="#Subzero.update_criteria!-Union{Tuple{FT}, Tuple{HiblerYieldCurve{FT}, Any}} where FT">#</a> <b><u>Subzero.update_criteria!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_criteria!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(criteria</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HiblerYieldCurve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, floes)</span></span></code></pre></div><p>Update the Hibler Yield Curve vertices based on the current set of floes. The criteria changes based off of the average height of the floes. Inputs: criteria &lt;HiblerYieldCurve&gt; simulation&#39;s fracture criteria floes &lt;StructArray{Floe}&gt; model&#39;s list of floes Outputs: None. Updates the criteria&#39;s vertices field to update new criteria.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.update_ghost_timestep_vals!-Tuple{Any, Any, Any}" href="#Subzero.update_ghost_timestep_vals!-Tuple{Any, Any, Any}">#</a> <b><u>Subzero.update_ghost_timestep_vals!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_ghost_timestep_vals!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(floes, idx, parent_idx)</span></span></code></pre></div><p>Update a parent floes and its ghosts to match velocities and accelerations at given index. Inputs: floes &lt;StructArray{Floe}&gt; list of floes in the simulation idx &lt;Int&gt; index of floe within floes list to copy to floe and ghosts parent_idx &lt;Int&gt; index of parent floe to update, along with its ghosts Outputs: Nothing. Update floe values.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.update_new_rotation_conserve!-NTuple{9, Any}" href="#Subzero.update_new_rotation_conserve!-NTuple{9, Any}">#</a> <b><u>Subzero.update_new_rotation_conserve!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_new_rotation_conserve!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x, y,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    floe1, floe2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    init_rot_momentum, init_p_rot_momentum,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    diff_orbital, diff_p_orbital,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Δt,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Update rotational velocities of two floes whose shapes may have changed to maintain conservation of momentum given the floes&#39; intial roational momentums and the change in orbital momentum between their original shape and new shapes. Additionally, both floes will have the same velocity at a given (x,y) point. Inputs: x &lt;Float&gt; x-coordinate of point where floes share same rotational velocity y &lt;Float&gt; y-coordinate of point where floes share same rotational velocity floe1 &lt;Union{Floe, LazyRow{Floe}}&gt; first floe in pair floe2 &lt;Union{Floe, LazyRow{Floe}}&gt; second floe in pair init_rot_momentum &lt;Float&gt; initial rotational momentum of floe 1 before shape change init_p_rot_momentum &lt;Float&gt; initial rotational momentum of floe 2 before shape change diff_orbital &lt;Float&gt; change in floe 1&#39;s orbital velocity after shape change diff_p_orbital &lt;Float&gt; change in floe 1&#39;s orbital velocity after shape change Δt &lt;Int&gt; length of timestep in seconds Output: Nothing. Update both floes&#39; rotational velocity, previous rotational velocity, and rotational acceleration to conserve angular momentum.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.valid_polyvec!-Tuple{Any}" href="#Subzero.valid_polyvec!-Tuple{Any}">#</a> <b><u>Subzero.valid_polyvec!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">valid_polyvec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coords</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PolyVec{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Takes a PolyVec object and make sure that the last element of each &quot;ring&quot; (vector of vector of floats) has the same first element as last element and has not duplicate adjacent elements. Also asserts that each &quot;ring&quot; as at least three distinct elements or else it is not a valid ring, but rather a line segment.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.valid_ringvec!-Tuple{Any}" href="#Subzero.valid_ringvec!-Tuple{Any}">#</a> <b><u>Subzero.valid_ringvec!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">valid_ringvec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coords</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RingVec{FT}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Takes a RingVec object and make sure that the last element has the same first element as last element and that other than these two elements there are no duplicate, adjacent vertices. Also asserts that the ring as at least three elements or else it cannot be made into a valid ring as it is a line segment.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.which_points_on_edges-Tuple{Any, Any}" href="#Subzero.which_points_on_edges-Tuple{Any, Any}">#</a> <b><u>Subzero.which_points_on_edges</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">which_points_on_edges</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(points, coords; atol </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1e-1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find which points are on the coordinates of the given polygon. Inputs: points &lt;Vector{Tuple{Float, Float} or Vector{Vector{Float}}}&gt; points to match to edges within polygon coords &lt;PolVec&gt; polygon coordinates atol &lt;Float&gt; distance target point can be from an edge before being classified as not on the edge</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.which_vertices_match_points-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Any}} where FT" href="#Subzero.which_vertices_match_points-Union{Tuple{FT}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}}, Tuple{Any, GeoInterface.Wrappers.Polygon{false, false, Array{GeoInterface.Wrappers.LinearRing{false, false, Array{Tuple{FT, FT}, 1}, Nothing, Nothing}, 1}, Nothing, Nothing}, Any}} where FT">#</a> <b><u>Subzero.which_vertices_match_points</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">which_vertices_match_points</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ipoints, coords, atol)</span></span></code></pre></div><p>Find which vertices in coords match given points Inputs: points &lt;Vector{Tuple{Float, Float} or Vector{Vector{Float}}}&gt; points to match to vertices within polygon region &lt;Polygon&gt; polygon atol &lt;Float&gt; distance vertex can be away from target point before being classified as different points Output: Vector{Int} indices of points in polygon that match the intersection points Note: If last coordinate is a repeat of first coordinate, last coordinate index is NOT recorded.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.write_checkpoint_data!-Tuple{Any, Any}" href="#Subzero.write_checkpoint_data!-Tuple{Any, Any}">#</a> <b><u>Subzero.write_checkpoint_data!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write_checkpoint_data!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim, tstep)</span></span></code></pre></div><p>Writes model&#39;s floe, ocean, and atmosphere data to JLD2 file. Data can be used to restart simulation run. Inputs: sim &lt;Simulation&gt; simulation to run tstep &lt;Int&gt; simulation timestep Output: Writes floes, ocean, and atmosphere to JLD2 file with name writer.fn for current timestep, which will be the group in the JLD2 file.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.write_data!-Tuple{Any, Any, Any}" href="#Subzero.write_data!-Tuple{Any, Any, Any}">#</a> <b><u>Subzero.write_data!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write_data!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim, tstep, start_tstep)</span></span></code></pre></div><p>Writes data for the simulation&#39;s writers that are due to write at given tstep. Inputs: sim &lt;Simulation&gt; simulation to run tstep &lt;Int&gt; simulation timestep start_tstep &lt;Int&gt; starting timestep of the simulation Output: Saves writer requested data to files specified in each writer.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.write_floe_data!-Tuple{Any, Any, Any}" href="#Subzero.write_floe_data!-Tuple{Any, Any, Any}">#</a> <b><u>Subzero.write_floe_data!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write_floe_data!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim, tstep)</span></span></code></pre></div><p>Writes desired FloeOutputWriter data to JLD2 file.</p><p>Inputs: writers &lt;StructArray{FloeWriter}&gt; list of floe writers floes &lt;StructArray{Floe}&gt; list of floes tstep &lt;Int&gt; simulation timestep Output: Writes desired fields writer.outputs to JLD2 file with name writer.fn for current timestep, which will be the group in the JLD2 file.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.write_grid_data!-NTuple{4, Any}" href="#Subzero.write_grid_data!-NTuple{4, Any}">#</a> <b><u>Subzero.write_grid_data!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write_grid_data!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim, tstep)</span></span></code></pre></div><p>Writes desired GridOutputWriter data to NetCDF file. Inputs: writers &lt;StructArray{GridWriter}&gt; list of grid writers floes &lt;StructArray{Floe}&gt; list of floes topography &lt;StructArray{TopographyElement}&gt; list of topography elements tstep &lt;Int&gt; simulation timestep Output: Writes desired fields writer.outputs to file with name writer.fn for current timestep.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="Subzero.write_init_state_data!-Tuple{Any}" href="#Subzero.write_init_state_data!-Tuple{Any}">#</a> <b><u>Subzero.write_init_state_data!</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write_init_state_data!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim, tstep)</span></span></code></pre></div><p>Save initial simulation state. Inputs: sim &lt;Simulation&gt; simulation to run tstep &lt;Int&gt; timestep - not used Outputs: Saves simulation state to file.</p><p><a href="https://github.com/Caltech-OCTO/Subzero.jl" target="_blank" rel="noreferrer">source</a></p></div><br></div></div></main><footer class="VPDocFooter" data-v-83890dd9 data-v-4f9813fa><!--[--><!--]--><div class="edit-info" data-v-4f9813fa><div class="edit-link" data-v-4f9813fa><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://https://github.com/Caltech-OCTO/Subzero.jl/edit/main/docs/src/api.md" target="_blank" rel="noreferrer" data-v-4f9813fa><!--[--><span class="vpi-square-pen edit-link-icon" data-v-4f9813fa></span> Edit this page<!--]--></a></div><!----></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-4f9813fa><span class="visually-hidden" id="doc-footer-aria-label" data-v-4f9813fa>Pager</span><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link prev" href="/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/introduction" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Previous page</span><span class="title" data-v-4f9813fa>Introduction</span><!--]--></a></div><div class="pager" data-v-4f9813fa><!----></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-a9a9e638 data-v-c970a860><div class="container" data-v-c970a860><p class="message" data-v-c970a860>Made with <a href="https://luxdl.github.io/DocumenterVitepress.jl/dev/" target="_blank"><strong>DocumenterVitepress.jl</strong></a><br></p><p class="copyright" data-v-c970a860>© Copyright 2024.</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"api.md\":\"CWneu1_y\",\"index.md\":\"o6WPgzn6\",\"introduction.md\":\"CIsf6dFf\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Subzero.jl\",\"description\":\"Documentation for Subzero.jl\",\"base\":\"/Caltech-OCTO.github.io/Subzero.jl/previews/PR102/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"outline\":\"deep\",\"search\":{\"provider\":\"local\",\"options\":{\"detailedView\":true}},\"nav\":[{\"text\":\"Home\",\"link\":\"/index\"},{\"text\":\"Introduction\",\"link\":\"/introduction\"},{\"text\":\"API Reference\",\"link\":\"/api\"}],\"sidebar\":[{\"text\":\"Home\",\"link\":\"/index\"},{\"text\":\"Introduction\",\"link\":\"/introduction\"},{\"text\":\"API Reference\",\"link\":\"/api\"}],\"editLink\":{\"pattern\":\"https://https://github.com/Caltech-OCTO/Subzero.jl/edit/main/docs/src/:path\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/Caltech-OCTO/Subzero.jl\"}],\"footer\":{\"message\":\"Made with <a href=\\\"https://luxdl.github.io/DocumenterVitepress.jl/dev/\\\" target=\\\"_blank\\\"><strong>DocumenterVitepress.jl</strong></a><br>\",\"copyright\":\"© Copyright 2024.\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>